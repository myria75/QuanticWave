[{
  "_id": {
    "$oid": "6563b5bd9c1f7ee332e16dda"
  },
  "id": "5f20e474-1f83-4e58-b960-755d244c6fbb",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_examples.python.teleport.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nQuantum teleportation example.\n\nNote: if you have only cloned the Qiskit repository but not\nused `pip install`, the examples only work from the root directory.\n\"\"\"\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit import BasicAer\nfrom qiskit import execute\n\n###############################################################\n# Set the backend name and coupling map.\n###############################################################\ncoupling_map = [[0, 1], [0, 2], [1, 2], [3, 2], [3, 4], [4, 2]]\nbackend = BasicAer.get_backend(\"qasm_simulator\")\n\n###############################################################\n# Make a quantum program for quantum teleportation.\n###############################################################\nq = QuantumRegister(3, \"q\")\nc0 = ClassicalRegister(1, \"c0\")\nc1 = ClassicalRegister(1, \"c1\")\nc2 = ClassicalRegister(1, \"c2\")\nqc = QuantumCircuit(q, c0, c1, c2, name=\"teleport\")\n\n# Prepare an initial state\nqc.u(0.3, 0.2, 0.1, q[0])\n\n# Prepare a Bell pair\nqc.h(q[1])\nqc.cx(q[1], q[2])\n\n# Barrier following state preparation\nqc.barrier(q)\n\n# Measure in the Bell basis\nqc.cx(q[0], q[1])\nqc.h(q[0])\nqc.measure(q[0], c0[0])\nqc.measure(q[1], c1[0])\n\n# Apply a correction\nqc.barrier(q)\nqc.z(q[2]).c_if(c0, 1)\nqc.x(q[2]).c_if(c1, 1)\nqc.measure(q[2], c2[0])\n\n###############################################################\n# Execute.\n# Experiment does not support feedback, so we use the simulator\n###############################################################\n\n# First version: not mapped\ninitial_layout = {q[0]: 0, q[1]: 1, q[2]: 2}\njob = execute(qc, backend=backend, coupling_map=None, shots=1024, initial_layout=initial_layout)\n\nresult = job.result()\nprint(result.get_counts(qc))\n\n# Second version: mapped to 2x8 array coupling graph\njob = execute(\n    qc, backend=backend, coupling_map=coupling_map, shots=1024, initial_layout=initial_layout\n)\nresult = job.result()\nprint(result.get_counts(qc))\n# Both versions should give the same distribution\n",
  "circuit": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 7
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 10
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0.7
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 701,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:26:07.543+00:00"
      },
      "value": 1
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 2,
          "column": 1,
          "fragment": "[[], [\"H\", {\"CONTROL\": 2}], [\"_\", \"X\"]]"
        }
      }
    ],
    "oracle": [
      {
        "id": 1,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[{\"ORACLE\": 1}]]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16dfc"
  },
  "id": "d180cbb5-d93f-4c0e-9f60-9ef549bd7e35",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.s.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The S, Sdg, CS and CSdg gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\nimport numpy\n\nfrom qiskit.circuit.singleton import SingletonGate, SingletonControlledGate, stdlib_singleton_key\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\n\n\n_S_ARRAY = numpy.array([[1, 0], [0, 1j]])\n_SDG_ARRAY = numpy.array([[1, 0], [0, -1j]])\n\n\n@with_gate_array(_S_ARRAY)\nclass SGate(SingletonGate):\n    r\"\"\"Single qubit S gate (Z**0.5).\n\n    It induces a :math:`\\pi/2` phase, and is sometimes called the P gate (phase).\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.s` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        S = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ S ├\n             └───┘\n\n    Equivalent to a :math:`\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create new S gate.\"\"\"\n        super().__init__(\"s\", 1, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        \"\"\"\n        gate s a { u1(pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of S (SdgGate).\"\"\"\n        return SdgGate()\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        from .p import PhaseGate\n\n        return PhaseGate(0.5 * numpy.pi * exponent)\n\n\n@with_gate_array(_SDG_ARRAY)\nclass SdgGate(SingletonGate):\n    r\"\"\"Single qubit S-adjoint gate (~Z**0.5).\n\n    It induces a :math:`-\\pi/2` phase.\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.sdg` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Sdg = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────┐\n        q_0: ┤ Sdg ├\n             └─────┘\n\n    Equivalent to a :math:`-\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create new Sdg gate.\"\"\"\n        super().__init__(\"sdg\", 1, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        \"\"\"\n        gate sdg a { u1(-pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(-pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of Sdg (SGate).\"\"\"\n        return SGate()\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        from .p import PhaseGate\n\n        return PhaseGate(-0.5 * numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_S_ARRAY, num_ctrl_qubits=1)\nclass CSGate(SingletonControlledGate):\n    r\"\"\"Controlled-S gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cs` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ S ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & i\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CS gate.\"\"\"\n        super().__init__(\n            \"cs\",\n            2,\n            [],\n            label=label,\n            num_ctrl_qubits=1,\n            ctrl_state=ctrl_state,\n            base_gate=SGate(label=_base_label),\n            duration=duration,\n            _base_label=_base_label,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=1)\n\n    def _define(self):\n        \"\"\"\n        gate cs a,b { h b; cp(pi/2) a,b; h b; }\n        \"\"\"\n        from .p import CPhaseGate\n\n        self.definition = CPhaseGate(theta=pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSGate (CSdgGate).\"\"\"\n        return CSdgGate(ctrl_state=self.ctrl_state)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        from .p import CPhaseGate\n\n        return CPhaseGate(0.5 * numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_SDG_ARRAY, num_ctrl_qubits=1)\nclass CSdgGate(SingletonControlledGate):\n    r\"\"\"Controlled-S^\\dagger gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.csdg` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ───■───\n             ┌──┴──┐\n        q_1: ┤ Sdg ├\n             └─────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS^\\dagger \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S^\\dagger \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -i\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CSdg gate.\"\"\"\n        super().__init__(\n            \"csdg\",\n            2,\n            [],\n            label=label,\n            num_ctrl_qubits=1,\n            ctrl_state=ctrl_state,\n            base_gate=SdgGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=1)\n\n    def _define(self):\n        \"\"\"\n        gate csdg a,b { h b; cp(-pi/2) a,b; h b; }\n        \"\"\"\n        from .p import CPhaseGate\n\n        self.definition = CPhaseGate(theta=-pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSdgGate (CSGate).\"\"\"\n        return CSGate(ctrl_state=self.ctrl_state)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        from .p import CPhaseGate\n\n        return CPhaseGate(-0.5 * numpy.pi * exponent)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16e3c"
  },
  "id": "bf67ee3f-14f0-4fc8-9867-7538f6c5035e",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.z.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Z, CZ and CCZ gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\nimport numpy\n\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\nfrom qiskit.circuit.singleton import SingletonGate, SingletonControlledGate, stdlib_singleton_key\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\nfrom .p import PhaseGate\n\n_Z_ARRAY = [[1, 0], [0, -1]]\n\n\n@with_gate_array(_Z_ARRAY)\nclass ZGate(SingletonGate):\n    r\"\"\"The single-qubit Pauli-Z gate (:math:`\\sigma_z`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.z` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Z = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -1\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Z ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Z axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RZ(\\pi)` and :math:`Z`.\n\n        .. math::\n\n            RZ(\\pi) = \\begin{pmatrix}\n                        -i & 0 \\\\\n                        0 & i\n                      \\end{pmatrix}\n                    = -i Z\n\n    The gate is equivalent to a phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow |0\\rangle \\\\\n        |1\\rangle \\rightarrow -|1\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create new Z gate.\"\"\"\n        super().__init__(\"z\", 1, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Z gate.\n\n        One control returns a CZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CZGate(label=label, ctrl_state=ctrl_state, _base_label=self.label)\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        \"\"\"Return inverted Z gate (itself).\"\"\"\n        return ZGate()  # self-inverse\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return PhaseGate(numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_Z_ARRAY, num_ctrl_qubits=1)\nclass CZGate(SingletonControlledGate):\n    r\"\"\"Controlled-Z gate.\n\n    This is a Clifford and symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CZ\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + Z \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubit is in the :math:`|1\\rangle` state.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CZ gate.\"\"\"\n        super().__init__(\n            \"cz\",\n            2,\n            [],\n            label=label,\n            num_ctrl_qubits=1,\n            ctrl_state=ctrl_state,\n            base_gate=ZGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=1)\n\n    def _define(self):\n        \"\"\"\n        gate cz a,b { h b; cx a,b; h b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .h import HGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (HGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CZ gate (itself).\"\"\"\n        return CZGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n\n@with_controlled_gate_array(_Z_ARRAY, num_ctrl_qubits=2, cached_states=(3,))\nclass CCZGate(SingletonControlledGate):\n    r\"\"\"CCZ gate.\n\n    This is a symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ccz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n              │\n        q_2: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CCZ\\ q_0, q_1, q_2 =\n            I \\otimes I \\otimes |0\\rangle\\langle 0| + CZ \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubits are in the :math:`|11\\rangle` state.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CCZ gate.\"\"\"\n        super().__init__(\n            \"ccz\",\n            3,\n            [],\n            label=label,\n            num_ctrl_qubits=2,\n            ctrl_state=ctrl_state,\n            base_gate=ZGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=2)\n\n    def _define(self):\n        \"\"\"\n        gate ccz a,b,c { h c; ccx a,b,c; h c; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .h import HGate\n        from .x import CCXGate\n\n        q = QuantumRegister(3, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[2]], []), (CCXGate(), [q[0], q[1], q[2]], []), (HGate(), [q[2]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CCZ gate (itself).\"\"\"\n        return CCZGate(ctrl_state=self.ctrl_state)  # self-inverse\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16e41"
  },
  "id": "f91c5cc8-2929-4eab-80be-5e7494b29baf",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.y.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Y and CY gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\n# pylint: disable=cyclic-import\nfrom qiskit.circuit.singleton import SingletonGate, SingletonControlledGate, stdlib_singleton_key\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\n\n_Y_ARRAY = [[0, -1j], [1j, 0]]\n\n\n@with_gate_array(_Y_ARRAY)\nclass YGate(SingletonGate):\n    r\"\"\"The single-qubit Pauli-Y gate (:math:`\\sigma_y`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.y` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Y = \\begin{pmatrix}\n                0 & -i \\\\\n                i & 0\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Y ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Y axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RY(\\pi)` and :math:`Y`.\n\n        .. math::\n\n            RY(\\pi) = \\begin{pmatrix}\n                        0 & -1 \\\\\n                        1 & 0\n                      \\end{pmatrix}\n                    = -i Y\n\n    The gate is equivalent to a bit and phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow i|1\\rangle \\\\\n        |1\\rangle \\rightarrow -i|0\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create new Y gate.\"\"\"\n        super().__init__(\"y\", 1, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, pi / 2, pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Y gate.\n\n        One control returns a CY gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CYGate(label=label, ctrl_state=ctrl_state, _base_label=self.label)\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted Y gate (:math:`Y^{\\dagger} = Y`)\"\"\"\n        return YGate()  # self-inverse\n\n\n@with_controlled_gate_array(_Y_ARRAY, num_ctrl_qubits=1)\nclass CYGate(SingletonControlledGate):\n    r\"\"\"Controlled-Y gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cy` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ Y ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CY\\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + Y \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & -i \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & i & 0 & 0\n            \\end{pmatrix}\n\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───┐\n            q_0: ┤ Y ├\n                 └─┬─┘\n            q_1: ──■──\n\n        .. math::\n\n            CY\\ q_1, q_0 =\n                |0 \\rangle\\langle 0| \\otimes I + |1 \\rangle\\langle 1| \\otimes Y =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & 0 & -i \\\\\n                    0 & 0 & i & 0\n                \\end{pmatrix}\n\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CY gate.\"\"\"\n        super().__init__(\n            \"cy\",\n            2,\n            [],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=YGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=1)\n\n    def _define(self):\n        \"\"\"\n        gate cy a,b { sdg b; cx a,b; s b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .s import SGate, SdgGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(SdgGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (SGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CY gate (itself).\"\"\"\n        return CYGate(ctrl_state=self.ctrl_state)  # self-inverse\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16e82"
  },
  "id": "cf234894-d56c-41fc-8512-080a885c3d4e",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_width_pass.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Width pass testing\"\"\"\n\nimport unittest\n\nfrom qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.transpiler.passes import Width\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestWidthPass(QiskitTestCase):\n    \"\"\"Tests for Depth analysis methods.\"\"\"\n\n    def test_empty_dag(self):\n        \"\"\"Empty DAG has 0 depth\"\"\"\n        circuit = QuantumCircuit()\n        dag = circuit_to_dag(circuit)\n\n        pass_ = Width()\n        _ = pass_.run(dag)\n\n        self.assertEqual(pass_.property_set[\"width\"], 0)\n\n    def test_just_qubits(self):\n        \"\"\"A dag with 8 operations and no classic bits\"\"\"\n        qr = QuantumRegister(2)\n        circuit = QuantumCircuit(qr)\n        circuit.h(qr[0])\n        circuit.h(qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[1], qr[0])\n        circuit.cx(qr[1], qr[0])\n        dag = circuit_to_dag(circuit)\n\n        pass_ = Width()\n        _ = pass_.run(dag)\n\n        self.assertEqual(pass_.property_set[\"width\"], 2)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 7
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 1.1428571428571428
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0.25
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 705,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:27:30.430+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 0,
          "fragment": "[[\"H\"], [\"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16e92"
  },
  "id": "76bb3145-7b2c-4858-9f12-4975593627b9",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.circuit.test_hamiltonian_gate.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"HamiltonianGate tests\"\"\"\n\nimport numpy as np\nfrom numpy.testing import assert_allclose\n\n\nimport qiskit\nfrom qiskit.circuit.library import HamiltonianGate, UnitaryGate\nfrom qiskit.test import QiskitTestCase\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import Operator\nfrom qiskit.converters import circuit_to_dag, dag_to_circuit\nfrom qiskit.circuit.exceptions import CircuitError\n\n\nclass TestHamiltonianGate(QiskitTestCase):\n    \"\"\"Tests for the HamiltonianGate class.\"\"\"\n\n    def test_set_matrix(self):\n        \"\"\"Test instantiation\"\"\"\n        hamiltonian = HamiltonianGate([[0, 1], [1, 0]], 1)\n        self.assertEqual(hamiltonian.num_qubits, 1)\n\n    def test_set_matrix_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        with self.assertRaises(ValueError):\n            HamiltonianGate([[1, 0], [1, 1]], 1)\n\n    def test_complex_time_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        with self.assertRaises(ValueError):\n            HamiltonianGate([[1, 0], [1, 1]], 1j)\n\n    def test_conjugate(self):\n        \"\"\"test conjugate\"\"\"\n        ham = HamiltonianGate([[0, 1j], [-1j, 2]], np.pi / 4)\n        np.testing.assert_array_almost_equal(ham.conjugate().to_matrix(), np.conj(ham.to_matrix()))\n\n    def test_transpose(self):\n        \"\"\"test transpose\"\"\"\n        ham = HamiltonianGate([[15, 1j], [-1j, -2]], np.pi / 7)\n        np.testing.assert_array_almost_equal(\n            ham.transpose().to_matrix(), np.transpose(ham.to_matrix())\n        )\n\n    def test_adjoint(self):\n        \"\"\"test adjoint operation\"\"\"\n        ham = HamiltonianGate([[3, 4j], [-4j, -0.2]], np.pi * 0.143)\n        np.testing.assert_array_almost_equal(\n            ham.adjoint().to_matrix(), np.transpose(np.conj(ham.to_matrix()))\n        )\n\n\nclass TestHamiltonianCircuit(QiskitTestCase):\n    \"\"\"Hamiltonian gate circuit tests.\"\"\"\n\n    def test_1q_hamiltonian(self):\n        \"\"\"test 1 qubit hamiltonian\"\"\"\n        qr = QuantumRegister(1, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = np.zeros((2, 2))\n        qc.x(qr[0])\n        theta = Parameter(\"theta\")\n        qc.append(HamiltonianGate(matrix, theta), [qr[0]])\n        qc = qc.assign_parameters({theta: 1})\n\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        dag_nodes = dag.named_nodes(\"hamiltonian\")\n        self.assertTrue(len(dag_nodes) == 1)\n        dnode = dag_nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, tuple(qc.qubits))\n        assert_allclose(dnode.op.to_matrix(), np.eye(2))\n\n    def test_error_and_deprecation_warning_on_qasm(self):\n        \"\"\"test that an error is thrown if the method `qasm` is called.\"\"\"\n        matrix = np.zeros((2, 2))\n        hamiltonian_gate = HamiltonianGate(data=matrix, time=1)\n        with self.assertRaises(CircuitError):\n            with self.assertWarns(DeprecationWarning):\n                hamiltonian_gate.qasm()\n\n    def test_2q_hamiltonian(self):\n        \"\"\"test 2 qubit hamiltonian\"\"\"\n        qr = QuantumRegister(2)\n        cr = ClassicalRegister(2)\n        qc = QuantumCircuit(qr, cr)\n        matrix = Operator.from_label(\"XY\")\n        qc.x(qr[0])\n        theta = Parameter(\"theta\")\n        uni2q = HamiltonianGate(matrix, theta)\n        qc.append(uni2q, [qr[0], qr[1]])\n        qc2 = qc.assign_parameters({theta: -np.pi / 2})\n        dag = circuit_to_dag(qc2)\n        nodes = dag.two_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1]))\n        # Equality based on Pauli exponential identity\n        np.testing.assert_array_almost_equal(dnode.op.to_matrix(), 1j * matrix.data)\n        qc3 = dag_to_circuit(dag)\n        self.assertEqual(qc2, qc3)\n\n    def test_3q_hamiltonian(self):\n        \"\"\"test 3 qubit hamiltonian on non-consecutive bits\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        qc.x(qr[0])\n        matrix = Operator.from_label(\"XZY\")\n        theta = Parameter(\"theta\")\n        uni3q = HamiltonianGate(matrix, theta)\n        qc.append(uni3q, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        # test of text drawer\n        self.log.info(qc)\n        qc = qc.assign_parameters({theta: -np.pi / 2})\n        dag = circuit_to_dag(qc)\n        nodes = dag.multi_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1], qr[3]))\n        np.testing.assert_almost_equal(dnode.op.to_matrix(), 1j * matrix.data)\n\n    def test_qobj_with_hamiltonian(self):\n        \"\"\"test qobj output with hamiltonian\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        qc.rx(np.pi / 4, qr[0])\n        matrix = Operator.from_label(\"XIZ\")\n        theta = Parameter(\"theta\")\n        uni = HamiltonianGate(matrix, theta, label=\"XIZ\")\n        qc.append(uni, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        qc = qc.assign_parameters({theta: np.pi / 2})\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[1]\n        self.assertEqual(instr.name, \"hamiltonian\")\n        # Also test label\n        self.assertEqual(instr.label, \"XIZ\")\n        np.testing.assert_array_almost_equal(\n            np.array(instr.params[0]).astype(np.complex64), matrix.data\n        )\n\n    def test_decomposes_into_correct_unitary(self):\n        \"\"\"test 2 qubit hamiltonian\"\"\"\n        qc = QuantumCircuit(2)\n        matrix = Operator.from_label(\"XY\")\n        theta = Parameter(\"theta\")\n        uni2q = HamiltonianGate(matrix, theta)\n        qc.append(uni2q, [0, 1])\n        qc = qc.assign_parameters({theta: -np.pi / 2}).decompose()\n        decomposed_ham = qc.data[0].operation\n        self.assertEqual(decomposed_ham, UnitaryGate(Operator.from_label(\"XY\")))\n",
  "circuit": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0.25
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 706,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T21:31:17.214+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16eb6"
  },
  "id": "89873d92-7acc-468e-8b53-ee337b497c82",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_crosstalk_adaptive_scheduler.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nTests for the CrosstalkAdaptiveSchedule transpiler pass.\n\"\"\"\n\nimport unittest\nfrom datetime import datetime\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.transpiler import Layout\nfrom qiskit.transpiler.passes.optimization import CrosstalkAdaptiveSchedule\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.compiler import transpile\nfrom qiskit.providers.models import BackendProperties\nfrom qiskit.providers.models.backendproperties import Nduv, Gate\nfrom qiskit.utils import optionals\n\n\ndef make_noisy_qubit(t_1=50.0, t_2=50.0):\n    \"\"\"Create a qubit for BackendProperties\"\"\"\n    calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n    return [\n        Nduv(name=\"T1\", date=calib_time, unit=\"µs\", value=t_1),\n        Nduv(name=\"T2\", date=calib_time, unit=\"µs\", value=t_2),\n        Nduv(name=\"frequency\", date=calib_time, unit=\"GHz\", value=5.0),\n        Nduv(name=\"readout_error\", date=calib_time, unit=\"\", value=0.01),\n    ]\n\n\ndef create_fake_machine():\n    \"\"\"Create a 6 qubit machine to test crosstalk adaptive schedules\"\"\"\n    calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n    qubit_list = []\n    for _ in range(6):\n        qubit_list.append(make_noisy_qubit())\n    cx01 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.05),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=500.0),\n    ]\n    cx12 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.05),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=501.0),\n    ]\n    cx23 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.05),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=502.0),\n    ]\n    cx34 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.05),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=503.0),\n    ]\n    cx45 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.05),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=504.0),\n    ]\n    gcx01 = Gate(name=\"CX0_1\", gate=\"cx\", parameters=cx01, qubits=[0, 1])\n    gcx12 = Gate(name=\"CX1_2\", gate=\"cx\", parameters=cx12, qubits=[1, 2])\n    gcx23 = Gate(name=\"CX2_3\", gate=\"cx\", parameters=cx23, qubits=[2, 3])\n    gcx34 = Gate(name=\"CX3_4\", gate=\"cx\", parameters=cx34, qubits=[3, 4])\n    gcx45 = Gate(name=\"CX4_5\", gate=\"cx\", parameters=cx45, qubits=[4, 5])\n    u_1 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.001),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=100.0),\n    ]\n    gu10 = Gate(name=\"u1_0\", gate=\"u1\", parameters=u_1, qubits=[0])\n    gu11 = Gate(name=\"u1_1\", gate=\"u1\", parameters=u_1, qubits=[1])\n    gu12 = Gate(name=\"u1_2\", gate=\"u1\", parameters=u_1, qubits=[2])\n    gu13 = Gate(name=\"u1_3\", gate=\"u1\", parameters=u_1, qubits=[3])\n    gu14 = Gate(name=\"u1_4\", gate=\"u1\", parameters=u_1, qubits=[4])\n    gu15 = Gate(name=\"u1_4\", gate=\"u1\", parameters=u_1, qubits=[5])\n    u_2 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.001),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=100.0),\n    ]\n    gu20 = Gate(name=\"u2_0\", gate=\"u2\", parameters=u_2, qubits=[0])\n    gu21 = Gate(name=\"u2_1\", gate=\"u2\", parameters=u_2, qubits=[1])\n    gu22 = Gate(name=\"u2_2\", gate=\"u2\", parameters=u_2, qubits=[2])\n    gu23 = Gate(name=\"u2_3\", gate=\"u2\", parameters=u_2, qubits=[3])\n    gu24 = Gate(name=\"u2_4\", gate=\"u2\", parameters=u_2, qubits=[4])\n    gu25 = Gate(name=\"u2_4\", gate=\"u2\", parameters=u_2, qubits=[5])\n    u_3 = [\n        Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.001),\n        Nduv(date=calib_time, name=\"gate_length\", unit=\"ns\", value=100.0),\n    ]\n    gu30 = Gate(name=\"u3_0\", gate=\"u3\", parameters=u_3, qubits=[0])\n    gu31 = Gate(name=\"u3_1\", gate=\"u3\", parameters=u_3, qubits=[1])\n    gu32 = Gate(name=\"u3_2\", gate=\"u3\", parameters=u_3, qubits=[2])\n    gu33 = Gate(name=\"u3_3\", gate=\"u3\", parameters=u_3, qubits=[3])\n    gu34 = Gate(name=\"u3_4\", gate=\"u3\", parameters=u_3, qubits=[4])\n    gu35 = Gate(name=\"u3_5\", gate=\"u3\", parameters=u_3, qubits=[5])\n\n    gate_list = [\n        gcx01,\n        gcx12,\n        gcx23,\n        gcx34,\n        gcx45,\n        gu10,\n        gu11,\n        gu12,\n        gu13,\n        gu14,\n        gu15,\n        gu20,\n        gu21,\n        gu22,\n        gu23,\n        gu24,\n        gu25,\n        gu30,\n        gu31,\n        gu32,\n        gu33,\n        gu34,\n        gu35,\n    ]\n\n    bprop = BackendProperties(\n        last_update_date=calib_time,\n        backend_name=\"test_backend\",\n        qubits=qubit_list,\n        backend_version=\"1.0.0\",\n        gates=gate_list,\n        general=[],\n    )\n    return bprop\n\n\n@unittest.skipIf(not optionals.HAS_Z3, \"z3-solver not installed.\")\nclass TestCrosstalk(QiskitTestCase):\n    \"\"\"\n    Tests for crosstalk adaptivity\n    \"\"\"\n\n    def test_schedule_length1(self):\n        \"\"\"Testing with high crosstalk between CNOT 0,1 and CNOT 2,3\"\"\"\n        bprop = create_fake_machine()\n        crosstalk_prop = {}\n        crosstalk_prop[(0, 1)] = {(2, 3): 0.2}\n        crosstalk_prop[(2, 3)] = {(0, 1): 0.05, (4, 5): 0.05}\n        crosstalk_prop[(4, 5)] = {(2, 3): 0.05}\n        crosstalk_prop[(1, 2)] = {(3, 4): 0.05}\n        crosstalk_prop[(3, 4)] = {(1, 2): 0.05}\n        qr = QuantumRegister(6, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[2], qr[3])\n        mapping = [0, 1, 2, 3, 4, 5]\n        layout = Layout({qr[i]: mapping[i] for i in range(6)})\n        new_circ = transpile(circuit, initial_layout=layout, basis_gates=[\"u1\", \"u2\", \"u3\", \"cx\"])\n        dag = circuit_to_dag(new_circ)\n        pass_ = CrosstalkAdaptiveSchedule(bprop, crosstalk_prop)\n        scheduled_dag = pass_.run(dag)\n        self.assertEqual(scheduled_dag.depth(), 3)\n\n    def test_schedule_length2(self):\n        \"\"\"Testing with no crosstalk between CNOT 0,1 and CNOT 2,3\"\"\"\n        bprop = create_fake_machine()\n        crosstalk_prop = {}\n        crosstalk_prop[(0, 1)] = {(2, 3): 0.05}\n        crosstalk_prop[(2, 3)] = {(0, 1): 0.05, (4, 5): 0.05}\n        crosstalk_prop[(4, 5)] = {(2, 3): 0.05}\n        crosstalk_prop[(1, 2)] = {(3, 4): 0.05}\n        crosstalk_prop[(3, 4)] = {(1, 2): 0.05}\n        qr = QuantumRegister(6, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[2], qr[3])\n        mapping = [0, 1, 2, 3, 4, 5]\n        layout = Layout({qr[i]: mapping[i] for i in range(6)})\n        new_circ = transpile(circuit, initial_layout=layout, basis_gates=[\"u1\", \"u2\", \"u3\", \"cx\"])\n        dag = circuit_to_dag(new_circ)\n        pass_ = CrosstalkAdaptiveSchedule(bprop, crosstalk_prop)\n        scheduled_dag = pass_.run(dag)\n        self.assertEqual(scheduled_dag.depth(), 1)\n\n    def test_schedule_length3(self):\n        \"\"\"Testing with repeated calls to run\"\"\"\n        bprop = create_fake_machine()\n        crosstalk_prop = {}\n        crosstalk_prop[(0, 1)] = {(2, 3): 0.2}\n        crosstalk_prop[(2, 3)] = {(0, 1): 0.05, (4, 5): 0.05}\n        crosstalk_prop[(4, 5)] = {(2, 3): 0.05}\n        crosstalk_prop[(1, 2)] = {(3, 4): 0.05}\n        crosstalk_prop[(3, 4)] = {(1, 2): 0.05}\n        qr = QuantumRegister(6, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[2], qr[3])\n        mapping = [0, 1, 2, 3, 4, 5]\n        layout = Layout({qr[i]: mapping[i] for i in range(6)})\n        new_circ = transpile(circuit, initial_layout=layout, basis_gates=[\"u1\", \"u2\", \"u3\", \"cx\"])\n        dag = circuit_to_dag(new_circ)\n        pass_ = CrosstalkAdaptiveSchedule(bprop, crosstalk_prop)\n        scheduled_dag1 = pass_.run(dag)\n        scheduled_dag2 = pass_.run(dag)\n        self.assertEqual(scheduled_dag1.depth(), 3)\n        self.assertEqual(scheduled_dag2.depth(), 3)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 707,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 1}], [\"X\"], [{\"CONTROL\": 3}], [\"X\"], [], []]"
        },
        "timestamp": "2023-11-26T21:34:06.296+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5be9c1f7ee332e16ef9"
  },
  "id": "d40fb694-9183-47b5-87de-9341af82bf44",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.randomized.test_synthesis.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Randomized tests of quantum synthesis.\"\"\"\nimport unittest\nfrom test.python.quantum_info.test_synthesis import CheckDecompositions\nfrom hypothesis import given, strategies, settings\nimport numpy as np\n\nfrom qiskit import execute\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.providers.basicaer import UnitarySimulatorPy\nfrom qiskit.quantum_info.random import random_unitary\nfrom qiskit.quantum_info.synthesis.two_qubit_decompose import (\n    two_qubit_cnot_decompose,\n    TwoQubitBasisDecomposer,\n    Ud,\n)\n\n\nclass TestSynthesis(CheckDecompositions):\n    \"\"\"Test synthesis\"\"\"\n\n    seed = strategies.integers(min_value=0, max_value=2**32 - 1)\n    rotation = strategies.floats(min_value=-np.pi * 10, max_value=np.pi * 10)\n\n    @given(seed)\n    def test_1q_random(self, seed):\n        \"\"\"Checks one qubit decompositions\"\"\"\n        unitary = random_unitary(2, seed=seed)\n        self.check_one_qubit_euler_angles(unitary)\n        self.check_one_qubit_euler_angles(unitary, \"U3\")\n        self.check_one_qubit_euler_angles(unitary, \"U1X\")\n        self.check_one_qubit_euler_angles(unitary, \"PSX\")\n        self.check_one_qubit_euler_angles(unitary, \"ZSX\")\n        self.check_one_qubit_euler_angles(unitary, \"ZYZ\")\n        self.check_one_qubit_euler_angles(unitary, \"ZXZ\")\n        self.check_one_qubit_euler_angles(unitary, \"XYX\")\n        self.check_one_qubit_euler_angles(unitary, \"RR\")\n\n    @settings(deadline=None)\n    @given(seed)\n    def test_2q_random(self, seed):\n        \"\"\"Checks two qubit decompositions\"\"\"\n        unitary = random_unitary(4, seed=seed)\n        self.check_exact_decomposition(unitary.data, two_qubit_cnot_decompose)\n\n    @given(strategies.tuples(*[seed] * 5))\n    def test_exact_supercontrolled_decompose_random(self, seeds):\n        \"\"\"Exact decomposition for random supercontrolled basis and random target\"\"\"\n        k1 = np.kron(random_unitary(2, seed=seeds[0]).data, random_unitary(2, seed=seeds[1]).data)\n        k2 = np.kron(random_unitary(2, seed=seeds[2]).data, random_unitary(2, seed=seeds[3]).data)\n        basis_unitary = k1 @ Ud(np.pi / 4, 0, 0) @ k2\n        decomposer = TwoQubitBasisDecomposer(UnitaryGate(basis_unitary))\n        self.check_exact_decomposition(random_unitary(4, seed=seeds[4]).data, decomposer)\n\n    @given(strategies.tuples(*[rotation] * 6), seed)\n    def test_cx_equivalence_0cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with  0 cx gates locally equivalent to identity.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 0)\n\n    @given(strategies.tuples(*[rotation] * 12), seed)\n    def test_cx_equivalence_1cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 1 cx gates locally equivalent to a cx.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 1)\n\n    @given(strategies.tuples(*[rotation] * 18), seed)\n    def test_cx_equivalence_2cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 2 cx gates locally equivalent to some circuit with 2 cx.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        qc.cx(qr[0], qr[1])\n\n        qc.u(rnd[12], rnd[13], rnd[14], qr[0])\n        qc.u(rnd[15], rnd[16], rnd[17], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 2)\n\n    @given(strategies.tuples(*[rotation] * 24), seed)\n    def test_cx_equivalence_3cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 3 cx gates are outside the 0, 1, and 2 qubit regions.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        qc.cx(qr[0], qr[1])\n\n        qc.u(rnd[12], rnd[13], rnd[14], qr[0])\n        qc.u(rnd[15], rnd[16], rnd[17], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[18], rnd[19], rnd[20], qr[0])\n        qc.u(rnd[21], rnd[22], rnd[23], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 3)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 7
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1.5714285714285714
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 11
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 709,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T21:38:27.600+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[{\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 1,
        "position": {
          "qubit": 1,
          "column": 0,
          "fragment": "[[], [{\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 2,
        "position": {
          "qubit": 0,
          "column": 2,
          "fragment": "[[\"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 3,
        "position": {
          "qubit": 1,
          "column": 2,
          "fragment": "[[], [\"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 4,
        "position": {
          "qubit": 0,
          "column": 4,
          "fragment": "[[\"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 5,
        "position": {
          "qubit": 1,
          "column": 4,
          "fragment": "[[], [\"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 6,
        "position": {
          "qubit": 0,
          "column": 6,
          "fragment": "[[\"_\", \"_\", \"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 7,
        "position": {
          "qubit": 1,
          "column": 6,
          "fragment": "[[], [\"_\", \"_\", \"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      }
    ],
    "uncompute": [
      {
        "id": 8,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e16f19"
  },
  "id": "0b25bc55-a04d-4813-8b7f-29a473c8f748",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.circuit.test_unitary.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"UnitaryGate tests\"\"\"\n\nimport json\nimport numpy\nfrom numpy.testing import assert_allclose\n\nimport qiskit\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.test import QiskitTestCase\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.transpiler import PassManager\nfrom qiskit.converters import circuit_to_dag, dag_to_circuit\nfrom qiskit.quantum_info.random import random_unitary\nfrom qiskit.quantum_info.operators import Operator\nfrom qiskit.transpiler.passes import CXCancellation\n\n\nclass TestUnitaryGate(QiskitTestCase):\n    \"\"\"Tests for the Unitary class.\"\"\"\n\n    def test_set_matrix(self):\n        \"\"\"Test instantiation\"\"\"\n        try:\n            UnitaryGate([[0, 1], [1, 0]])\n        # pylint: disable=broad-except\n        except Exception as err:\n            self.fail(f\"unexpected exception in init of Unitary: {err}\")\n\n    def test_set_matrix_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        try:\n            UnitaryGate([[1, 1], [1, 0]])\n        # pylint: disable=broad-except\n        except Exception:\n            pass\n        else:\n            self.fail(\"setting Unitary with non-unitary did not raise\")\n\n    def test_set_init_with_unitary(self):\n        \"\"\"test instantiation of new unitary with another one (copy)\"\"\"\n        uni1 = UnitaryGate([[0, 1], [1, 0]])\n        uni2 = UnitaryGate(uni1)\n        self.assertEqual(uni1, uni2)\n        self.assertFalse(uni1 is uni2)\n\n    def test_conjugate(self):\n        \"\"\"test conjugate\"\"\"\n        ymat = numpy.array([[0, -1j], [1j, 0]])\n        uni = UnitaryGate([[0, 1j], [-1j, 0]])\n        self.assertTrue(numpy.array_equal(uni.conjugate().to_matrix(), ymat))\n\n    def test_adjoint(self):\n        \"\"\"test adjoint operation\"\"\"\n        uni = UnitaryGate([[0, 1j], [-1j, 0]])\n        self.assertTrue(numpy.array_equal(uni.adjoint().to_matrix(), uni.to_matrix()))\n\n\nclass TestUnitaryCircuit(QiskitTestCase):\n    \"\"\"Matrix gate circuit tests.\"\"\"\n\n    def test_1q_unitary(self):\n        \"\"\"test 1 qubit unitary matrix\"\"\"\n        qr = QuantumRegister(1)\n        cr = ClassicalRegister(1)\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        qc.x(qr[0])\n        qc.append(UnitaryGate(matrix), [qr[0]])\n        # test of qasm output\n        self.log.info(qc.qasm())\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        dag_nodes = dag.named_nodes(\"unitary\")\n        self.assertTrue(len(dag_nodes) == 1)\n        dnode = dag_nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0],))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n\n    def test_2q_unitary(self):\n        \"\"\"test 2 qubit unitary matrix\"\"\"\n        qr = QuantumRegister(2)\n        cr = ClassicalRegister(2)\n        qc = QuantumCircuit(qr, cr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmax, sigmay)\n        qc.x(qr[0])\n        uni2q = UnitaryGate(matrix)\n        qc.append(uni2q, [qr[0], qr[1]])\n        passman = PassManager()\n        passman.append(CXCancellation())\n        qc2 = passman.run(qc)\n        # test of qasm output\n        self.log.info(qc2.qasm())\n        # test of text drawer\n        self.log.info(qc2)\n        dag = circuit_to_dag(qc)\n        nodes = dag.two_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1]))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n        qc3 = dag_to_circuit(dag)\n        self.assertEqual(qc2, qc3)\n\n    def test_3q_unitary(self):\n        \"\"\"test 3 qubit unitary matrix on non-consecutive bits\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmay, numpy.kron(sigmax, sigmay))\n        qc.x(qr[0])\n        uni3q = UnitaryGate(matrix)\n        qc.append(uni3q, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        nodes = dag.multi_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1], qr[3]))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n\n    def test_1q_unitary_int_qargs(self):\n        \"\"\"test single qubit unitary matrix with 'int' and 'list of ints' qubits argument\"\"\"\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmaz = numpy.array([[1, 0], [0, -1]])\n        # new syntax\n        qr = QuantumRegister(2)\n        qc = QuantumCircuit(qr)\n        qc.unitary(sigmax, 0)\n        qc.unitary(sigmax, qr[1])\n        qc.unitary(sigmaz, [0, 1])\n        # expected circuit\n        qc_target = QuantumCircuit(qr)\n        qc_target.append(UnitaryGate(sigmax), [0])\n        qc_target.append(UnitaryGate(sigmax), [qr[1]])\n        qc_target.append(UnitaryGate(sigmaz), [[0, 1]])\n        self.assertEqual(qc, qc_target)\n\n    def test_qobj_with_unitary_matrix(self):\n        \"\"\"test qobj output with unitary matrix\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmay, numpy.kron(sigmax, sigmay))\n        qc.rx(numpy.pi / 4, qr[0])\n        uni = UnitaryGate(matrix)\n        qc.append(uni, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[1]\n        self.assertEqual(instr.name, \"unitary\")\n        assert_allclose(numpy.array(instr.params[0]).astype(numpy.complex64), matrix)\n        # check conversion to dict\n        qobj_dict = qobj.to_dict()\n\n        class NumpyEncoder(json.JSONEncoder):\n            \"\"\"Class for encoding json str with complex and numpy arrays.\"\"\"\n\n            def default(self, obj):\n                if isinstance(obj, numpy.ndarray):\n                    return obj.tolist()\n                if isinstance(obj, complex):\n                    return (obj.real, obj.imag)\n                return json.JSONEncoder.default(self, obj)\n\n        # check json serialization\n        self.assertTrue(isinstance(json.dumps(qobj_dict, cls=NumpyEncoder), str))\n\n    def test_labeled_unitary(self):\n        \"\"\"test qobj output with unitary matrix\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmax, sigmay)\n        uni = UnitaryGate(matrix, label=\"xy\")\n        qc.append(uni, [qr[0], qr[1]])\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[0]\n        self.assertEqual(instr.name, \"unitary\")\n        self.assertEqual(instr.label, \"xy\")\n\n    def test_qasm_unitary_only_one_def(self):\n        \"\"\"test that a custom unitary can be converted to qasm and the\n        definition is only written once\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        unitary_gate = UnitaryGate(matrix)\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0]])\n        qc.append(unitary_gate, [qr[1]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate unitary q0 { u(0,0,0) q0; }\\n\"\n            \"qreg q0[2];\\ncreg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"unitary q0[0];\\n\"\n            \"unitary q0[1];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_unitary_twice(self):\n        \"\"\"test that a custom unitary can be converted to qasm and that if\n        the qasm is called twice it is the same every time\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        unitary_gate = UnitaryGate(matrix)\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0]])\n        qc.append(unitary_gate, [qr[1]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate unitary q0 { u(0,0,0) q0; }\\n\"\n            \"qreg q0[2];\\ncreg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"unitary q0[0];\\n\"\n            \"unitary q0[1];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_2q_unitary(self):\n        \"\"\"test that a 2 qubit custom unitary can be converted to qasm\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.asarray([[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0]])\n        unitary_gate = UnitaryGate(matrix)\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0], qr[1]])\n        qc.append(unitary_gate, [qr[1], qr[0]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate unitary q0,q1 { u(pi,-pi/2,pi/2) q0; u(pi,pi/2,-pi/2) q1; }\\n\"\n            \"qreg q0[2];\\n\"\n            \"creg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"unitary q0[0],q0[1];\\n\"\n            \"unitary q0[1],q0[0];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_unitary_noop(self):\n        \"\"\"Test that an identity unitary can be converted to OpenQASM 2\"\"\"\n        qc = QuantumCircuit(QuantumRegister(3, \"q0\"))\n        qc.unitary(numpy.eye(8), qc.qubits)\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate unitary q0,q1,q2 {  }\\n\"\n            \"qreg q0[3];\\n\"\n            \"unitary q0[0],q0[1],q0[2];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_unitary_decomposition(self):\n        \"\"\"Test decomposition for unitary gates over 2 qubits.\"\"\"\n        qc = QuantumCircuit(3)\n        qc.unitary(random_unitary(8, seed=42), [0, 1, 2])\n        self.assertTrue(Operator(qc).equiv(Operator(qc.decompose())))\n\n    def test_unitary_decomposition_via_definition(self):\n        \"\"\"Test decomposition for 1Q unitary via definition.\"\"\"\n        mat = numpy.array([[0, 1], [1, 0]])\n        self.assertTrue(numpy.allclose(Operator(UnitaryGate(mat).definition).data, mat))\n\n    def test_unitary_decomposition_via_definition_2q(self):\n        \"\"\"Test decomposition for 2Q unitary via definition.\"\"\"\n        mat = numpy.array([[0, 0, 1, 0], [0, 0, 0, -1], [1, 0, 0, 0], [0, -1, 0, 0]])\n        self.assertTrue(numpy.allclose(Operator(UnitaryGate(mat).definition).data, mat))\n\n    def test_unitary_control(self):\n        \"\"\"Test parameters of controlled - unitary.\"\"\"\n        mat = numpy.array([[0, 1], [1, 0]])\n        gate = UnitaryGate(mat).control()\n        self.assertTrue(numpy.allclose(gate.params, mat))\n        self.assertTrue(numpy.allclose(gate.base_gate.params, mat))\n",
  "circuit": "[[], [], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], [], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e16f1c"
  },
  "id": "92d19994-a4eb-4fbf-b74a-c04e4928ebb5",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.quantum_info.test_local_invariance.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n# pylint: disable=invalid-name\n\n\"\"\"Tests for local invariance routines.\"\"\"\n\nimport unittest\n\nfrom numpy.testing import assert_allclose\nfrom qiskit.execute_function import execute\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.providers.basicaer import UnitarySimulatorPy\nfrom qiskit.quantum_info.synthesis.local_invariance import two_qubit_local_invariants\n\n\nclass TestLocalInvariance(QiskitTestCase):\n    \"\"\"Test local invariance routines\"\"\"\n\n    def test_2q_local_invariance_simple(self):\n        \"\"\"Check the local invariance parameters\n        for known simple cases.\n        \"\"\"\n        sim = UnitarySimulatorPy()\n\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n        U = execute(qc, sim).result().get_unitary()\n        vec = two_qubit_local_invariants(U)\n        assert_allclose(vec, [1, 0, 3])\n\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n        qc.cx(qr[1], qr[0])\n        U = execute(qc, sim).result().get_unitary()\n        vec = two_qubit_local_invariants(U)\n        assert_allclose(vec, [0, 0, 1])\n\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n        qc.cx(qr[1], qr[0])\n        qc.cx(qr[0], qr[1])\n        U = execute(qc, sim).result().get_unitary()\n        vec = two_qubit_local_invariants(U)\n        assert_allclose(vec, [0, 0, -1])\n\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n        qc.swap(qr[1], qr[0])\n        U = execute(qc, sim).result().get_unitary()\n        vec = two_qubit_local_invariants(U)\n        assert_allclose(vec, [-1, 0, -3])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e16f54"
  },
  "id": "72c4f6b3-2867-40d3-9c1b-df39a77de583",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.u2.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"One-pulse single-qubit gate.\"\"\"\nfrom math import sqrt, pi\nfrom cmath import exp\nfrom typing import Optional\nimport numpy\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\n\nclass U2Gate(Gate):\n    r\"\"\"Single-qubit rotation about the X+Z axis.\n\n    Implemented using one X90 pulse on IBM Quantum systems:\n\n    .. warning::\n\n       This gate is deprecated. Instead, the following replacements should be used\n\n       .. math::\n\n           U2(\\phi, \\lambda) = U\\left(\\frac{\\pi}{2}, \\phi, \\lambda\\right)\n\n       .. code-block:: python\n\n          circuit = QuantumCircuit(1)\n          circuit.u(pi/2, phi, lambda)\n\n\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────────┐\n        q_0: ┤ U2(φ,λ) ├\n             └─────────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        U2(\\phi, \\lambda) = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1          & -e^{i\\lambda} \\\\\n                e^{i\\phi} & e^{i(\\phi+\\lambda)}\n            \\end{pmatrix}\n\n    **Examples:**\n\n    .. math::\n\n        U2(\\phi,\\lambda) = e^{i \\frac{\\phi + \\lambda}{2}}RZ(\\phi)\n        RY\\left(\\frac{\\pi}{2}\\right) RZ(\\lambda)\n        = e^{- i\\frac{\\pi}{4}} P\\left(\\frac{\\pi}{2} + \\phi\\right)\n        \\sqrt{X} P\\left(\\lambda- \\frac{\\pi}{2}\\right)\n\n    .. math::\n\n        U2(0, \\pi) = H\n\n    .. math::\n\n        U2(0, 0) = RY(\\pi/2)\n\n    .. math::\n\n        U2(-\\pi/2, \\pi/2) = RX(\\pi/2)\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.U3Gate`:\n        U3 is a generalization of U2 that covers all single-qubit rotations,\n        using two X90 pulses.\n    \"\"\"\n\n    def __init__(\n        self,\n        phi: ParameterValueType,\n        lam: ParameterValueType,\n        label: Optional[str] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n    ):\n        \"\"\"Create new U2 gate.\"\"\"\n        super().__init__(\"u2\", 1, [phi, lam], label=label, duration=duration, unit=unit)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi / 2, self.params[0], self.params[1]), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Return inverted U2 gate.\n\n        :math:`U2(\\phi, \\lambda)^{\\dagger} =U2(-\\lambda-\\pi, -\\phi+\\pi)`)\n        \"\"\"\n        return U2Gate(-self.params[1] - pi, -self.params[0] + pi)\n\n    def __array__(self, dtype=complex):\n        \"\"\"Return a Numpy.array for the U2 gate.\"\"\"\n        isqrt2 = 1 / sqrt(2)\n        phi, lam = self.params\n        phi, lam = float(phi), float(lam)\n        return numpy.array(\n            [\n                [isqrt2, -exp(1j * lam) * isqrt2],\n                [exp(1j * phi) * isqrt2, exp(1j * (phi + lam)) * isqrt2],\n            ],\n            dtype=dtype,\n        )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e16f8a"
  },
  "id": "14836737-a70a-44df-aafd-8605b59c524f",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.rz.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the Z axis.\"\"\"\nfrom cmath import exp\nfrom typing import Optional, Union\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RZGate(Gate):\n    r\"\"\"Single-qubit rotation about the Z axis.\n\n    This is a diagonal gate. It can be implemented virtually in hardware\n    via framechanges (i.e. at zero error and duration).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        RZ(\\lambda) = \\exp\\left(-i\\frac{\\lambda}{2}Z\\right) =\n            \\begin{pmatrix}\n                e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.U1Gate`\n        This gate is equivalent to U1 up to a phase factor.\n\n            .. math::\n\n                U1(\\lambda) = e^{i{\\lambda}/2}RZ(\\lambda)\n\n        Reference for virtual Z gate implementation:\n        `1612.00858 <https://arxiv.org/abs/1612.00858>`_\n    \"\"\"\n\n    def __init__(\n        self, phi: ParameterValueType, label: Optional[str] = None, *, duration=None, unit=\"dt\"\n    ):\n        \"\"\"Create new RZ gate.\"\"\"\n        super().__init__(\"rz\", 1, [phi], label=label, duration=duration, unit=unit)\n\n    def _define(self):\n        \"\"\"\n        gate rz(phi) a { u1(phi) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        theta = self.params[0]\n        qc = QuantumCircuit(q, name=self.name, global_phase=-theta / 2)\n        rules = [(U1Gate(theta), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRZGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RZ gate\n\n        :math:`RZ(\\lambda)^{\\dagger} = RZ(-\\lambda)`\n        \"\"\"\n        return RZGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RZ gate.\"\"\"\n        import numpy as np\n\n        ilam2 = 0.5j * float(self.params[0])\n        return np.array([[exp(-ilam2), 0], [0, exp(ilam2)]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        (theta,) = self.params\n        return RZGate(exponent * theta)\n\n\nclass CRZGate(ControlledGate):\n    r\"\"\"Controlled-RZ gate.\n\n    This is a diagonal but non-symmetric gate that induces a\n    phase on the state of the target qubit, depending on the control state.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.crz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CRZ(\\lambda)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RZ(\\lambda) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & e^{-i\\frac{\\lambda}{2}} & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Rz(λ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            CRZ(\\lambda)\\ q_1, q_0 =\n                |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes RZ(\\lambda) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                    0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n                \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.CU1Gate`:\n        Due to the global phase difference in the matrix definitions\n        of U1 and RZ, CU1 and CRZ are different gates with a relative\n        phase difference.\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CRZ gate.\"\"\"\n        super().__init__(\n            \"crz\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RZGate(theta, label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    def _define(self):\n        \"\"\"\n        gate crz(lambda) a,b\n        { rz(lambda/2) b; cx a,b;\n          rz(-lambda/2) b; cx a,b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate\n\n        # q_0: ─────────────■────────────────■──\n        #      ┌─────────┐┌─┴─┐┌──────────┐┌─┴─┐\n        # q_1: ┤ Rz(λ/2) ├┤ X ├┤ Rz(-λ/2) ├┤ X ├\n        #      └─────────┘└───┘└──────────┘└───┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RZGate(self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (RZGate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRZ gate (i.e. with the negative rotation angle).\"\"\"\n        return CRZGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRZ gate.\"\"\"\n        import numpy\n\n        arg = 1j * float(self.params[0]) / 2\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, exp(-arg), 0, 0], [0, 0, 1, 0], [0, 0, 0, exp(arg)]],\n                dtype=dtype,\n            )\n        else:\n            return numpy.array(\n                [[exp(-arg), 0, 0, 0], [0, 1, 0, 0], [0, 0, exp(arg), 0], [0, 0, 0, 1]],\n                dtype=dtype,\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e1702d"
  },
  "id": "410fd1a5-bc84-441c-855b-1aea465528d6",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_kak_over_optimization.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test KAK over optimization\"\"\"\n\nimport unittest\nimport numpy as np\nfrom qiskit import QuantumCircuit, QuantumRegister, transpile\nfrom qiskit.circuit.library import CU1Gate\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestKAKOverOptim(QiskitTestCase):\n    \"\"\"Tests to verify that KAK decomposition\n    does not over optimize.\n    \"\"\"\n\n    def test_cz_optimization(self):\n        \"\"\"Test that KAK does not run on a cz gate\"\"\"\n        qr = QuantumRegister(2)\n        qc = QuantumCircuit(qr)\n\n        qc.cz(qr[0], qr[1])\n\n        cz_circ = transpile(\n            qc,\n            None,\n            coupling_map=[[0, 1], [1, 0]],\n            basis_gates=[\"u1\", \"u2\", \"u3\", \"id\", \"cx\"],\n            optimization_level=3,\n        )\n        ops = cz_circ.count_ops()\n        self.assertEqual(ops[\"u2\"], 2)\n        self.assertEqual(ops[\"cx\"], 1)\n        self.assertFalse(\"u3\" in ops.keys())\n\n    def test_cu1_optimization(self):\n        \"\"\"Test that KAK does run on a cu1 gate and\n        reduces the cx count from two to one.\n        \"\"\"\n        qr = QuantumRegister(2)\n        qc = QuantumCircuit(qr)\n\n        qc.append(CU1Gate(np.pi), [qr[0], qr[1]])\n\n        cu1_circ = transpile(\n            qc,\n            None,\n            coupling_map=[[0, 1], [1, 0]],\n            basis_gates=[\"u1\", \"u2\", \"u3\", \"id\", \"cx\"],\n            optimization_level=3,\n        )\n        ops = cu1_circ.count_ops()\n        self.assertEqual(ops[\"cx\"], 1)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e17037"
  },
  "id": "19219cc1-79e9-469d-b55c-4e86a19e6d2a",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.converters.test_dag_to_dagdependency.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test for the converter dag dependency to dag circuit and\ndag circuit to dag dependency.\"\"\"\n\nimport unittest\n\nfrom qiskit.converters.circuit_to_dag import circuit_to_dag\nfrom qiskit.converters.dag_to_dagdependency import dag_to_dagdependency\nfrom qiskit.converters.dagdependency_to_dag import dagdependency_to_dag\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestCircuitToDagDependency(QiskitTestCase):\n    \"\"\"Test DAGCircuit to DAGDependency.\"\"\"\n\n    def test_circuit_and_dag_dependency(self):\n        \"\"\"Check convert to dag dependency and back\"\"\"\n        qr = QuantumRegister(3)\n        cr = ClassicalRegister(3)\n        circuit_in = QuantumCircuit(qr, cr)\n        circuit_in.h(qr[0])\n        circuit_in.h(qr[1])\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.x(qr[0]).c_if(cr, 0x3)\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.measure(qr[2], cr[2])\n        dag_in = circuit_to_dag(circuit_in)\n\n        dag_dependency = dag_to_dagdependency(dag_in)\n        dag_out = dagdependency_to_dag(dag_dependency)\n\n        self.assertEqual(dag_out, dag_in)\n\n    def test_circuit_and_dag_dependency2(self):\n        \"\"\"Check convert to dag dependency and back\n        also when the option ``create_preds_and_succs`` is False.\"\"\"\n        qr = QuantumRegister(3)\n        cr = ClassicalRegister(3)\n        circuit_in = QuantumCircuit(qr, cr)\n        circuit_in.h(qr[0])\n        circuit_in.h(qr[1])\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.x(qr[0]).c_if(cr, 0x3)\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.measure(qr[2], cr[2])\n        dag_in = circuit_to_dag(circuit_in)\n\n        dag_dependency = dag_to_dagdependency(dag_in, create_preds_and_succs=False)\n        dag_out = dagdependency_to_dag(dag_dependency)\n\n        self.assertEqual(dag_out, dag_in)\n\n    def test_metadata(self):\n        \"\"\"Test circuit metadata is preservered through conversion.\"\"\"\n        meta_dict = {\"experiment_id\": \"1234\", \"execution_number\": 4}\n        qr = QuantumRegister(2)\n        circuit_in = QuantumCircuit(qr, metadata=meta_dict)\n        circuit_in.h(qr[0])\n        circuit_in.cx(qr[0], qr[1])\n        circuit_in.measure_all()\n        dag = circuit_to_dag(circuit_in)\n        self.assertEqual(dag.metadata, meta_dict)\n        dag_dependency = dag_to_dagdependency(dag)\n        self.assertEqual(dag_dependency.metadata, meta_dict)\n        dag_out = dagdependency_to_dag(dag_dependency)\n        self.assertEqual(dag_out.metadata, meta_dict)\n\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 717,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:25.530+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5bf9c1f7ee332e17038"
  },
  "id": "2b0bdfb3-7737-416a-8177-0ff813330f98",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_basic_swap.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the BasicSwap pass\"\"\"\n\nimport unittest\nfrom qiskit.transpiler.passes import BasicSwap\nfrom qiskit.transpiler.passmanager import PassManager\nfrom qiskit.transpiler.layout import Layout\nfrom qiskit.transpiler import CouplingMap, Target\nfrom qiskit.circuit.library import CXGate\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestBasicSwap(QiskitTestCase):\n    \"\"\"Tests the BasicSwap pass.\"\"\"\n\n    def test_trivial_case(self):\n        \"\"\"No need to have any swap, the CX are distance 1 to each other\n        q0:--(+)-[U]-(+)-\n              |       |\n        q1:---.-------|--\n                      |\n        q2:-----------.--\n\n        CouplingMap map: [1]--[0]--[2]\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.h(qr[0])\n        circuit.cx(qr[0], qr[2])\n\n        dag = circuit_to_dag(circuit)\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(dag, after)\n\n    def test_trivial_in_same_layer(self):\n        \"\"\"No need to have any swap, two CXs distance 1 to each other, in the same layer\n        q0:--(+)--\n              |\n        q1:---.---\n\n        q2:--(+)--\n              |\n        q3:---.---\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[2], qr[3])\n        circuit.cx(qr[0], qr[1])\n\n        dag = circuit_to_dag(circuit)\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(dag, after)\n\n    def test_a_single_swap(self):\n        \"\"\"Adding a swap\n        q0:-------\n\n        q1:--(+)--\n              |\n        q2:---.---\n\n        CouplingMap map: [1]--[0]--[2]\n\n        q0:--X---.---\n             |   |\n        q1:--X---|---\n                 |\n        q2:-----(+)--\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[1], qr[2])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[1], qr[0])\n        expected.cx(qr[0], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_a_single_swap_with_target(self):\n        \"\"\"Adding a swap\n        q0:-------\n\n        q1:--(+)--\n              |\n        q2:---.---\n\n        CouplingMap map: [1]--[0]--[2]\n\n        q0:--X---.---\n             |   |\n        q1:--X---|---\n                 |\n        q2:-----(+)--\n\n        \"\"\"\n        target = Target()\n        target.add_instruction(CXGate(), {(0, 1): None, (0, 2): None})\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[1], qr[2])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[1], qr[0])\n        expected.cx(qr[0], qr[2])\n\n        pass_ = BasicSwap(target)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_a_single_swap_bigger_cm(self):\n        \"\"\"Swapper in a bigger coupling map\n        q0:-------\n\n        q1:---.---\n              |\n        q2:--(+)--\n\n        CouplingMap map: [1]--[0]--[2]--[3]\n\n        q0:--X---.---\n             |   |\n        q1:--X---|---\n                 |\n        q2:-----(+)--\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2], [2, 3]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[1], qr[2])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[1], qr[0])\n        expected.cx(qr[0], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_keep_layout(self):\n        \"\"\"After a swap, the following gates also change the wires.\n        qr0:---.---[H]--\n               |\n        qr1:---|--------\n               |\n        qr2:--(+)-------\n\n        CouplingMap map: [0]--[1]--[2]\n\n        qr0:--X-----------\n              |\n        qr1:--X---.--[H]--\n                  |\n        qr2:-----(+)------\n        \"\"\"\n        coupling = CouplingMap([[1, 0], [1, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[2])\n        circuit.h(qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[0], qr[1])\n        expected.cx(qr[1], qr[2])\n        expected.h(qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap(self):\n        \"\"\"A far swap that affects coming CXs.\n        qr0:--(+)---.--\n               |    |\n        qr1:---|----|--\n               |    |\n        qr2:---|----|--\n               |    |\n        qr3:---.---(+)-\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        qr0:--X--------------\n              |\n        qr1:--X--X-----------\n                 |\n        qr2:-----X--(+)---.--\n                     |    |\n        qr3:---------.---(+)-\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[3])\n        circuit.cx(qr[3], qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[0], qr[1])\n        expected.swap(qr[1], qr[2])\n        expected.cx(qr[2], qr[3])\n        expected.cx(qr[3], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_front(self):\n        \"\"\"A far swap with a gate in the front.\n        q0:------(+)--\n                  |\n        q1:-------|---\n                  |\n        q2:-------|---\n                  |\n        q3:--[H]--.---\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-----------(+)--\n                       |\n        q1:---------X--.---\n                    |\n        q2:------X--X------\n                 |\n        q3:-[H]--X---------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.h(qr[3])\n        circuit.cx(qr[3], qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.h(qr[3])\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_back(self):\n        \"\"\"A far swap with a gate in the back.\n        q0:--(+)------\n              |\n        q1:---|-------\n              |\n        q2:---|-------\n              |\n        q3:---.--[H]--\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-------(+)------\n                   |\n        q1:-----X--.--[H]--\n                |\n        q2:--X--X----------\n             |\n        q3:--X-------------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[3], qr[0])\n        circuit.h(qr[3])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n        expected.h(qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_middle(self):\n        \"\"\"A far swap with a gate in the middle.\n        q0:--(+)-------.--\n              |        |\n        q1:---|--------|--\n              |\n        q2:---|--------|--\n              |        |\n        q3:---.--[H]--(+)-\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-------(+)-------.---\n                   |        |\n        q1:-----X--.--[H]--(+)--\n                |\n        q2:--X--X---------------\n             |\n        q3:--X------------------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[3], qr[0])\n        circuit.h(qr[3])\n        circuit.cx(qr[0], qr[3])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n        expected.h(qr[1])\n        expected.cx(qr[0], qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_fake_run(self):\n        \"\"\"A fake run, doesn't change dag\n        q0:--(+)-------.--\n              |        |\n        q1:---|--------|--\n              |\n        q2:---|--------|--\n              |        |\n        q3:---.--[H]--(+)-\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-------(+)-------.---\n                   |        |\n        q1:-----X--.--[H]--(+)--\n                |\n        q2:--X--X---------------\n             |\n        q3:--X------------------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[3], qr[0])\n        circuit.h(qr[3])\n        circuit.cx(qr[0], qr[3])\n\n        fake_pm = PassManager([BasicSwap(coupling, fake_run=True)])\n        real_pm = PassManager([BasicSwap(coupling, fake_run=False)])\n\n        self.assertEqual(circuit, fake_pm.run(circuit))\n        self.assertNotEqual(circuit, real_pm.run(circuit))\n        self.assertIsInstance(fake_pm.property_set[\"final_layout\"], Layout)\n        self.assertEqual(fake_pm.property_set[\"final_layout\"], real_pm.property_set[\"final_layout\"])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 718,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}], [], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:47:39.114+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170ac"
  },
  "id": "4784c359-f619-416e-92fe-17825122259e",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.r.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around an axis in x-y plane.\"\"\"\n\nimport math\nfrom cmath import exp\nfrom math import pi\nfrom typing import Optional\nimport numpy\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RGate(Gate):\n    r\"\"\"Rotation θ around the cos(φ)x + sin(φ)y axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.r` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌──────┐\n        q_0: ┤ R(ϴ) ├\n             └──────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        R(\\theta, \\phi) = e^{-i \\th \\left(\\cos{\\phi} x + \\sin{\\phi} y\\right)} =\n            \\begin{pmatrix}\n                \\cos\\left(\\th\\right) & -i e^{-i \\phi} \\sin\\left(\\th\\right) \\\\\n                -i e^{i \\phi} \\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        phi: ParameterValueType,\n        label: Optional[str] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n    ):\n        \"\"\"Create new r single-qubit gate.\"\"\"\n        super().__init__(\"r\", 1, [theta, phi], label=label, duration=duration, unit=unit)\n\n    def _define(self):\n        \"\"\"\n        gate r(θ, φ) a {u3(θ, φ - π/2, -φ + π/2) a;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        theta = self.params[0]\n        phi = self.params[1]\n        rules = [(U3Gate(theta, phi - pi / 2, -phi + pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Invert this gate.\n\n        r(θ, φ)^dagger = r(-θ, φ)\n        \"\"\"\n        return RGate(-self.params[0], self.params[1])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the R gate.\"\"\"\n        theta, phi = float(self.params[0]), float(self.params[1])\n        cos = math.cos(theta / 2)\n        sin = math.sin(theta / 2)\n        exp_m = exp(-1j * phi)\n        exp_p = exp(1j * phi)\n        return numpy.array([[cos, -1j * exp_m * sin], [-1j * exp_p * sin, cos]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        theta, phi = self.params\n        return RGate(exponent * theta, phi)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170d1"
  },
  "id": "d9d9b97c-a73b-4d84-88aa-3645abf9cc13",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_lookahead_swap.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the LookaheadSwap pass\"\"\"\n\nimport unittest\nfrom numpy import pi\nfrom qiskit.dagcircuit import DAGCircuit\nfrom qiskit.transpiler.passes import LookaheadSwap\nfrom qiskit.transpiler import CouplingMap, Target\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.circuit.library import CXGate\nfrom qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.providers.fake_provider import FakeMelbourne\n\n\nclass TestLookaheadSwap(QiskitTestCase):\n    \"\"\"Tests the LookaheadSwap pass.\"\"\"\n\n    def test_lookahead_swap_doesnt_modify_mapped_circuit(self):\n        \"\"\"Test that lookahead swap is idempotent.\n\n        It should not modify a circuit which is already compatible with the\n        coupling map, and can be applied repeatedly without modifying the circuit.\n        \"\"\"\n\n        qr = QuantumRegister(3, name=\"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[2])\n        circuit.cx(qr[0], qr[1])\n        original_dag = circuit_to_dag(circuit)\n\n        # Create coupling map which contains all two-qubit gates in the circuit.\n        coupling_map = CouplingMap([[0, 1], [0, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(original_dag)\n\n        self.assertEqual(original_dag, mapped_dag)\n\n        remapped_dag = LookaheadSwap(coupling_map).run(mapped_dag)\n\n        self.assertEqual(mapped_dag, remapped_dag)\n\n    def test_lookahead_swap_should_add_a_single_swap(self):\n        \"\"\"Test that LookaheadSwap will insert a SWAP to match layout.\n\n        For a single cx gate which is not available in the current layout, test\n        that the mapper inserts a single swap to enable the gate.\n        \"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[2])\n        dag_circuit = circuit_to_dag(circuit)\n\n        coupling_map = CouplingMap([[0, 1], [1, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(dag_circuit)\n\n        self.assertEqual(\n            mapped_dag.count_ops().get(\"swap\", 0), dag_circuit.count_ops().get(\"swap\", 0) + 1\n        )\n\n    def test_lookahead_swap_finds_minimal_swap_solution(self):\n        \"\"\"Of many valid SWAPs, test that LookaheadSwap finds the cheapest path.\n\n        For a two CNOT circuit: cx q[0],q[2]; cx q[0],q[1]\n        on the initial layout: qN -> qN\n        (At least) two solutions exist:\n        - SWAP q[0],[1], cx q[0],q[2], cx q[0],q[1]\n        - SWAP q[1],[2], cx q[0],q[2], SWAP q[1],q[2], cx q[0],q[1]\n\n        Verify that we find the first solution, as it requires fewer SWAPs.\n        \"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[2])\n        circuit.cx(qr[0], qr[1])\n\n        dag_circuit = circuit_to_dag(circuit)\n\n        coupling_map = CouplingMap([[0, 1], [1, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(dag_circuit)\n\n        self.assertEqual(\n            mapped_dag.count_ops().get(\"swap\", 0), dag_circuit.count_ops().get(\"swap\", 0) + 1\n        )\n\n    def test_lookahead_swap_maps_measurements(self):\n        \"\"\"Verify measurement nodes are updated to map correct cregs to re-mapped qregs.\n\n        Create a circuit with measures on q0 and q2, following a swap between q0 and q2.\n        Since that swap is not in the coupling, one of the two will be required to move.\n        Verify that the mapped measure corresponds to one of the two possible layouts following\n        the swap.\n\n        \"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        cr = ClassicalRegister(2)\n        circuit = QuantumCircuit(qr, cr)\n\n        circuit.cx(qr[0], qr[2])\n        circuit.measure(qr[0], cr[0])\n        circuit.measure(qr[2], cr[1])\n\n        dag_circuit = circuit_to_dag(circuit)\n\n        coupling_map = CouplingMap([[0, 1], [1, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(dag_circuit)\n\n        mapped_measure_qargs = {op.qargs[0] for op in mapped_dag.named_nodes(\"measure\")}\n\n        self.assertIn(mapped_measure_qargs, [{qr[0], qr[1]}, {qr[1], qr[2]}])\n\n    def test_lookahead_swap_maps_measurements_with_target(self):\n        \"\"\"Verify measurement nodes are updated to map correct cregs to re-mapped qregs.\n\n        Create a circuit with measures on q0 and q2, following a swap between q0 and q2.\n        Since that swap is not in the coupling, one of the two will be required to move.\n        Verify that the mapped measure corresponds to one of the two possible layouts following\n        the swap.\n\n        \"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        cr = ClassicalRegister(2)\n        circuit = QuantumCircuit(qr, cr)\n\n        circuit.cx(qr[0], qr[2])\n        circuit.measure(qr[0], cr[0])\n        circuit.measure(qr[2], cr[1])\n\n        dag_circuit = circuit_to_dag(circuit)\n\n        target = Target()\n        target.add_instruction(CXGate(), {(0, 1): None, (1, 2): None})\n\n        mapped_dag = LookaheadSwap(target).run(dag_circuit)\n\n        mapped_measure_qargs = {op.qargs[0] for op in mapped_dag.named_nodes(\"measure\")}\n\n        self.assertIn(mapped_measure_qargs, [{qr[0], qr[1]}, {qr[1], qr[2]}])\n\n    def test_lookahead_swap_maps_barriers(self):\n        \"\"\"Verify barrier nodes are updated to re-mapped qregs.\n\n        Create a circuit with a barrier on q0 and q2, following a swap between q0 and q2.\n        Since that swap is not in the coupling, one of the two will be required to move.\n        Verify that the mapped barrier corresponds to one of the two possible layouts following\n        the swap.\n\n        \"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        cr = ClassicalRegister(2)\n        circuit = QuantumCircuit(qr, cr)\n\n        circuit.cx(qr[0], qr[2])\n        circuit.barrier(qr[0], qr[2])\n\n        dag_circuit = circuit_to_dag(circuit)\n\n        coupling_map = CouplingMap([[0, 1], [1, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(dag_circuit)\n\n        mapped_barrier_qargs = [set(op.qargs) for op in mapped_dag.named_nodes(\"barrier\")][0]\n\n        self.assertIn(mapped_barrier_qargs, [{qr[0], qr[1]}, {qr[1], qr[2]}])\n\n    def test_lookahead_swap_higher_depth_width_is_better(self):\n        \"\"\"Test that lookahead swap finds better circuit with increasing search space.\n\n        Increasing the tree width and depth is expected to yield a better (or same) quality\n        circuit, in the form of fewer SWAPs.\n        \"\"\"\n        # q_0: ──■───────────────────■───────────────────────────────────────────────»\n        #      ┌─┴─┐                 │                 ┌───┐                         »\n        # q_1: ┤ X ├──■──────────────┼─────────────────┤ X ├─────────────────────────»\n        #      └───┘┌─┴─┐            │                 └─┬─┘┌───┐          ┌───┐     »\n        # q_2: ─────┤ X ├──■─────────┼───────────────────┼──┤ X ├──────────┤ X ├──■──»\n        #           └───┘┌─┴─┐     ┌─┴─┐                 │  └─┬─┘     ┌───┐└─┬─┘  │  »\n        # q_3: ──────────┤ X ├──■──┤ X ├─────────────────┼────┼────■──┤ X ├──┼────┼──»\n        #                └───┘┌─┴─┐└───┘          ┌───┐  │    │    │  └─┬─┘  │    │  »\n        # q_4: ───────────────┤ X ├──■────────────┤ X ├──┼────■────┼────┼────┼────┼──»\n        #                     └───┘┌─┴─┐          └─┬─┘  │         │    │    │    │  »\n        # q_5: ────────────────────┤ X ├──■─────────┼────┼─────────┼────■────┼────┼──»\n        #                          └───┘┌─┴─┐       │    │         │         │    │  »\n        # q_6: ─────────────────────────┤ X ├──■────■────┼─────────┼─────────■────┼──»\n        #                               └───┘┌─┴─┐       │       ┌─┴─┐          ┌─┴─┐»\n        # q_7: ──────────────────────────────┤ X ├───────■───────┤ X ├──────────┤ X ├»\n        #                                    └───┘               └───┘          └───┘»\n        # «q_0: ──■───────\n        # «       │\n        # «q_1: ──┼───────\n        # «       │\n        # «q_2: ──┼───────\n        # «       │\n        # «q_3: ──┼───────\n        # «       │\n        # «q_4: ──┼───────\n        # «       │\n        # «q_5: ──┼────■──\n        # «     ┌─┴─┐  │\n        # «q_6: ┤ X ├──┼──\n        # «     └───┘┌─┴─┐\n        # «q_7: ─────┤ X ├\n        # «          └───┘\n        qr = QuantumRegister(8, name=\"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[1], qr[2])\n        circuit.cx(qr[2], qr[3])\n        circuit.cx(qr[3], qr[4])\n        circuit.cx(qr[4], qr[5])\n        circuit.cx(qr[5], qr[6])\n        circuit.cx(qr[6], qr[7])\n        circuit.cx(qr[0], qr[3])\n        circuit.cx(qr[6], qr[4])\n        circuit.cx(qr[7], qr[1])\n        circuit.cx(qr[4], qr[2])\n        circuit.cx(qr[3], qr[7])\n        circuit.cx(qr[5], qr[3])\n        circuit.cx(qr[6], qr[2])\n        circuit.cx(qr[2], qr[7])\n        circuit.cx(qr[0], qr[6])\n        circuit.cx(qr[5], qr[7])\n        original_dag = circuit_to_dag(circuit)\n\n        # Create a ring of 8 connected qubits\n        coupling_map = CouplingMap.from_grid(num_rows=2, num_columns=4)\n\n        mapped_dag_1 = LookaheadSwap(coupling_map, search_depth=3, search_width=3).run(original_dag)\n        mapped_dag_2 = LookaheadSwap(coupling_map, search_depth=5, search_width=5).run(original_dag)\n\n        num_swaps_1 = mapped_dag_1.count_ops().get(\"swap\", 0)\n        num_swaps_2 = mapped_dag_2.count_ops().get(\"swap\", 0)\n\n        self.assertLessEqual(num_swaps_2, num_swaps_1)\n\n    def test_lookahead_swap_hang_in_min_case(self):\n        \"\"\"Verify LookaheadSwap does not stall in minimal case.\"\"\"\n        # ref: https://github.com/Qiskit/qiskit-terra/issues/2171\n\n        qr = QuantumRegister(14, \"q\")\n        qc = QuantumCircuit(qr)\n        qc.cx(qr[0], qr[13])\n        qc.cx(qr[1], qr[13])\n        qc.cx(qr[1], qr[0])\n        qc.cx(qr[13], qr[1])\n        dag = circuit_to_dag(qc)\n\n        cmap = CouplingMap(FakeMelbourne().configuration().coupling_map)\n\n        out = LookaheadSwap(cmap, search_depth=4, search_width=4).run(dag)\n\n        self.assertIsInstance(out, DAGCircuit)\n\n    def test_lookahead_swap_hang_full_case(self):\n        \"\"\"Verify LookaheadSwap does not stall in reported case.\"\"\"\n        # ref: https://github.com/Qiskit/qiskit-terra/issues/2171\n\n        qr = QuantumRegister(14, \"q\")\n        qc = QuantumCircuit(qr)\n        qc.cx(qr[0], qr[13])\n        qc.cx(qr[1], qr[13])\n        qc.cx(qr[1], qr[0])\n        qc.cx(qr[13], qr[1])\n        qc.cx(qr[6], qr[7])\n        qc.cx(qr[8], qr[7])\n        qc.cx(qr[8], qr[6])\n        qc.cx(qr[7], qr[8])\n        qc.cx(qr[0], qr[13])\n        qc.cx(qr[1], qr[0])\n        qc.cx(qr[13], qr[1])\n        qc.cx(qr[0], qr[1])\n        dag = circuit_to_dag(qc)\n\n        cmap = CouplingMap(FakeMelbourne().configuration().coupling_map)\n\n        out = LookaheadSwap(cmap, search_depth=4, search_width=4).run(dag)\n\n        self.assertIsInstance(out, DAGCircuit)\n\n    def test_global_phase_preservation(self):\n        \"\"\"Test that LookaheadSwap preserves global phase\"\"\"\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.global_phase = pi / 3\n        circuit.cx(qr[0], qr[2])\n        dag_circuit = circuit_to_dag(circuit)\n\n        coupling_map = CouplingMap([[0, 1], [1, 2]])\n\n        mapped_dag = LookaheadSwap(coupling_map).run(dag_circuit)\n\n        self.assertEqual(mapped_dag.global_phase, circuit.global_phase)\n        self.assertEqual(\n            mapped_dag.count_ops().get(\"swap\", 0), dag_circuit.count_ops().get(\"swap\", 0) + 1\n        )\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[{\"CONTROL\": 2}], [], [\"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 720,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [], [\"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:03.508+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170d9"
  },
  "id": "54a1d4cb-99a4-4b36-9513-d64b14b80eb9",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_dag_fixed_point_pass.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"DAGFixedPoint pass testing\"\"\"\n\nimport unittest\nfrom qiskit.transpiler.passes import DAGFixedPoint\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestFixedPointPass(QiskitTestCase):\n    \"\"\"Tests for PropertySet methods.\"\"\"\n\n    def test_empty_dag_true(self):\n        \"\"\"Test the dag fixed point of an empty dag.\"\"\"\n        circuit = QuantumCircuit()\n        dag = circuit_to_dag(circuit)\n\n        pass_ = DAGFixedPoint()\n        pass_.run(dag)\n        self.assertFalse(pass_.property_set[\"dag_fixed_point\"])\n        pass_.run(dag)\n        self.assertTrue(pass_.property_set[\"dag_fixed_point\"])\n\n    def test_nonempty_dag_false(self):\n        \"\"\"Test the dag false fixed point of a non-empty dag.\"\"\"\n        qr = QuantumRegister(2)\n        circuit = QuantumCircuit(qr)\n        circuit.h(qr[0])\n        circuit.cx(qr[0], qr[1])\n        dag = circuit_to_dag(circuit)\n\n        pass_ = DAGFixedPoint()\n        pass_.run(dag)\n        self.assertFalse(pass_.property_set[\"dag_fixed_point\"])\n        dag.remove_all_ops_named(\"h\")\n        pass_.run(dag)\n        self.assertFalse(pass_.property_set[\"dag_fixed_point\"])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 721,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:51:38.672+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170de"
  },
  "id": "83e04c85-0e7d-4273-80d1-26086885d8fa",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_layout_transformation.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the LayoutTransformation pass\"\"\"\n\nimport unittest\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.transpiler import CouplingMap, Layout, Target\nfrom qiskit.circuit.library import CXGate\nfrom qiskit.transpiler.passes import LayoutTransformation\n\n\nclass TestLayoutTransformation(QiskitTestCase):\n    \"\"\"\n    Tests the LayoutTransformation pass.\n    \"\"\"\n\n    def test_three_qubit(self):\n        \"\"\"Test if the permutation {0->2,1->0,2->1} is implemented correctly.\"\"\"\n        v = QuantumRegister(3, \"v\")  # virtual qubits\n        coupling = CouplingMap([[0, 1], [1, 2]])\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2})\n        to_layout = Layout({v[0]: 2, v[1]: 0, v[2]: 1})\n        ltpass = LayoutTransformation(\n            coupling_map=coupling, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(3)\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(3)\n        expected.swap(1, 0)\n        expected.swap(1, 2)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n    def test_four_qubit(self):\n        \"\"\"Test if the permutation {0->3,1->0,2->1,3->2} is implemented correctly.\"\"\"\n        v = QuantumRegister(4, \"v\")  # virtual qubits\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2, v[3]: 3})\n        to_layout = Layout({v[0]: 3, v[1]: 0, v[2]: 1, v[3]: 2})\n        ltpass = LayoutTransformation(\n            coupling_map=coupling, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(4)  # input (empty) physical circuit\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(4)\n        expected.swap(1, 0)\n        expected.swap(1, 2)\n        expected.swap(2, 3)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n    def test_four_qubit_with_target(self):\n        \"\"\"Test if the permutation {0->3,1->0,2->1,3->2} is implemented correctly.\"\"\"\n        v = QuantumRegister(4, \"v\")  # virtual qubits\n        target = Target()\n        target.add_instruction(CXGate(), {(0, 1): None, (1, 2): None, (2, 3): None})\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2, v[3]: 3})\n        to_layout = Layout({v[0]: 3, v[1]: 0, v[2]: 1, v[3]: 2})\n        ltpass = LayoutTransformation(target, from_layout=from_layout, to_layout=to_layout, seed=42)\n        qc = QuantumCircuit(4)  # input (empty) physical circuit\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(4)\n        expected.swap(1, 0)\n        expected.swap(1, 2)\n        expected.swap(2, 3)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n    @unittest.skip(\"rustworkx token_swapper produces correct, but sometimes random output\")\n    def test_full_connected_coupling_map(self):\n        \"\"\"Test if the permutation {0->3,1->0,2->1,3->2} in a fully connected map.\"\"\"\n\n        # TODO: Remove skip when https://github.com/Qiskit/rustworkx/pull/897 is\n        # merged and released. Should be rustworkx 0.13.1.\n\n        v = QuantumRegister(4, \"v\")  # virtual qubits\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2, v[3]: 3})\n        to_layout = Layout({v[0]: 3, v[1]: 0, v[2]: 1, v[3]: 2})\n        ltpass = LayoutTransformation(\n            coupling_map=None, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(4)  # input (empty) physical circuit\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(4)\n        expected.swap(1, 0)\n        expected.swap(2, 1)\n        expected.swap(3, 2)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[], [], [], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], [], [], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170e0"
  },
  "id": "e451c67b-f9d4-4c04-9c91-8a8fe18045f5",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_noise_adaptive_layout.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the NoiseAdaptiveLayout pass\"\"\"\n\nfrom datetime import datetime\nimport unittest\nfrom qiskit.transpiler.passes import NoiseAdaptiveLayout\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.providers.models import BackendProperties\nfrom qiskit.providers.models.backendproperties import Nduv, Gate\n\n\ndef make_qubit_with_error(readout_error):\n    \"\"\"Create a qubit for BackendProperties\"\"\"\n    calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n    return [\n        Nduv(name=\"T1\", date=calib_time, unit=\"µs\", value=100.0),\n        Nduv(name=\"T2\", date=calib_time, unit=\"µs\", value=100.0),\n        Nduv(name=\"frequency\", date=calib_time, unit=\"GHz\", value=5.0),\n        Nduv(name=\"readout_error\", date=calib_time, unit=\"\", value=readout_error),\n    ]\n\n\nclass TestNoiseAdaptiveLayout(QiskitTestCase):\n    \"\"\"Tests the NoiseAdaptiveLayout pass.\"\"\"\n\n    def test_on_linear_topology(self):\n        \"\"\"\n        Test that the mapper identifies the correct gate in a linear topology\n        \"\"\"\n        calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n        qr = QuantumRegister(2, name=\"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        dag = circuit_to_dag(circuit)\n        qubit_list = []\n        ro_errors = [0.01, 0.01, 0.01]\n        for ro_error in ro_errors:\n            qubit_list.append(make_qubit_with_error(ro_error))\n        p01 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.9)]\n        g01 = Gate(name=\"CX0_1\", gate=\"cx\", parameters=p01, qubits=[0, 1])\n        p12 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        g12 = Gate(name=\"CX1_2\", gate=\"cx\", parameters=p12, qubits=[1, 2])\n        gate_list = [g01, g12]\n        bprop = BackendProperties(\n            last_update_date=calib_time,\n            backend_name=\"test_backend\",\n            qubits=qubit_list,\n            backend_version=\"1.0.0\",\n            gates=gate_list,\n            general=[],\n        )\n        nalayout = NoiseAdaptiveLayout(bprop)\n        nalayout.run(dag)\n        initial_layout = nalayout.property_set[\"layout\"]\n        self.assertNotEqual(initial_layout[qr[0]], 0)\n        self.assertNotEqual(initial_layout[qr[1]], 0)\n\n    def test_bad_readout(self):\n        \"\"\"Test that the mapper avoids bad readout unit\"\"\"\n        calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n        qr = QuantumRegister(2, name=\"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        dag = circuit_to_dag(circuit)\n        qubit_list = []\n        ro_errors = [0.01, 0.01, 0.8]\n        for ro_error in ro_errors:\n            qubit_list.append(make_qubit_with_error(ro_error))\n        p01 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        g01 = Gate(name=\"CX0_1\", gate=\"cx\", parameters=p01, qubits=[0, 1])\n        p12 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        g12 = Gate(name=\"CX1_2\", gate=\"cx\", parameters=p12, qubits=[1, 2])\n        gate_list = [g01, g12]\n        bprop = BackendProperties(\n            last_update_date=calib_time,\n            backend_name=\"test_backend\",\n            qubits=qubit_list,\n            backend_version=\"1.0.0\",\n            gates=gate_list,\n            general=[],\n        )\n        nalayout = NoiseAdaptiveLayout(bprop)\n        nalayout.run(dag)\n        initial_layout = nalayout.property_set[\"layout\"]\n        self.assertNotEqual(initial_layout[qr[0]], 2)\n        self.assertNotEqual(initial_layout[qr[1]], 2)\n\n    def test_grid_layout(self):\n        \"\"\"\n        Test that the mapper identifies best location for a star-like program graph\n        Machine row1: (0, 1, 2)\n        Machine row2: (3, 4, 5)\n        \"\"\"\n        calib_time = datetime(year=2019, month=2, day=1, hour=0, minute=0, second=0)\n        qr = QuantumRegister(4, name=\"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[3])\n        circuit.cx(qr[1], qr[3])\n        circuit.cx(qr[2], qr[3])\n        dag = circuit_to_dag(circuit)\n        qubit_list = []\n        ro_errors = [0.01] * 6\n        for ro_error in ro_errors:\n            qubit_list.append(make_qubit_with_error(ro_error))\n        p01 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.3)]\n        p03 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.3)]\n        p12 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.3)]\n        p14 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        p34 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        p45 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.1)]\n        p25 = [Nduv(date=calib_time, name=\"gate_error\", unit=\"\", value=0.3)]\n        g01 = Gate(name=\"CX0_1\", gate=\"cx\", parameters=p01, qubits=[0, 1])\n        g03 = Gate(name=\"CX0_3\", gate=\"cx\", parameters=p03, qubits=[0, 3])\n        g12 = Gate(name=\"CX1_2\", gate=\"cx\", parameters=p12, qubits=[1, 2])\n        g14 = Gate(name=\"CX1_4\", gate=\"cx\", parameters=p14, qubits=[1, 4])\n        g34 = Gate(name=\"CX3_4\", gate=\"cx\", parameters=p34, qubits=[3, 4])\n        g45 = Gate(name=\"CX4_5\", gate=\"cx\", parameters=p45, qubits=[4, 5])\n        g25 = Gate(name=\"CX2_5\", gate=\"cx\", parameters=p25, qubits=[2, 5])\n        gate_list = [g01, g03, g12, g14, g34, g45, g25]\n        bprop = BackendProperties(\n            last_update_date=calib_time,\n            backend_name=\"test_backend\",\n            qubits=qubit_list,\n            backend_version=\"1.0.0\",\n            gates=gate_list,\n            general=[],\n        )\n        nalayout = NoiseAdaptiveLayout(bprop)\n        nalayout.run(dag)\n        initial_layout = nalayout.property_set[\"layout\"]\n        for qid in range(4):\n            for qloc in [0, 2]:\n                self.assertNotEqual(initial_layout[qr[qid]], qloc)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0.75
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 723,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 3}], [\"_\", {\"CONTROL\": 3}], [\"_\", \"_\", {\"CONTROL\": 3}], [\"X\", \"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T21:52:36.348+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170e3"
  },
  "id": "75a0e55f-a1c9-42ae-84f8-f365fa12ad91",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_resource_estimation_pass.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"ResourceEstimation pass testing\"\"\"\n\nimport unittest\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.transpiler import PassManager\nfrom qiskit.transpiler.passes import ResourceEstimation\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestResourceEstimationPass(QiskitTestCase):\n    \"\"\"Tests for PropertySet methods.\"\"\"\n\n    def test_empty_dag(self):\n        \"\"\"Empty DAG.\"\"\"\n        circuit = QuantumCircuit()\n        passmanager = PassManager()\n        passmanager.append(ResourceEstimation())\n        passmanager.run(circuit)\n\n        self.assertEqual(passmanager.property_set[\"size\"], 0)\n        self.assertEqual(passmanager.property_set[\"depth\"], 0)\n        self.assertEqual(passmanager.property_set[\"width\"], 0)\n        self.assertDictEqual(passmanager.property_set[\"count_ops\"], {})\n\n    def test_just_qubits(self):\n        \"\"\"A dag with 8 operations and no classic bits\"\"\"\n        qr = QuantumRegister(2)\n        circuit = QuantumCircuit(qr)\n        circuit.h(qr[0])\n        circuit.h(qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[0], qr[1])\n        circuit.cx(qr[1], qr[0])\n        circuit.cx(qr[1], qr[0])\n\n        passmanager = PassManager()\n        passmanager.append(ResourceEstimation())\n        passmanager.run(circuit)\n\n        self.assertEqual(passmanager.property_set[\"size\"], 8)\n        self.assertEqual(passmanager.property_set[\"depth\"], 7)\n        self.assertEqual(passmanager.property_set[\"width\"], 2)\n        self.assertDictEqual(passmanager.property_set[\"count_ops\"], {\"cx\": 6, \"h\": 2})\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 7
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 1.1428571428571428
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0.25
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 724,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, {\"CONTROL\": 1}, \"X\", \"X\"], [\"H\", \"X\", \"X\", \"X\", \"X\", {\"CONTROL\": 0}, {\"CONTROL\": 0}]]"
        },
        "timestamp": "2023-11-26T21:53:19.722+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 0,
          "fragment": "[[\"H\"], [\"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e170e5"
  },
  "id": "e6f33d85-ef35-4af8-8c18-b1b447f4aacf",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_test.python.transpiler.test_pass_call.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test calling passes (passmanager-less)\"\"\"\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.circuit.library import ZGate\nfrom qiskit.transpiler.passes import Unroller\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.transpiler import PropertySet\nfrom ._dummy_passes import PassD_TP_NR_NP, PassE_AP_NR_NP, PassN_AP_NR_NP\n\n\nclass TestPassCall(QiskitTestCase):\n    \"\"\"Test calling passes (passmanager-less).\"\"\"\n\n    def assertMessageLog(self, context, messages):\n        \"\"\"Checks the log messages\"\"\"\n        self.assertEqual([record.message for record in context.records], messages)\n\n    def test_transformation_pass(self):\n        \"\"\"Call a transformation pass without a scheduler\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n\n        pass_d = PassD_TP_NR_NP(argument1=[1, 2])\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_d(circuit)\n\n        self.assertMessageLog(cm, [\"run transformation pass PassD_TP_NR_NP\", \"argument [1, 2]\"])\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_dict(self):\n        \"\"\"Call an analysis pass without a scheduler (property_set dict)\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = {\"another_property\": \"another_value\"}\n\n        pass_e = PassE_AP_NR_NP(\"value\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(cm, [\"run analysis pass PassE_AP_NR_NP\", \"set property as value\"])\n        self.assertEqual(property_set, {\"another_property\": \"another_value\", \"property\": \"value\"})\n        self.assertIsInstance(property_set, dict)\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_property_set(self):\n        \"\"\"Call an analysis pass without a scheduler (PropertySet dict)\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = PropertySet({\"another_property\": \"another_value\"})\n\n        pass_e = PassE_AP_NR_NP(\"value\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(cm, [\"run analysis pass PassE_AP_NR_NP\", \"set property as value\"])\n        self.assertEqual(\n            property_set, PropertySet({\"another_property\": \"another_value\", \"property\": \"value\"})\n        )\n        self.assertIsInstance(property_set, PropertySet)\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_remove_property(self):\n        \"\"\"Call an analysis pass that removes a property without a scheduler\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = {\"to remove\": \"value to remove\", \"to none\": \"value to none\"}\n\n        pass_e = PassN_AP_NR_NP(\"to remove\", \"to none\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(\n            cm,\n            [\n                \"run analysis pass PassN_AP_NR_NP\",\n                \"property to remove deleted\",\n                \"property to none noned\",\n            ],\n        )\n        self.assertEqual(property_set, PropertySet({\"to none\": None}))\n        self.assertIsInstance(property_set, dict)\n        self.assertEqual(circuit, result)\n\n    def test_error_unknown_defn_unroller_pass(self):\n        \"\"\"Check for proper error message when unroller cannot find the definition\n        of a gate.\"\"\"\n        circuit = ZGate().control(2).definition\n        basis = [\"u1\", \"u2\", \"u3\", \"cx\"]\n        with self.assertWarns(DeprecationWarning):\n            unroller = Unroller(basis)\n        with self.assertRaises(QiskitError) as cm:\n            unroller(circuit)\n        exp_msg = (\n            \"Error decomposing node of instruction 'u': \"\n            \"'NoneType' object has no attribute 'global_phase'. \"\n            \"Unable to define instruction 'u' in the given basis.\"\n        )\n        self.assertEqual(exp_msg, cm.exception.message)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e1710a"
  },
  "id": "01c40626-7889-4d2c-98d8-ef9a59554c94",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.x.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"X, CX, CCX and multi-controlled X gates.\"\"\"\nfrom __future__ import annotations\nfrom typing import Optional, Union, Type\nfrom math import ceil, pi\nimport numpy\nfrom qiskit.utils.deprecation import deprecate_func\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.singleton import SingletonGate, SingletonControlledGate, stdlib_singleton_key\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import _ctrl_state_to_int, with_gate_array, with_controlled_gate_array\n\n_X_ARRAY = [[0, 1], [1, 0]]\n\n\n@with_gate_array(_X_ARRAY)\nclass XGate(SingletonGate):\n    r\"\"\"The single-qubit Pauli-X gate (:math:`\\sigma_x`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.x` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        X = \\begin{pmatrix}\n                0 & 1 \\\\\n                1 & 0\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ X ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the X axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RX(\\pi)` and :math:`X`.\n\n        .. math::\n\n            RX(\\pi) = \\begin{pmatrix}\n                        0 & -i \\\\\n                        -i & 0\n                      \\end{pmatrix}\n                    = -i X\n\n    The gate is equivalent to a classical bit flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow |1\\rangle \\\\\n        |1\\rangle \\rightarrow |0\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create new X gate.\"\"\"\n        super().__init__(\"x\", 1, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        \"\"\"\n        gate x a { u3(pi,0,pi) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, 0, pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-X gate.\n\n        One control returns a CX gate. Two controls returns a CCX gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        gate = MCXGate(\n            num_ctrl_qubits=num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            _base_label=self.label,\n        )\n        return gate\n\n    def inverse(self):\n        r\"\"\"Return inverted X gate (itself).\"\"\"\n        return XGate()  # self-inverse\n\n\n@with_controlled_gate_array(_X_ARRAY, num_ctrl_qubits=1)\nclass CXGate(SingletonControlledGate):\n    r\"\"\"Controlled-X gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cx` and\n    :meth:`~qiskit.circuit.QuantumCircuit.cnot` methods.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ X ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CX\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle0| + X \\otimes |1\\rangle\\langle1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 1 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 1 & 0 & 0\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───┐\n            q_0: ┤ X ├\n                 └─┬─┘\n            q_1: ──■──\n\n        .. math::\n\n            CX\\ q_1, q_0 =\n                |0 \\rangle\\langle 0| \\otimes I + |1 \\rangle\\langle 1| \\otimes X =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & 0 & 1 \\\\\n                    0 & 0 & 1 & 0\n                \\end{pmatrix}\n\n\n    In the computational basis, this gate flips the target qubit\n    if the control qubit is in the :math:`|1\\rangle` state.\n    In this sense it is similar to a classical XOR gate.\n\n    .. math::\n        `|a, b\\rangle \\rightarrow |a, a \\oplus b\\rangle`\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CX gate.\"\"\"\n        super().__init__(\n            \"cx\",\n            2,\n            [],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=XGate(label=_base_label),\n            _base_label=_base_label,\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=1)\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a controlled-X gate with more control lines.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n        new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n        gate = MCXGate(\n            num_ctrl_qubits=num_ctrl_qubits + 1,\n            label=label,\n            ctrl_state=new_ctrl_state,\n            _base_label=self.label,\n        )\n        return gate\n\n    def inverse(self):\n        \"\"\"Return inverted CX gate (itself).\"\"\"\n        return CXGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n\n@with_controlled_gate_array(_X_ARRAY, num_ctrl_qubits=2, cached_states=(3,))\nclass CCXGate(SingletonControlledGate):\n    r\"\"\"CCX gate, also known as Toffoli gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ccx` and\n    :meth:`~qiskit.circuit.QuantumCircuit.toffoli` methods.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n               │\n        q_1: ──■──\n             ┌─┴─┐\n        q_2: ┤ X ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CCX q_0, q_1, q_2 =\n            I \\otimes I \\otimes |0 \\rangle \\langle 0| + CX \\otimes |1 \\rangle \\langle 1| =\n           \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n                0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n                0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n                0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n                0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\\\\n                0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_2 and q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───┐\n            q_0: ┤ X ├\n                 └─┬─┘\n            q_1: ──■──\n                   │\n            q_2: ──■──\n\n        .. math::\n\n            CCX\\ q_2, q_1, q_0 =\n                |0 \\rangle \\langle 0| \\otimes I \\otimes I + |1 \\rangle \\langle 1| \\otimes CX =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n                    0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\\\\n                    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n                    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n                    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\\\\n                    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\\\\n                    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n                    0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\n                \\end{pmatrix}\n\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CCX gate.\"\"\"\n        super().__init__(\n            \"ccx\",\n            3,\n            [],\n            num_ctrl_qubits=2,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=XGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=2)\n\n    def _define(self):\n        \"\"\"\n        gate ccx a,b,c\n        {\n        h c; cx b,c; tdg c; cx a,c;\n        t c; cx b,c; tdg c; cx a,c;\n        t b; t c; h c; cx a,b;\n        t a; tdg b; cx a,b;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .h import HGate\n        from .t import TGate, TdgGate\n\n        #                                                        ┌───┐\n        # q_0: ───────────────────■─────────────────────■────■───┤ T ├───■──\n        #                         │             ┌───┐   │  ┌─┴─┐┌┴───┴┐┌─┴─┐\n        # q_1: ───────■───────────┼─────────■───┤ T ├───┼──┤ X ├┤ Tdg ├┤ X ├\n        #      ┌───┐┌─┴─┐┌─────┐┌─┴─┐┌───┐┌─┴─┐┌┴───┴┐┌─┴─┐├───┤└┬───┬┘└───┘\n        # q_2: ┤ H ├┤ X ├┤ Tdg ├┤ X ├┤ T ├┤ X ├┤ Tdg ├┤ X ├┤ T ├─┤ H ├──────\n        #      └───┘└───┘└─────┘└───┘└───┘└───┘└─────┘└───┘└───┘ └───┘\n        q = QuantumRegister(3, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (HGate(), [q[2]], []),\n            (CXGate(), [q[1], q[2]], []),\n            (TdgGate(), [q[2]], []),\n            (CXGate(), [q[0], q[2]], []),\n            (TGate(), [q[2]], []),\n            (CXGate(), [q[1], q[2]], []),\n            (TdgGate(), [q[2]], []),\n            (CXGate(), [q[0], q[2]], []),\n            (TGate(), [q[1]], []),\n            (TGate(), [q[2]], []),\n            (HGate(), [q[2]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (TGate(), [q[0]], []),\n            (TdgGate(), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Controlled version of this gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n        new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n        gate = MCXGate(\n            num_ctrl_qubits=num_ctrl_qubits + 2,\n            label=label,\n            ctrl_state=new_ctrl_state,\n            _base_label=self.label,\n        )\n        return gate\n\n    def inverse(self):\n        \"\"\"Return an inverted CCX gate (also a CCX).\"\"\"\n        return CCXGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n\n@with_gate_array(\n    [\n        [1, 0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, -1j],\n        [0, 0, 0, 0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0, -1, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 1j, 0, 0, 0, 0],\n    ]\n)\nclass RCCXGate(SingletonGate):\n    \"\"\"The simplified Toffoli gate, also referred to as Margolus gate.\n\n    The simplified Toffoli gate implements the Toffoli gate up to relative phases.\n    This implementation requires three CX gates which is the minimal amount possible,\n    as shown in https://arxiv.org/abs/quant-ph/0312225.\n    Note, that the simplified Toffoli is not equivalent to the Toffoli. But can be used in places\n    where the Toffoli gate is uncomputed again.\n\n    This concrete implementation is from https://arxiv.org/abs/1508.03273, the dashed box\n    of Fig. 3.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rccx` method.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create a new simplified CCX gate.\"\"\"\n        super().__init__(\"rccx\", 3, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        \"\"\"\n        gate rccx a,b,c\n        { u2(0,pi) c;\n          u1(pi/4) c;\n          cx b, c;\n          u1(-pi/4) c;\n          cx a, c;\n          u1(pi/4) c;\n          cx b, c;\n          u1(-pi/4) c;\n          u2(0,pi) c;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n        from .u2 import U2Gate\n\n        q = QuantumRegister(3, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (U2Gate(0, pi), [q[2]], []),  # H gate\n            (U1Gate(pi / 4), [q[2]], []),  # T gate\n            (CXGate(), [q[1], q[2]], []),\n            (U1Gate(-pi / 4), [q[2]], []),  # inverse T gate\n            (CXGate(), [q[0], q[2]], []),\n            (U1Gate(pi / 4), [q[2]], []),\n            (CXGate(), [q[1], q[2]], []),\n            (U1Gate(-pi / 4), [q[2]], []),  # inverse T gate\n            (U2Gate(0, pi), [q[2]], []),  # H gate\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n\nclass C3SXGate(SingletonControlledGate):\n    \"\"\"The 3-qubit controlled sqrt-X gate.\n\n    This implementation is based on Page 17 of [1].\n\n    References:\n        [1] Barenco et al., 1995. https://arxiv.org/pdf/quant-ph/9503016.pdf\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create a new 3-qubit controlled sqrt-X gate.\n\n        Args:\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n        \"\"\"\n        from .sx import SXGate\n\n        super().__init__(\n            \"c3sx\",\n            4,\n            [],\n            num_ctrl_qubits=3,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=SXGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=3)\n\n    def _define(self):\n        \"\"\"\n        gate c3sqrtx a,b,c,d\n        {\n            h d; cu1(pi/8) a,d; h d;\n            cx a,b;\n            h d; cu1(-pi/8) b,d; h d;\n            cx a,b;\n            h d; cu1(pi/8) b,d; h d;\n            cx b,c;\n            h d; cu1(-pi/8) c,d; h d;\n            cx a,c;\n            h d; cu1(pi/8) c,d; h d;\n            cx b,c;\n            h d; cu1(-pi/8) c,d; h d;\n            cx a,c;\n            h d; cu1(pi/8) c,d; h d;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import CU1Gate\n        from .h import HGate\n\n        angle = numpy.pi / 8\n        q = QuantumRegister(4, name=\"q\")\n        rules = [\n            (HGate(), [q[3]], []),\n            (CU1Gate(angle), [q[0], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(-angle), [q[1], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(angle), [q[1], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[1], q[2]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(-angle), [q[2], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[0], q[2]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(angle), [q[2], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[1], q[2]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(-angle), [q[2], q[3]], []),\n            (HGate(), [q[3]], []),\n            (CXGate(), [q[0], q[2]], []),\n            (HGate(), [q[3]], []),\n            (CU1Gate(angle), [q[2], q[3]], []),\n            (HGate(), [q[3]], []),\n        ]\n        qc = QuantumCircuit(q)\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    @deprecate_func(since=\"0.25.0\")\n    def qasm(self):\n        # Gross hack to override the Qiskit name with the name this gate has in Terra's version of\n        # 'qelib1.inc'.  In general, the larger exporter mechanism should know about this to do the\n        # mapping itself, but right now that's not possible without a complete rewrite of the OQ2\n        # exporter code (low priority), or we would need to modify 'qelib1.inc' which would be\n        # needlessly disruptive this late in OQ2's lifecycle.  The current OQ2 exporter _always_\n        # outputs the `include 'qelib1.inc' line.  ---Jake, 2022-11-21.\n        old_name = self.name\n        if not self.mutable:\n            copy_self = self.to_mutable()\n            copy_self.name = \"c3sqrtx\"\n            return copy_self.qasm()\n        try:\n            return super().qasm()\n        finally:\n            self.name = old_name\n\n\n@with_controlled_gate_array(_X_ARRAY, num_ctrl_qubits=3, cached_states=(7,))\nclass C3XGate(SingletonControlledGate):\n    r\"\"\"The X gate controlled on 3 qubits.\n\n    This implementation uses :math:`\\sqrt{T}` and 14 CNOT gates.\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        _base_label=None,\n        duration=None,\n        unit=\"dt\",\n    ):\n        \"\"\"Create a new 3-qubit controlled X gate.\"\"\"\n        super().__init__(\n            \"mcx\",\n            4,\n            [],\n            num_ctrl_qubits=3,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=XGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=3)\n\n    # seems like open controls not hapening?\n    def _define(self):\n        \"\"\"\n        gate c3x a,b,c,d\n        {\n            h d;\n            p(pi/8) a;\n            p(pi/8) b;\n            p(pi/8) c;\n            p(pi/8) d;\n            cx a, b;\n            p(-pi/8) b;\n            cx a, b;\n            cx b, c;\n            p(-pi/8) c;\n            cx a, c;\n            p(pi/8) c;\n            cx b, c;\n            p(-pi/8) c;\n            cx a, c;\n            cx c, d;\n            p(-pi/8) d;\n            cx b, d;\n            p(pi/8) d;\n            cx c, d;\n            p(-pi/8) d;\n            cx a, d;\n            p(pi/8) d;\n            cx c, d;\n            p(-pi/8) d;\n            cx b, d;\n            p(pi/8) d;\n            cx c, d;\n            p(-pi/8) d;\n            cx a, d;\n            h d;\n        }\n        \"\"\"\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        q = QuantumRegister(4, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        qc.h(3)\n        qc.p(pi / 8, [0, 1, 2, 3])\n        qc.cx(0, 1)\n        qc.p(-pi / 8, 1)\n        qc.cx(0, 1)\n        qc.cx(1, 2)\n        qc.p(-pi / 8, 2)\n        qc.cx(0, 2)\n        qc.p(pi / 8, 2)\n        qc.cx(1, 2)\n        qc.p(-pi / 8, 2)\n        qc.cx(0, 2)\n        qc.cx(2, 3)\n        qc.p(-pi / 8, 3)\n        qc.cx(1, 3)\n        qc.p(pi / 8, 3)\n        qc.cx(2, 3)\n        qc.p(-pi / 8, 3)\n        qc.cx(0, 3)\n        qc.p(pi / 8, 3)\n        qc.cx(2, 3)\n        qc.p(-pi / 8, 3)\n        qc.cx(1, 3)\n        qc.p(pi / 8, 3)\n        qc.cx(2, 3)\n        qc.p(-pi / 8, 3)\n        qc.cx(0, 3)\n        qc.h(3)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Controlled version of this gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n        new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n        return MCXGate(\n            num_ctrl_qubits=num_ctrl_qubits + 3,\n            label=label,\n            ctrl_state=new_ctrl_state,\n            _base_label=self.label,\n        )\n\n    def inverse(self):\n        \"\"\"Invert this gate. The C4X is its own inverse.\"\"\"\n        return C3XGate(ctrl_state=self.ctrl_state)\n\n\n@with_gate_array(\n    [\n        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 1j, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1j, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0],\n    ]\n)\nclass RC3XGate(SingletonGate):\n    \"\"\"The simplified 3-controlled Toffoli gate.\n\n    The simplified Toffoli gate implements the Toffoli gate up to relative phases.\n    Note, that the simplified Toffoli is not equivalent to the Toffoli. But can be used in places\n    where the Toffoli gate is uncomputed again.\n\n    This concrete implementation is from https://arxiv.org/abs/1508.03273, the complete circuit\n    of Fig. 4.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rcccx` method.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, *, duration=None, unit=\"dt\"):\n        \"\"\"Create a new RC3X gate.\"\"\"\n        super().__init__(\"rcccx\", 4, [], label=label, duration=duration, unit=unit)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def _define(self):\n        \"\"\"\n        gate rc3x a,b,c,d\n        { u2(0,pi) d;\n          u1(pi/4) d;\n          cx c,d;\n          u1(-pi/4) d;\n          u2(0,pi) d;\n          cx a,d;\n          u1(pi/4) d;\n          cx b,d;\n          u1(-pi/4) d;\n          cx a,d;\n          u1(pi/4) d;\n          cx b,d;\n          u1(-pi/4) d;\n          u2(0,pi) d;\n          u1(pi/4) d;\n          cx c,d;\n          u1(-pi/4) d;\n          u2(0,pi) d;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n        from .u2 import U2Gate\n\n        q = QuantumRegister(4, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (U2Gate(0, pi), [q[3]], []),  # H gate\n            (U1Gate(pi / 4), [q[3]], []),  # T gate\n            (CXGate(), [q[2], q[3]], []),\n            (U1Gate(-pi / 4), [q[3]], []),  # inverse T gate\n            (U2Gate(0, pi), [q[3]], []),\n            (CXGate(), [q[0], q[3]], []),\n            (U1Gate(pi / 4), [q[3]], []),\n            (CXGate(), [q[1], q[3]], []),\n            (U1Gate(-pi / 4), [q[3]], []),\n            (CXGate(), [q[0], q[3]], []),\n            (U1Gate(pi / 4), [q[3]], []),\n            (CXGate(), [q[1], q[3]], []),\n            (U1Gate(-pi / 4), [q[3]], []),\n            (U2Gate(0, pi), [q[3]], []),\n            (U1Gate(pi / 4), [q[3]], []),\n            (CXGate(), [q[2], q[3]], []),\n            (U1Gate(-pi / 4), [q[3]], []),\n            (U2Gate(0, pi), [q[3]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n\n@with_controlled_gate_array(_X_ARRAY, num_ctrl_qubits=4, cached_states=(15,))\nclass C4XGate(SingletonControlledGate):\n    \"\"\"The 4-qubit controlled X gate.\n\n    This implementation is based on Page 21, Lemma 7.5, of [1], with the use\n    of the relative phase version of c3x, the rc3x [2].\n\n    References:\n        [1] Barenco et al., 1995. https://arxiv.org/pdf/quant-ph/9503016.pdf\n        [2] Maslov, 2015. https://arxiv.org/abs/1508.03273\n    \"\"\"\n\n    def __init__(\n        self,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create a new 4-qubit controlled X gate.\"\"\"\n        if unit is None:\n            unit = \"dt\"\n        super().__init__(\n            \"mcx\",\n            5,\n            [],\n            num_ctrl_qubits=4,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=XGate(label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    _singleton_lookup_key = stdlib_singleton_key(num_ctrl_qubits=4)\n\n    # seems like open controls not hapening?\n    def _define(self):\n        \"\"\"\n        gate c3sqrtx a,b,c,d\n        {\n            h d; cu1(pi/8) a,d; h d;\n            cx a,b;\n            h d; cu1(-pi/8) b,d; h d;\n            cx a,b;\n            h d; cu1(pi/8) b,d; h d;\n            cx b,c;\n            h d; cu1(-pi/8) c,d; h d;\n            cx a,c;\n            h d; cu1(pi/8) c,d; h d;\n            cx b,c;\n            h d; cu1(-pi/8) c,d; h d;\n            cx a,c;\n            h d; cu1(pi/8) c,d; h d;\n        }\n        gate c4x a,b,c,d,e\n        {\n            h e; cu1(pi/2) d,e; h e;\n            rc3x a,b,c,d;\n            h e; cu1(-pi/2) d,e; h e;\n            rc3x a,b,c,d;\n            c3sqrtx a,b,c,e;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import CU1Gate\n        from .h import HGate\n\n        q = QuantumRegister(5, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (HGate(), [q[4]], []),\n            (CU1Gate(numpy.pi / 2), [q[3], q[4]], []),\n            (HGate(), [q[4]], []),\n            (RC3XGate(), [q[0], q[1], q[2], q[3]], []),\n            (HGate(), [q[4]], []),\n            (CU1Gate(-numpy.pi / 2), [q[3], q[4]], []),\n            (HGate(), [q[4]], []),\n            (RC3XGate().inverse(), [q[0], q[1], q[2], q[3]], []),\n            (C3SXGate(), [q[0], q[1], q[2], q[4]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Controlled version of this gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n        new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n        return MCXGate(\n            num_ctrl_qubits=num_ctrl_qubits + 4,\n            label=label,\n            ctrl_state=new_ctrl_state,\n            _base_label=self.label,\n        )\n\n    def inverse(self):\n        \"\"\"Invert this gate. The C4X is its own inverse.\"\"\"\n        return C4XGate(ctrl_state=self.ctrl_state)\n\n\nclass MCXGate(ControlledGate):\n    \"\"\"The general, multi-controlled X gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.mcx` method.\n    \"\"\"\n\n    def __new__(\n        cls,\n        num_ctrl_qubits: Optional[int] = None,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create a new MCX instance.\n\n        Depending on the number of controls and which mode of the MCX, this creates an\n        explicit CX, CCX, C3X or C4X instance or a generic MCX gate.\n        \"\"\"\n        # The CXGate and CCXGate will be implemented for all modes of the MCX, and\n        # the C3XGate and C4XGate will be implemented in the MCXGrayCode class.\n        explicit: dict[int, Type[ControlledGate]] = {1: CXGate, 2: CCXGate}\n        gate_class = explicit.get(num_ctrl_qubits, None)\n        if gate_class is not None:\n            gate = gate_class.__new__(\n                gate_class, label=label, ctrl_state=ctrl_state, _base_label=_base_label\n            )\n            # if __new__ does not return the same type as cls, init is not called\n            gate.__init__(\n                label=label,\n                ctrl_state=ctrl_state,\n                _base_label=_base_label,\n                duration=duration,\n                unit=unit,\n            )\n            return gate\n        return super().__new__(cls)\n\n    def __init__(\n        self,\n        num_ctrl_qubits: int,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _name=\"mcx\",\n        _base_label=None,\n    ):\n        \"\"\"Create new MCX gate.\"\"\"\n        num_ancilla_qubits = self.__class__.get_num_ancilla_qubits(num_ctrl_qubits)\n        super().__init__(\n            _name,\n            num_ctrl_qubits + 1 + num_ancilla_qubits,\n            [],\n            num_ctrl_qubits=num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=XGate(label=_base_label),\n        )\n\n    def inverse(self):\n        \"\"\"Invert this gate. The MCX is its own inverse.\"\"\"\n        return MCXGate(num_ctrl_qubits=self.num_ctrl_qubits, ctrl_state=self.ctrl_state)\n\n    @staticmethod\n    def get_num_ancilla_qubits(num_ctrl_qubits: int, mode: str = \"noancilla\") -> int:\n        \"\"\"Get the number of required ancilla qubits without instantiating the class.\n\n        This staticmethod might be necessary to check the number of ancillas before\n        creating the gate, or to use the number of ancillas in the initialization.\n        \"\"\"\n        if mode == \"noancilla\":\n            return 0\n        if mode in [\"recursion\", \"advanced\"]:\n            return int(num_ctrl_qubits > 4)\n        if mode[:7] == \"v-chain\" or mode[:5] == \"basic\":\n            return max(0, num_ctrl_qubits - 2)\n        raise AttributeError(f\"Unsupported mode ({mode}) specified!\")\n\n    def _define(self):\n        \"\"\"The standard definition used the Gray code implementation.\"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        q = QuantumRegister(self.num_qubits, name=\"q\")\n        qc = QuantumCircuit(q)\n        qc._append(MCXGrayCode(self.num_ctrl_qubits), q[:], [])\n        self.definition = qc\n\n    @property\n    def num_ancilla_qubits(self):\n        \"\"\"The number of ancilla qubits.\"\"\"\n        return self.__class__.get_num_ancilla_qubits(self.num_ctrl_qubits)\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a multi-controlled-X gate with more control lines.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if ctrl_state is None:\n            # use __class__ so this works for derived classes\n            return self.__class__(\n                self.num_ctrl_qubits + num_ctrl_qubits,\n                label=label,\n                ctrl_state=ctrl_state,\n                _base_label=self.label,\n            )\n        return super().control(num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n\nclass MCXGrayCode(MCXGate):\n    r\"\"\"Implement the multi-controlled X gate using the Gray code.\n\n    This delegates the implementation to the MCU1 gate, since :math:`X = H \\cdot U1(\\pi) \\cdot H`.\n    \"\"\"\n\n    def __new__(\n        cls,\n        num_ctrl_qubits: Optional[int] = None,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create a new MCXGrayCode instance\"\"\"\n        # if 1 to 4 control qubits, create explicit gates\n        explicit = {1: CXGate, 2: CCXGate, 3: C3XGate, 4: C4XGate}\n        gate_class = explicit.get(num_ctrl_qubits, None)\n        if gate_class is not None:\n            gate = gate_class.__new__(\n                gate_class,\n                label=label,\n                ctrl_state=ctrl_state,\n                _base_label=_base_label,\n                duration=duration,\n                unit=unit,\n            )\n            # if __new__ does not return the same type as cls, init is not called\n            gate.__init__(\n                label=label,\n                ctrl_state=ctrl_state,\n                duration=duration,\n                unit=unit,\n            )\n            return gate\n        return super().__new__(cls)\n\n    def __init__(\n        self,\n        num_ctrl_qubits: int,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        super().__init__(num_ctrl_qubits, label=label, ctrl_state=ctrl_state, _name=\"mcx_gray\")\n\n    def inverse(self):\n        \"\"\"Invert this gate. The MCX is its own inverse.\"\"\"\n        return MCXGrayCode(num_ctrl_qubits=self.num_ctrl_qubits, ctrl_state=self.ctrl_state)\n\n    def _define(self):\n        \"\"\"Define the MCX gate using the Gray code.\"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import MCU1Gate\n        from .h import HGate\n\n        q = QuantumRegister(self.num_qubits, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        qc._append(HGate(), [q[-1]], [])\n        qc._append(MCU1Gate(numpy.pi, num_ctrl_qubits=self.num_ctrl_qubits), q[:], [])\n        qc._append(HGate(), [q[-1]], [])\n        self.definition = qc\n\n\nclass MCXRecursive(MCXGate):\n    \"\"\"Implement the multi-controlled X gate using recursion.\n\n    Using a single ancilla qubit, the multi-controlled X gate is recursively split onto\n    four sub-registers. This is done until we reach the 3- or 4-controlled X gate since\n    for these we have a concrete implementation that do not require ancillas.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_ctrl_qubits: int,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        super().__init__(\n            num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            _name=\"mcx_recursive\",\n            duration=duration,\n            unit=unit,\n            _base_label=None,\n        )\n\n    @staticmethod\n    def get_num_ancilla_qubits(num_ctrl_qubits: int, mode: str = \"recursion\"):\n        \"\"\"Get the number of required ancilla qubits.\"\"\"\n        return MCXGate.get_num_ancilla_qubits(num_ctrl_qubits, mode)\n\n    def inverse(self):\n        \"\"\"Invert this gate. The MCX is its own inverse.\"\"\"\n        return MCXRecursive(num_ctrl_qubits=self.num_ctrl_qubits, ctrl_state=self.ctrl_state)\n\n    def _define(self):\n        \"\"\"Define the MCX gate using recursion.\"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        q = QuantumRegister(self.num_qubits, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        if self.num_qubits == 4:\n            qc._append(C3XGate(), q[:], [])\n            self.definition = qc\n        elif self.num_qubits == 5:\n            qc._append(C4XGate(), q[:], [])\n            self.definition = qc\n        else:\n            for instr, qargs, cargs in self._recurse(q[:-1], q_ancilla=q[-1]):\n                qc._append(instr, qargs, cargs)\n            self.definition = qc\n\n    def _recurse(self, q, q_ancilla=None):\n        # recursion stop\n        if len(q) == 4:\n            return [(C3XGate(), q[:], [])]\n        if len(q) == 5:\n            return [(C4XGate(), q[:], [])]\n        if len(q) < 4:\n            raise AttributeError(\"Something went wrong in the recursion, have less than 4 qubits.\")\n\n        # recurse\n        num_ctrl_qubits = len(q) - 1\n        middle = ceil(num_ctrl_qubits / 2)\n        first_half = [*q[:middle], q_ancilla]\n        second_half = [*q[middle:num_ctrl_qubits], q_ancilla, q[num_ctrl_qubits]]\n\n        rule = []\n        rule += self._recurse(first_half, q_ancilla=q[middle])\n        rule += self._recurse(second_half, q_ancilla=q[middle - 1])\n        rule += self._recurse(first_half, q_ancilla=q[middle])\n        rule += self._recurse(second_half, q_ancilla=q[middle - 1])\n\n        return rule\n\n\nclass MCXVChain(MCXGate):\n    \"\"\"Implement the multi-controlled X gate using a V-chain of CX gates.\"\"\"\n\n    def __new__(\n        cls,\n        num_ctrl_qubits: Optional[int] = None,\n        dirty_ancillas: bool = False,  # pylint: disable=unused-argument\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create a new MCX instance.\n\n        This must be defined anew to include the additional argument ``dirty_ancillas``.\n        \"\"\"\n        return super().__new__(\n            cls,\n            num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            _base_label=_base_label,\n            duration=duration,\n            unit=unit,\n        )\n\n    def __init__(\n        self,\n        num_ctrl_qubits: int,\n        dirty_ancillas: bool = False,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        super().__init__(\n            num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            _name=\"mcx_vchain\",\n            _base_label=_base_label,\n            duration=duration,\n            unit=unit,\n        )\n        self._dirty_ancillas = dirty_ancillas\n\n    def inverse(self):\n        \"\"\"Invert this gate. The MCX is its own inverse.\"\"\"\n        return MCXVChain(\n            num_ctrl_qubits=self.num_ctrl_qubits,\n            dirty_ancillas=self._dirty_ancillas,\n            ctrl_state=self.ctrl_state,\n        )\n\n    @staticmethod\n    def get_num_ancilla_qubits(num_ctrl_qubits: int, mode: str = \"v-chain\"):\n        \"\"\"Get the number of required ancilla qubits.\"\"\"\n        return MCXGate.get_num_ancilla_qubits(num_ctrl_qubits, mode)\n\n    def _define(self):\n        \"\"\"Define the MCX gate using a V-chain of CX gates.\"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n        from .u2 import U2Gate\n\n        q = QuantumRegister(self.num_qubits, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        q_controls = q[: self.num_ctrl_qubits]\n        q_target = q[self.num_ctrl_qubits]\n        q_ancillas = q[self.num_ctrl_qubits + 1 :]\n\n        definition = []\n\n        if self._dirty_ancillas:\n            i = self.num_ctrl_qubits - 3\n            ancilla_pre_rule = [\n                (U2Gate(0, numpy.pi), [q_target], []),\n                (CXGate(), [q_target, q_ancillas[i]], []),\n                (U1Gate(-numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_controls[-1], q_ancillas[i]], []),\n                (U1Gate(numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_target, q_ancillas[i]], []),\n                (U1Gate(-numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_controls[-1], q_ancillas[i]], []),\n                (U1Gate(numpy.pi / 4), [q_ancillas[i]], []),\n            ]\n            for inst in ancilla_pre_rule:\n                definition.append(inst)\n\n            for j in reversed(range(2, self.num_ctrl_qubits - 1)):\n                definition.append(\n                    (RCCXGate(), [q_controls[j], q_ancillas[i - 1], q_ancillas[i]], [])\n                )\n                i -= 1\n\n        definition.append((RCCXGate(), [q_controls[0], q_controls[1], q_ancillas[0]], []))\n        i = 0\n        for j in range(2, self.num_ctrl_qubits - 1):\n            definition.append((RCCXGate(), [q_controls[j], q_ancillas[i], q_ancillas[i + 1]], []))\n            i += 1\n\n        if self._dirty_ancillas:\n            ancilla_post_rule = [\n                (U1Gate(-numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_controls[-1], q_ancillas[i]], []),\n                (U1Gate(numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_target, q_ancillas[i]], []),\n                (U1Gate(-numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_controls[-1], q_ancillas[i]], []),\n                (U1Gate(numpy.pi / 4), [q_ancillas[i]], []),\n                (CXGate(), [q_target, q_ancillas[i]], []),\n                (U2Gate(0, numpy.pi), [q_target], []),\n            ]\n            for inst in ancilla_post_rule:\n                definition.append(inst)\n        else:\n            definition.append((CCXGate(), [q_controls[-1], q_ancillas[i], q_target], []))\n\n        for j in reversed(range(2, self.num_ctrl_qubits - 1)):\n            definition.append((RCCXGate(), [q_controls[j], q_ancillas[i - 1], q_ancillas[i]], []))\n            i -= 1\n        definition.append((RCCXGate(), [q_controls[0], q_controls[1], q_ancillas[i]], []))\n\n        if self._dirty_ancillas:\n            for i, j in enumerate(list(range(2, self.num_ctrl_qubits - 1))):\n                definition.append(\n                    (RCCXGate(), [q_controls[j], q_ancillas[i], q_ancillas[i + 1]], [])\n                )\n\n        for instr, qargs, cargs in definition:\n            qc._append(instr, qargs, cargs)\n        self.definition = qc\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e17121"
  },
  "id": "adfc88dd-b7b1-41a2-ad09-4a9a0dd95f42",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "qiskit",
  "path": "Python_qiskit_2lambda123_qiskit_qiskit.circuit.library.standard_gates.ry.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the Y axis.\"\"\"\n\nimport math\nfrom math import pi\nfrom typing import Optional, Union\nimport numpy\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RYGate(Gate):\n    r\"\"\"Single-qubit rotation about the Y axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ry` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Ry(ϴ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        RY(\\theta) = \\exp\\left(-i \\th Y\\right) =\n            \\begin{pmatrix}\n                \\cos\\left(\\th\\right) & -\\sin\\left(\\th\\right) \\\\\n                \\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self, theta: ParameterValueType, label: Optional[str] = None, *, duration=None, unit=\"dt\"\n    ):\n        \"\"\"Create new RY gate.\"\"\"\n        super().__init__(\"ry\", 1, [theta], label=label, duration=duration, unit=unit)\n\n    def _define(self):\n        \"\"\"\n        gate ry(theta) a { r(theta, pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .r import RGate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(RGate(self.params[0], pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RY gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRYGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RY gate.\n\n        :math:`RY(\\lambda)^{\\dagger} = RY(-\\lambda)`\n        \"\"\"\n        return RYGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RY gate.\"\"\"\n        cos = math.cos(self.params[0] / 2)\n        sin = math.sin(self.params[0] / 2)\n        return numpy.array([[cos, -sin], [sin, cos]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        (theta,) = self.params\n        return RYGate(exponent * theta)\n\n\nclass CRYGate(ControlledGate):\n    r\"\"\"Controlled-RY gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cry` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Ry(ϴ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        CRY(\\theta)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RY(\\theta) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0         & 0 & 0 \\\\\n                0 & \\cos\\left(\\th\\right) & 0 & -\\sin\\left(\\th\\right) \\\\\n                0 & 0         & 1 & 0 \\\\\n                0 & \\sin\\left(\\th\\right) & 0 & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Ry(ϴ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n            CRY(\\theta)\\ q_1, q_0 =\n            |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes RY(\\theta) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & \\cos\\left(\\th\\right) & -\\sin\\left(\\th\\right) \\\\\n                    0 & 0 & \\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n                \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n        *,\n        duration=None,\n        unit=\"dt\",\n        _base_label=None,\n    ):\n        \"\"\"Create new CRY gate.\"\"\"\n        super().__init__(\n            \"cry\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RYGate(theta, label=_base_label),\n            duration=duration,\n            unit=unit,\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cry(lambda) a,b\n        { u3(lambda/2,0,0) b; cx a,b;\n          u3(-lambda/2,0,0) b; cx a,b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate\n\n        # q_0: ─────────────■───────────────■──\n        #      ┌─────────┐┌─┴─┐┌─────────┐┌─┴─┐\n        # q_1: ┤ Ry(λ/2) ├┤ X ├┤ Ry(λ/2) ├┤ X ├\n        #      └─────────┘└───┘└─────────┘└───┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RYGate(self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (RYGate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRY gate (i.e. with the negative rotation angle).\"\"\"\n        return CRYGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRY gate.\"\"\"\n        half_theta = float(self.params[0]) / 2\n        cos = math.cos(half_theta)\n        sin = math.sin(half_theta)\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, cos, 0, -sin], [0, 0, 1, 0], [0, sin, 0, cos]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[cos, 0, -sin, 0], [0, 1, 0, 0], [sin, 0, cos, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c09c1f7ee332e1719d"
  },
  "id": "bdedadb8-4127-4888-b6a5-49e96b57892a",
  "language": "Python",
  "extension": "qiskit",
  "author": "vr100",
  "name": "qc-dm-backend",
  "path": "Python_qiskit_vr100_qc-dm-backend_aakash.circuits.teleport.py",
  "hybrid": true,
  "content": "import numpy as np\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit import execute\nfrom qiskit.providers.aakash import AAKASH_DM\nfrom utils import compare\n\nbackend1 = AAKASH_DM.get_backend('dm_simulator')\nbackend2 = AAKASH_DM.get_backend('qasm_simulator')\nbackend2.SHOW_FINAL_STATE = True\noptions = {}\n\nq = QuantumRegister(3, 'q')\nc = ClassicalRegister(3, 'c')\ncirc = QuantumCircuit(q, c)\n\ncirc.h(q[1])\ncirc.cx(q[1], q[2])\ncirc.h(q[0])\ncirc.cx(q[0], q[1])\ncirc.h(q[0])\n\nprint()\nprint(\"## Before measurement ##\")\nprint()\n\ncircuits = [circ]\njob = execute(circuits, backend1, **options)\naakash_result_before = job.result()\nprint(aakash_result_before)\n\njob = execute(circuits, backend2, **options)\nqasm_result_before = job.result()\nprint(qasm_result_before)\n\ncirc.measure(q[0], c[0])\ncirc.measure(q[1], c[1])\nif c[0] == 1:\n    circ.z(q[2])\nif c[1] == 1:\n    circ.x(q[2])\ncirc.measure(q[2], c[2])\n\nprint()\nprint(\"## After measurement ##\")\nprint()\n\ncircuits = [circ]\njob = execute(circuits, backend1, **options)\naakash_result = job.result()\nprint(aakash_result)\n\njob = execute(circuits, backend2, **options)\nqasm_result = job.result()\nprint(qasm_result)\n\nprint()\nsuccess = compare(aakash_result_before[\"results\"][0],\n    qasm_result_before.results[0])\nprint(f\"Comparing results before measurement: {success}\")\n\nsuccess = compare(aakash_result[\"results\"][0],\n    qasm_result.results[0])\nprint(f\"Comparing results after measurement: {success}\")\n",
  "circuit": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 10
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0.8
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 729,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"_\", {\"CONTROL\": 1}, \"H\", \"MEASURE\"], [\"H\", {\"CONTROL\": 2}, \"X\", \"MEASURE\"], [\"_\", \"X\", \"Z\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T21:58:51.693+00:00"
      },
      "value": 1
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 2,
          "column": 1,
          "fragment": "[[], [\"H\", {\"CONTROL\": 2}], [\"_\", \"X\"]]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c19c1f7ee332e17214"
  },
  "id": "b11da252-c092-4d39-96a4-1a25cb99b5bc",
  "language": "Python",
  "extension": "qiskit",
  "author": "dynexcoin",
  "name": "Dynex-Qiskit",
  "path": "Python_qiskit_dynexcoin_Dynex-Qiskit_dynex_qiskit_example_6.py",
  "hybrid": false,
  "content": "from dynexsdk.qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute\n\na = QuantumRegister(2)\nb = QuantumRegister(2)\nc = QuantumRegister(1)\ns = QuantumRegister(2)\nco = QuantumRegister(1)\n\na_ = ClassicalRegister(2)\nb_ = ClassicalRegister(2)\nc_ = ClassicalRegister(1)\ns_ = ClassicalRegister(2)\nco_ = ClassicalRegister(1)\n\n\ncircuit = QuantumCircuit(a,b,c,s,co,a_,b_,c_,s_,co_)\n\n\ncircuit.ccx(a[0],b[0],c[0])\ncircuit.cx(a[0],s[0])\ncircuit.cx(b[0],s[0])\n\ncircuit.ccx(c[0], a[1], co[0])\ncircuit.ccx(c[0], b[1], co[0])\ncircuit.ccx(a[1], b[1], co[0])\ncircuit.cx(c[0], s[1])\ncircuit.cx(a[1], s[1])\ncircuit.cx(b[1], s[1])\n\n\n#circuit.measure(c, c_)\ncircuit.measure(s, s_)\ncircuit.measure(co, co_)\n\nexecute(circuit)\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c19c1f7ee332e172bc"
  },
  "id": "1ad7375b-07aa-48a9-b541-8f75d2330896",
  "language": "Python",
  "extension": "qiskit",
  "author": "dynexcoin",
  "name": "Dynex-Qiskit",
  "path": "Python_qiskit_dynexcoin_Dynex-Qiskit_dynex_qiskit_example_3.py",
  "hybrid": false,
  "content": "from dynexsdk.qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute\nfrom sys import argv\n\nqin1 = QuantumRegister(1)\ncin1 = ClassicalRegister(1)\nqin2 = QuantumRegister(1)\ncin2 = ClassicalRegister(1)\n\n#output bit: function XORed onto this\nqz = QuantumRegister(1)\ncz = ClassicalRegister(1)\n\n#output bit: function XORed onto this\ntmp = QuantumRegister(1)\n\n#beginning of the circuit\ncircuit = QuantumCircuit(qin1,qin2,qz,tmp,cin1,cin2,cz)\n\n#initialize temp\ncircuit.x(tmp)\n\ncircuit.cx(tmp, qz)\ncircuit.ccx(qin1, tmp, qz)\ncircuit.ccx(qin2, tmp, qz)\n\n#reversing tmp\ncircuit.x(tmp)\n\n#circuit.measure(qin1, cin1)\n#circuit.measure(qin2, cin2)\ncircuit.measure(qz, cz)\n\nexecute(circuit)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17373"
  },
  "id": "60421d5f-bda8-4665-8da9-010ca96cafa3",
  "language": "Python",
  "extension": "qiskit",
  "author": "2lambda123",
  "name": "quantuminspire",
  "path": "Python_qiskit_2lambda123_quantuminspire_docs.examples.example_qiskit_conditional.py",
  "hybrid": true,
  "content": "\"\"\"Example usage of the Quantum Inspire backend with the Qiskit SDK.\n\nA simple example that demonstrates how to use the SDK to create\na circuit to demonstrate conditional gate execution.\n\nFor documentation on how to use Qiskit we refer to\n[https://qiskit.org/](https://qiskit.org/).\n\nSpecific to Quantum Inspire is the creation of the QI instance, which is used to set the authentication\nof the user and provides a Quantum Inspire backend that is used to execute the circuit.\n\nCopyright 2018-2022 QuTech Delft. Licensed under the Apache License, Version 2.0.\n\"\"\"\nimport os\n\nfrom qiskit import BasicAer, execute\nfrom qiskit.circuit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\nfrom quantuminspire.credentials import get_authentication\nfrom quantuminspire.qiskit import QI\n\nQI_URL = os.getenv('API_URL', 'https://api.quantum-inspire.com/')\n\n\nauthentication = get_authentication()\nQI.set_authentication(authentication, QI_URL)\nqi_backend = QI.get_backend('QX single-node simulator')\n\nq = QuantumRegister(3, \"q\")\nc0 = ClassicalRegister(1, \"c0\")\nc1 = ClassicalRegister(1, \"c1\")\nc2 = ClassicalRegister(1, \"c2\")\nqc = QuantumCircuit(q, c0, c1, c2, name=\"conditional\")\n\nqc.h(q[0])\nqc.h(q[1]).c_if(c0, 0)  # h-gate on q[1] is executed\nqc.h(q[2]).c_if(c1, 1)  # h-gate on q[2] is not executed\n\nqc.measure(q[0], c0)\nqc.measure(q[1], c1)\nqc.measure(q[2], c2)\n\nqi_job = execute(qc, backend=qi_backend, shots=1024)\nqi_result = qi_job.result()\nhistogram = qi_result.get_counts(qc)\nprint(\"\\nResult from the remote Quantum Inspire backend:\\n\")\nprint('State\\tCounts')\n[print('{0}\\t{1}'.format(state, counts)) for state, counts in histogram.items()]\n\nprint(\"\\nResult from the local Qiskit simulator backend:\\n\")\nbackend = BasicAer.get_backend(\"qasm_simulator\")\njob = execute(qc, backend=backend, shots=1024)\nresult = job.result()\nprint(result.get_counts(qc))\n",
  "circuit": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 732,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"], [\"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:03:23.222+00:00"
      },
      "value": 1
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": [
      {
        "id": 0,
        "position": {
          "qubit": 2,
          "column": 0,
          "fragment": "[[\"H\"], [\"H\"], [\"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17383"
  },
  "id": "294a08e0-02c6-43cd-aa68-b595cd603e7d",
  "language": "Python",
  "extension": "qiskit",
  "author": "viishnurs",
  "name": "ALU-in-Qiskit-",
  "path": "Python_qiskit_viishnurs_ALU-in-Qiskit-_ALU2 _QISKIT.py",
  "hybrid": true,
  "content": "# Importing standard Qiskit libraries\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit.tools.jupyter import *\nfrom qiskit.visualization import *\nfrom ibm_quantum_widgets import *\nfrom qiskit_aer import AerSimulator\n\n# qiskit-ibmq-provider has been deprecated.\n# Please see the Migration Guides in https://ibm.biz/provider_migration_guide for more detail.\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options\n\n# Loading your IBM Quantum account(s)\nservice = QiskitRuntimeService(channel=\"ibm_quantum\")\n\n# Invoke a primitive inside a session. For more details see https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials.html\n# with Session(backend=service.backend(\"ibmq_qasm_simulator\")):\n#     result = Sampler().run(circuits).result()\n\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\n# Create a quantum circuit with 8 qubits and 2 classical bits\nqr = QuantumRegister(8)\ncr = ClassicalRegister(2)\nqc = QuantumCircuit(qr, cr)\n\n# Define the input qubits\na = qr[0]\nb = qr[1]\nc = qr[2]\n\n# Define the output qubits\ns = qr[3]\nf = qr[4]\no = qr[5]\na_out = qr[6]\nh = qr[7]\n\n# 4x1 MUX\nqc.cx(a, s)\nqc.cx(b, s)\nqc.cx(c, f)\nqc.cx(b, f)\nqc.ccx(a, b, s)\nqc.ccx(a, c, f)\nqc.barrier()\n\n# Full Adder\nqc.cx(s, o)\nqc.cx(c, o)\nqc.ccx(s, c, f)\nqc.barrier()\n\n# OR logical block\nqc.cx(s, o)\nqc.cx(f, o)\nqc.barrier()\n\n# AND logical block\nqc.ccx(s, f, a_out)\nqc.barrier()\n\n# XOR logical block\nqc.cx(s, h)\nqc.cx(f, h)\nqc.barrier()\n\n# XNOR logical block\nqc.cx(h, a_out)\nqc.barrier()\n\n# 2x1 MUX\nqc.cx(s, a_out)\nqc.cx(h, a_out)\nqc.barrier()\n\n# Half Adder\nqc.cx(s, h)\nqc.cx(f, h)\nqc.barrier()\n\n# 3 input AND gate\nqc.ccx(s, f, h)\nqc.ccx(h, c, a_out)\n\n# Measure the output qubits\nqc.measure(a_out, cr[0])\nqc.measure(o, cr[1])\n\n# Draw the circuit\nqc.draw()\n",
  "circuit": "[[], [], [], [], [], [], [], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], [], [], [], [], [], [], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e173f3"
  },
  "id": "4476bb44-ccc0-4c12-b3ef-6ffe219b4769",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.y.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Y and CY gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\n# pylint: disable=cyclic-import\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\n\n_Y_ARRAY = [[0, -1j], [1j, 0]]\n\n\n@with_gate_array(_Y_ARRAY)\nclass YGate(Gate):\n    r\"\"\"The single-qubit Pauli-Y gate (:math:`\\sigma_y`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.y` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Y = \\begin{pmatrix}\n                0 & -i \\\\\n                i & 0\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Y ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Y axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RY(\\pi)` and :math:`Y`.\n\n        .. math::\n\n            RY(\\pi) = \\begin{pmatrix}\n                        0 & -1 \\\\\n                        1 & 0\n                      \\end{pmatrix}\n                    = -i Y\n\n    The gate is equivalent to a bit and phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow i|1\\rangle \\\\\n        |1\\rangle \\rightarrow -i|0\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Y gate.\"\"\"\n        super().__init__(\"y\", 1, [], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, pi / 2, pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Y gate.\n\n        One control returns a CY gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CYGate(label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted Y gate (:math:`Y^{\\dagger} = Y`)\"\"\"\n        return YGate()  # self-inverse\n\n\n@with_controlled_gate_array(_Y_ARRAY, num_ctrl_qubits=1)\nclass CYGate(ControlledGate):\n    r\"\"\"Controlled-Y gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cy` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ Y ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CY\\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + Y \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & -i \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & i & 0 & 0\n            \\end{pmatrix}\n\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───┐\n            q_0: ┤ Y ├\n                 └─┬─┘\n            q_1: ──■──\n\n        .. math::\n\n            CY\\ q_1, q_0 =\n                |0 \\rangle\\langle 0| \\otimes I + |1 \\rangle\\langle 1| \\otimes Y =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & 0 & -i \\\\\n                    0 & 0 & i & 0\n                \\end{pmatrix}\n\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CY gate.\"\"\"\n        super().__init__(\n            \"cy\", 2, [], num_ctrl_qubits=1, label=label, ctrl_state=ctrl_state, base_gate=YGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cy a,b { sdg b; cx a,b; s b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .s import SGate, SdgGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(SdgGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (SGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CY gate (itself).\"\"\"\n        return CYGate(ctrl_state=self.ctrl_state)  # self-inverse\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17410"
  },
  "id": "27296acd-4673-4c64-be4d-df7d0720d169",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.u1.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"U1 Gate.\"\"\"\nfrom __future__ import annotations\nfrom cmath import exp\nimport numpy\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import _ctrl_state_to_int\n\n\nclass U1Gate(Gate):\n    r\"\"\"Single-qubit rotation about the Z axis.\n\n    This is a diagonal gate. It can be implemented virtually in hardware\n    via framechanges (i.e. at zero error and duration).\n\n    .. warning::\n\n       This gate is deprecated. Instead, the following replacements should be used\n\n       .. math::\n\n           U1(\\lambda) = P(\\lambda)= U(0,0,\\lambda)\n\n       .. code-block:: python\n\n          circuit = QuantumCircuit(1)\n          circuit.p(lambda, 0) # or circuit.u(0, 0, lambda)\n\n\n\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ U1(λ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        U1(\\lambda) =\n            \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & e^{i\\lambda}\n            \\end{pmatrix}\n\n    **Examples:**\n\n        .. math::\n\n            U1(\\lambda = \\pi) = Z\n\n        .. math::\n\n            U1(\\lambda = \\pi/2) = S\n\n        .. math::\n\n            U1(\\lambda = \\pi/4) = T\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.RZGate`:\n        This gate is equivalent to RZ up to a phase factor.\n\n            .. math::\n\n                U1(\\lambda) = e^{i{\\lambda}/2} RZ(\\lambda)\n\n        :class:`~qiskit.circuit.library.standard_gates.U3Gate`:\n        U3 is a generalization of U2 that covers all single-qubit rotations,\n        using two X90 pulses.\n\n        Reference for virtual Z gate implementation:\n        `1612.00858 <https://arxiv.org/abs/1612.00858>`_\n    \"\"\"\n\n    def __init__(self, theta: ParameterValueType, label: str | None = None):\n        \"\"\"Create new U1 gate.\"\"\"\n        super().__init__(\"u1\", 1, [theta], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate  # pylint: disable=cyclic-import\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(0, 0, self.params[0]), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: str | None = None,\n        ctrl_state: str | int | None = None,\n    ):\n        \"\"\"Return a (multi-)controlled-U1 gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CU1Gate(self.params[0], label=label, ctrl_state=ctrl_state)\n        elif ctrl_state is None and num_ctrl_qubits > 1:\n            gate = MCU1Gate(self.params[0], num_ctrl_qubits, label=label)\n        else:\n            return super().control(\n                num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state\n            )\n        gate.base_gate.label = self.label\n        return gate\n\n    def inverse(self):\n        r\"\"\"Return inverted U1 gate (:math:`U1(\\lambda)^{\\dagger} = U1(-\\lambda)`)\"\"\"\n        return U1Gate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the U1 gate.\"\"\"\n        lam = float(self.params[0])\n        return numpy.array([[1, 0], [0, numpy.exp(1j * lam)]], dtype=dtype)\n\n\nclass CU1Gate(ControlledGate):\n    r\"\"\"Controlled-U1 gate.\n\n    This is a diagonal and symmetric gate that induces a\n    phase on the state of the target qubit, depending on the control state.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n\n        q_0: ─■──\n              │λ\n        q_1: ─■──\n\n\n    **Matrix representation:**\n\n    .. math::\n\n        CU1(\\lambda) =\n            I \\otimes |0\\rangle\\langle 0| + U1 \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & e^{i\\lambda}\n            \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.CRZGate`:\n        Due to the global phase difference in the matrix definitions\n        of U1 and RZ, CU1 and CRZ are different gates with a relative\n        phase difference.\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: str | None = None,\n        ctrl_state: str | int | None = None,\n    ):\n        \"\"\"Create new CU1 gate.\"\"\"\n        super().__init__(\n            \"cu1\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=U1Gate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cu1(lambda) a,b\n        { u1(lambda/2) a; cx a,b;\n          u1(-lambda/2) b; cx a,b;\n          u1(lambda/2) b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate  # pylint: disable=cyclic-import\n\n        #      ┌─────────┐\n        # q_0: ┤ U1(λ/2) ├──■────────────────■─────────────\n        #      └─────────┘┌─┴─┐┌──────────┐┌─┴─┐┌─────────┐\n        # q_1: ───────────┤ X ├┤ U1(-λ/2) ├┤ X ├┤ U1(λ/2) ├\n        #                 └───┘└──────────┘└───┘└─────────┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (U1Gate(self.params[0] / 2), [q[0]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U1Gate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U1Gate(self.params[0] / 2), [q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: str | None = None,\n        ctrl_state: str | int | None = None,\n    ):\n        \"\"\"Controlled version of this gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if ctrl_state is None:\n            gate = MCU1Gate(self.params[0], num_ctrl_qubits=num_ctrl_qubits + 1, label=label)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted CU1 gate (:math:`CU1(\\lambda)^{\\dagger} = CU1(-\\lambda)`)\"\"\"\n        return CU1Gate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CU1 gate.\"\"\"\n        eith = exp(1j * float(self.params[0]))\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, eith]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, eith, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n\n\nclass MCU1Gate(ControlledGate):\n    r\"\"\"Multi-controlled-U1 gate.\n\n    This is a diagonal and symmetric gate that induces a\n    phase on the state of the target qubit, depending on the state of the control qubits.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n            q_0: ────■────\n                     │\n                     .\n                     │\n        q_(n-1): ────■────\n                 ┌───┴───┐\n            q_n: ┤ U1(λ) ├\n                 └───────┘\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.CU1Gate`:\n        The singly-controlled-version of this gate.\n    \"\"\"\n\n    def __init__(\n        self,\n        lam: ParameterValueType,\n        num_ctrl_qubits: int,\n        label: str | None = None,\n        ctrl_state: str | int | None = None,\n    ):\n        \"\"\"Create new MCU1 gate.\"\"\"\n        super().__init__(\n            \"mcu1\",\n            num_ctrl_qubits + 1,\n            [lam],\n            num_ctrl_qubits=num_ctrl_qubits,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=U1Gate(lam),\n        )\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        q = QuantumRegister(self.num_qubits, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n\n        if self.num_ctrl_qubits == 0:\n            definition = U1Gate(self.params[0]).definition\n        if self.num_ctrl_qubits == 1:\n            definition = CU1Gate(self.params[0]).definition\n        else:\n            from .u3 import _gray_code_chain\n\n            scaled_lam = self.params[0] / (2 ** (self.num_ctrl_qubits - 1))\n            bottom_gate = CU1Gate(scaled_lam)\n            definition = _gray_code_chain(q, self.num_ctrl_qubits, bottom_gate)\n        for instr, qargs, cargs in definition:\n            qc._append(instr, qargs, cargs)\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: str | None = None,\n        ctrl_state: str | int | None = None,\n    ):\n        \"\"\"Controlled version of this gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n        new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n        gate = MCU1Gate(\n            self.params[0],\n            num_ctrl_qubits=num_ctrl_qubits + self.num_ctrl_qubits,\n            label=label,\n            ctrl_state=new_ctrl_state,\n        )\n        gate.base_gate.label = self.label\n        return gate\n\n    def inverse(self):\n        r\"\"\"Return inverted MCU1 gate (:math:`MCU1(\\lambda)^{\\dagger} = MCU1(-\\lambda)`)\"\"\"\n        return MCU1Gate(-self.params[0], self.num_ctrl_qubits)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17433"
  },
  "id": "08788c8e-a054-48a3-8a04-e9611666e21f",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.rz.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the Z axis.\"\"\"\nfrom cmath import exp\nfrom typing import Optional, Union\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RZGate(Gate):\n    r\"\"\"Single-qubit rotation about the Z axis.\n\n    This is a diagonal gate. It can be implemented virtually in hardware\n    via framechanges (i.e. at zero error and duration).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        RZ(\\lambda) = \\exp\\left(-i\\frac{\\lambda}{2}Z\\right) =\n            \\begin{pmatrix}\n                e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.U1Gate`\n        This gate is equivalent to U1 up to a phase factor.\n\n            .. math::\n\n                U1(\\lambda) = e^{i{\\lambda}/2}RZ(\\lambda)\n\n        Reference for virtual Z gate implementation:\n        `1612.00858 <https://arxiv.org/abs/1612.00858>`_\n    \"\"\"\n\n    def __init__(self, phi: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new RZ gate.\"\"\"\n        super().__init__(\"rz\", 1, [phi], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate rz(phi) a { u1(phi) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        theta = self.params[0]\n        qc = QuantumCircuit(q, name=self.name, global_phase=-theta / 2)\n        rules = [(U1Gate(theta), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRZGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RZ gate\n\n        :math:`RZ(\\lambda)^{\\dagger} = RZ(-\\lambda)`\n        \"\"\"\n        return RZGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RZ gate.\"\"\"\n        import numpy as np\n\n        ilam2 = 0.5j * float(self.params[0])\n        return np.array([[exp(-ilam2), 0], [0, exp(ilam2)]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        (theta,) = self.params\n        return RZGate(exponent * theta)\n\n\nclass CRZGate(ControlledGate):\n    r\"\"\"Controlled-RZ gate.\n\n    This is a diagonal but non-symmetric gate that induces a\n    phase on the state of the target qubit, depending on the control state.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.crz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CRZ(\\lambda)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RZ(\\lambda) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & e^{-i\\frac{\\lambda}{2}} & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Rz(λ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            CRZ(\\lambda)\\ q_1, q_0 =\n                |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes RZ(\\lambda) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                    0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n                \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.CU1Gate`:\n        Due to the global phase difference in the matrix definitions\n        of U1 and RZ, CU1 and CRZ are different gates with a relative\n        phase difference.\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Create new CRZ gate.\"\"\"\n        super().__init__(\n            \"crz\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RZGate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate crz(lambda) a,b\n        { rz(lambda/2) b; cx a,b;\n          rz(-lambda/2) b; cx a,b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate\n\n        # q_0: ─────────────■────────────────■──\n        #      ┌─────────┐┌─┴─┐┌──────────┐┌─┴─┐\n        # q_1: ┤ Rz(λ/2) ├┤ X ├┤ Rz(-λ/2) ├┤ X ├\n        #      └─────────┘└───┘└──────────┘└───┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RZGate(self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (RZGate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRZ gate (i.e. with the negative rotation angle).\"\"\"\n        return CRZGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRZ gate.\"\"\"\n        import numpy\n\n        arg = 1j * float(self.params[0]) / 2\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, exp(-arg), 0, 0], [0, 0, 1, 0], [0, 0, 0, exp(arg)]],\n                dtype=dtype,\n            )\n        else:\n            return numpy.array(\n                [[exp(-arg), 0, 0, 0], [0, 1, 0, 0], [0, 0, exp(arg), 0], [0, 0, 0, 1]],\n                dtype=dtype,\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17470"
  },
  "id": "d0b554f6-7d86-44dc-9fe4-1fcad6ecda47",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.s.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The S, Sdg, CS and CSdg gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\nimport numpy\n\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.library.standard_gates.p import CPhaseGate, PhaseGate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\n\n\n_S_ARRAY = numpy.array([[1, 0], [0, 1j]])\n_SDG_ARRAY = numpy.array([[1, 0], [0, -1j]])\n\n\n@with_gate_array(_S_ARRAY)\nclass SGate(Gate):\n    r\"\"\"Single qubit S gate (Z**0.5).\n\n    It induces a :math:`\\pi/2` phase, and is sometimes called the P gate (phase).\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.s` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        S = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ S ├\n             └───┘\n\n    Equivalent to a :math:`\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new S gate.\"\"\"\n        super().__init__(\"s\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate s a { u1(pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of S (SdgGate).\"\"\"\n        return SdgGate()\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return PhaseGate(0.5 * numpy.pi * exponent)\n\n\n@with_gate_array(_SDG_ARRAY)\nclass SdgGate(Gate):\n    r\"\"\"Single qubit S-adjoint gate (~Z**0.5).\n\n    It induces a :math:`-\\pi/2` phase.\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.sdg` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Sdg = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────┐\n        q_0: ┤ Sdg ├\n             └─────┘\n\n    Equivalent to a :math:`-\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Sdg gate.\"\"\"\n        super().__init__(\"sdg\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate sdg a { u1(-pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(-pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of Sdg (SGate).\"\"\"\n        return SGate()\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return PhaseGate(-0.5 * numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_S_ARRAY, num_ctrl_qubits=1)\nclass CSGate(ControlledGate):\n    r\"\"\"Controlled-S gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cs` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ S ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & i\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CS gate.\"\"\"\n        super().__init__(\n            \"cs\", 2, [], label=label, num_ctrl_qubits=1, ctrl_state=ctrl_state, base_gate=SGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cs a,b { h b; cp(pi/2) a,b; h b; }\n        \"\"\"\n        self.definition = CPhaseGate(theta=pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSGate (CSdgGate).\"\"\"\n        return CSdgGate(ctrl_state=self.ctrl_state)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return CPhaseGate(0.5 * numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_SDG_ARRAY, num_ctrl_qubits=1)\nclass CSdgGate(ControlledGate):\n    r\"\"\"Controlled-S^\\dagger gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.csdg` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ───■───\n             ┌──┴──┐\n        q_1: ┤ Sdg ├\n             └─────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS^\\dagger \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S^\\dagger \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -i\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CSdg gate.\"\"\"\n        super().__init__(\n            \"csdg\",\n            2,\n            [],\n            label=label,\n            num_ctrl_qubits=1,\n            ctrl_state=ctrl_state,\n            base_gate=SdgGate(),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate csdg a,b { h b; cp(-pi/2) a,b; h b; }\n        \"\"\"\n        self.definition = CPhaseGate(theta=-pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSdgGate (CSGate).\"\"\"\n        return CSGate(ctrl_state=self.ctrl_state)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return CPhaseGate(-0.5 * numpy.pi * exponent)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e17471"
  },
  "id": "24b7a136-43b3-4fdf-afbc-d0e6a396f032",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.rx.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the X axis.\"\"\"\n\nimport math\nfrom math import pi\nfrom typing import Optional, Union\nimport numpy\n\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RXGate(Gate):\n    r\"\"\"Single-qubit rotation about the X axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rx` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Rx(ϴ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        RX(\\theta) = \\exp\\left(-i \\th X\\right) =\n            \\begin{pmatrix}\n                \\cos\\left(\\th\\right)   & -i\\sin\\left(\\th\\right) \\\\\n                -i\\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(self, theta: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new RX gate.\"\"\"\n        super().__init__(\"rx\", 1, [theta], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate rx(theta) a {r(theta, 0) a;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .r import RGate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(RGate(self.params[0], 0), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RX gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRXGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RX gate.\n\n        :math:`RX(\\lambda)^{\\dagger} = RX(-\\lambda)`\n        \"\"\"\n        return RXGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RX gate.\"\"\"\n        cos = math.cos(self.params[0] / 2)\n        sin = math.sin(self.params[0] / 2)\n        return numpy.array([[cos, -1j * sin], [-1j * sin, cos]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        (theta,) = self.params\n        return RXGate(exponent * theta)\n\n\nclass CRXGate(ControlledGate):\n    r\"\"\"Controlled-RX gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.crx` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Rx(ϴ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        CRX(\\theta)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RX(\\theta) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & \\cos\\left(\\th\\right) & 0 & -i\\sin\\left(\\th\\right) \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & -i\\sin\\left(\\th\\right) & 0 & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Rx(ϴ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n            CRX(\\theta)\\ q_1, q_0 =\n            |0\\rangle\\langle0| \\otimes I + |1\\rangle\\langle1| \\otimes RX(\\theta) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & \\cos\\left(\\th\\right)   & -i\\sin\\left(\\th\\right) \\\\\n                    0 & 0 & -i\\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n                \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Create new CRX gate.\"\"\"\n        super().__init__(\n            \"crx\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RXGate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cu3(theta,phi,lambda) c, t\n        { u1(pi/2) t;\n          cx c,t;\n          u3(-theta/2,0,0) t;\n          cx c,t;\n          u3(theta/2,-pi/2,0) t;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n        from .u3 import U3Gate\n        from .x import CXGate\n\n        # q_0: ─────────────■───────────────────■────────────────────\n        #      ┌─────────┐┌─┴─┐┌─────────────┐┌─┴─┐┌────────────────┐\n        # q_1: ┤ U1(π/2) ├┤ X ├┤ U3(0/2,0,0) ├┤ X ├┤ U3(0/2,-π/2,0) ├\n        #      └─────────┘└───┘└─────────────┘└───┘└────────────────┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (U1Gate(pi / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U3Gate(-self.params[0] / 2, 0, 0), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U3Gate(self.params[0] / 2, -pi / 2, 0), [q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRX gate (i.e. with the negative rotation angle).\"\"\"\n        return CRXGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRX gate.\"\"\"\n        half_theta = float(self.params[0]) / 2\n        cos = math.cos(half_theta)\n        isin = 1j * math.sin(half_theta)\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, cos, 0, -isin], [0, 0, 1, 0], [0, -isin, 0, cos]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[cos, 0, -isin, 0], [0, 1, 0, 0], [-isin, 0, cos, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e174c1"
  },
  "id": "142a970b-d081-414f-8308-6323070ca466",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.r.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around an axis in x-y plane.\"\"\"\n\nimport math\nfrom cmath import exp\nfrom math import pi\nfrom typing import Optional\nimport numpy\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RGate(Gate):\n    r\"\"\"Rotation θ around the cos(φ)x + sin(φ)y axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.r` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌──────┐\n        q_0: ┤ R(ϴ) ├\n             └──────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        R(\\theta, \\phi) = e^{-i \\th \\left(\\cos{\\phi} x + \\sin{\\phi} y\\right)} =\n            \\begin{pmatrix}\n                \\cos\\left(\\th\\right) & -i e^{-i \\phi} \\sin\\left(\\th\\right) \\\\\n                -i e^{i \\phi} \\sin\\left(\\th\\right) & \\cos\\left(\\th\\right)\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self, theta: ParameterValueType, phi: ParameterValueType, label: Optional[str] = None\n    ):\n        \"\"\"Create new r single-qubit gate.\"\"\"\n        super().__init__(\"r\", 1, [theta, phi], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate r(θ, φ) a {u3(θ, φ - π/2, -φ + π/2) a;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        theta = self.params[0]\n        phi = self.params[1]\n        rules = [(U3Gate(theta, phi - pi / 2, -phi + pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Invert this gate.\n\n        r(θ, φ)^dagger = r(-θ, φ)\n        \"\"\"\n        return RGate(-self.params[0], self.params[1])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the R gate.\"\"\"\n        theta, phi = float(self.params[0]), float(self.params[1])\n        cos = math.cos(theta / 2)\n        sin = math.sin(theta / 2)\n        exp_m = exp(-1j * phi)\n        exp_p = exp(1j * phi)\n        return numpy.array([[cos, -1j * exp_m * sin], [-1j * exp_p * sin, cos]], dtype=dtype)\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        theta, phi = self.params\n        return RGate(exponent * theta, phi)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c29c1f7ee332e174d7"
  },
  "id": "0b66fcd0-9183-4452-aabd-7dcf883e647c",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.z.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Z, CZ and CCZ gates.\"\"\"\n\nfrom math import pi\nfrom typing import Optional, Union\n\nimport numpy\n\nfrom qiskit.circuit._utils import with_gate_array, with_controlled_gate_array\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\nfrom .p import PhaseGate\n\n_Z_ARRAY = [[1, 0], [0, -1]]\n\n\n@with_gate_array(_Z_ARRAY)\nclass ZGate(Gate):\n    r\"\"\"The single-qubit Pauli-Z gate (:math:`\\sigma_z`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.z` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Z = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -1\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Z ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Z axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RZ(\\pi)` and :math:`Z`.\n\n        .. math::\n\n            RZ(\\pi) = \\begin{pmatrix}\n                        -i & 0 \\\\\n                        0 & i\n                      \\end{pmatrix}\n                    = -i Z\n\n    The gate is equivalent to a phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow |0\\rangle \\\\\n        |1\\rangle \\rightarrow -|1\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Z gate.\"\"\"\n        super().__init__(\"z\", 1, [], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Z gate.\n\n        One control returns a CZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CZGate(label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        \"\"\"Return inverted Z gate (itself).\"\"\"\n        return ZGate()  # self-inverse\n\n    def power(self, exponent: float):\n        \"\"\"Raise gate to a power.\"\"\"\n        return PhaseGate(numpy.pi * exponent)\n\n\n@with_controlled_gate_array(_Z_ARRAY, num_ctrl_qubits=1)\nclass CZGate(ControlledGate):\n    r\"\"\"Controlled-Z gate.\n\n    This is a Clifford and symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CZ\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + Z \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubit is in the :math:`|1\\rangle` state.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CZ gate.\"\"\"\n        super().__init__(\n            \"cz\", 2, [], label=label, num_ctrl_qubits=1, ctrl_state=ctrl_state, base_gate=ZGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cz a,b { h b; cx a,b; h b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .h import HGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (HGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CZ gate (itself).\"\"\"\n        return CZGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n\n@with_controlled_gate_array(_Z_ARRAY, num_ctrl_qubits=2, cached_states=(3,))\nclass CCZGate(ControlledGate):\n    r\"\"\"CCZ gate.\n\n    This is a symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ccz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n              │\n        q_2: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CCZ\\ q_0, q_1, q_2 =\n            I \\otimes I \\otimes |0\\rangle\\langle 0| + CZ \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubits are in the :math:`|11\\rangle` state.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CCZ gate.\"\"\"\n        super().__init__(\n            \"ccz\", 3, [], label=label, num_ctrl_qubits=2, ctrl_state=ctrl_state, base_gate=ZGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate ccz a,b,c { h c; ccx a,b,c; h c; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n\n        from .h import HGate\n        from .x import CCXGate\n\n        q = QuantumRegister(3, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[2]], []), (CCXGate(), [q[0], q[1], q[2]], []), (HGate(), [q[2]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CCZ gate (itself).\"\"\"\n        return CCZGate(ctrl_state=self.ctrl_state)  # self-inverse\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c39c1f7ee332e17500"
  },
  "id": "2b6194e5-ba33-45c4-bd0a-e9d503b292cb",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.circuit.library.standard_gates.u2.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"One-pulse single-qubit gate.\"\"\"\nfrom math import sqrt, pi\nfrom cmath import exp\nfrom typing import Optional\nimport numpy\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\n\nclass U2Gate(Gate):\n    r\"\"\"Single-qubit rotation about the X+Z axis.\n\n    Implemented using one X90 pulse on IBM Quantum systems:\n\n    .. warning::\n\n       This gate is deprecated. Instead, the following replacements should be used\n\n       .. math::\n\n           U2(\\phi, \\lambda) = U\\left(\\frac{\\pi}{2}, \\phi, \\lambda\\right)\n\n       .. code-block:: python\n\n          circuit = QuantumCircuit(1)\n          circuit.u(pi/2, phi, lambda)\n\n\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────────┐\n        q_0: ┤ U2(φ,λ) ├\n             └─────────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        U2(\\phi, \\lambda) = \\frac{1}{\\sqrt{2}}\n            \\begin{pmatrix}\n                1          & -e^{i\\lambda} \\\\\n                e^{i\\phi} & e^{i(\\phi+\\lambda)}\n            \\end{pmatrix}\n\n    **Examples:**\n\n    .. math::\n\n        U2(\\phi,\\lambda) = e^{i \\frac{\\phi + \\lambda}{2}}RZ(\\phi)\n        RY\\left(\\frac{\\pi}{2}\\right) RZ(\\lambda)\n        = e^{- i\\frac{\\pi}{4}} P\\left(\\frac{\\pi}{2} + \\phi\\right)\n        \\sqrt{X} P\\left(\\lambda- \\frac{\\pi}{2}\\right)\n\n    .. math::\n\n        U2(0, \\pi) = H\n\n    .. math::\n\n        U2(0, 0) = RY(\\pi/2)\n\n    .. math::\n\n        U2(-\\pi/2, \\pi/2) = RX(\\pi/2)\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.U3Gate`:\n        U3 is a generalization of U2 that covers all single-qubit rotations,\n        using two X90 pulses.\n    \"\"\"\n\n    def __init__(\n        self, phi: ParameterValueType, lam: ParameterValueType, label: Optional[str] = None\n    ):\n        \"\"\"Create new U2 gate.\"\"\"\n        super().__init__(\"u2\", 1, [phi, lam], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi / 2, self.params[0], self.params[1]), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Return inverted U2 gate.\n\n        :math:`U2(\\phi, \\lambda)^{\\dagger} =U2(-\\lambda-\\pi, -\\phi+\\pi)`)\n        \"\"\"\n        return U2Gate(-self.params[1] - pi, -self.params[0] + pi)\n\n    def __array__(self, dtype=complex):\n        \"\"\"Return a Numpy.array for the U2 gate.\"\"\"\n        isqrt2 = 1 / sqrt(2)\n        phi, lam = self.params\n        phi, lam = float(phi), float(lam)\n        return numpy.array(\n            [\n                [isqrt2, -exp(1j * lam) * isqrt2],\n                [exp(1j * phi) * isqrt2, exp(1j * (phi + lam)) * isqrt2],\n            ],\n            dtype=dtype,\n        )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c39c1f7ee332e1759e"
  },
  "id": "4cf746d6-5355-4862-ada8-25bdb690a7f9",
  "language": "Python",
  "extension": "qiskit",
  "author": "athu070",
  "name": "quantum-glasses",
  "path": "Python_qiskit_athu070_quantum-glasses_venv.Lib.site-packages.qiskit.extensions.unitary.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nArbitrary unitary circuit instruction.\n\"\"\"\n\nimport numpy\n\nfrom qiskit.circuit import Gate, ControlledGate\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister, Qubit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit._utils import _compute_control_matrix\nfrom qiskit.circuit.library.standard_gates import U3Gate\nfrom qiskit.extensions.quantum_initializer import isometry\nfrom qiskit.quantum_info.operators.predicates import matrix_equal\nfrom qiskit.quantum_info.operators.predicates import is_unitary_matrix\nfrom qiskit.quantum_info.synthesis.one_qubit_decompose import OneQubitEulerDecomposer\nfrom qiskit.quantum_info.synthesis.two_qubit_decompose import two_qubit_cnot_decompose\nfrom qiskit.extensions.exceptions import ExtensionError\n\n_DECOMPOSER1Q = OneQubitEulerDecomposer(\"U3\")\n\n\nclass UnitaryGate(Gate):\n    \"\"\"Class quantum gates specified by a unitary matrix.\n\n    Example:\n\n        We can create a unitary gate from a unitary matrix then add it to a\n        quantum circuit. The matrix can also be directly applied to the quantum\n        circuit, see :meth:`.QuantumCircuit.unitary`.\n\n        .. code-block:: python\n\n            from qiskit import QuantumCircuit\n            from qiskit.extensions import UnitaryGate\n\n            matrix = [[0, 0, 0, 1],\n                      [0, 0, 1, 0],\n                      [1, 0, 0, 0],\n                      [0, 1, 0, 0]]\n            gate = UnitaryGate(matrix)\n\n            circuit = QuantumCircuit(2)\n            circuit.append(gate, [0, 1])\n    \"\"\"\n\n    def __init__(self, data, label=None):\n        \"\"\"Create a gate from a numeric unitary matrix.\n\n        Args:\n            data (matrix or Operator): unitary operator.\n            label (str): unitary name for backend [Default: None].\n\n        Raises:\n            ExtensionError: if input data is not an N-qubit unitary operator.\n        \"\"\"\n        if hasattr(data, \"to_matrix\"):\n            # If input is Gate subclass or some other class object that has\n            # a to_matrix method this will call that method.\n            data = data.to_matrix()\n        elif hasattr(data, \"to_operator\"):\n            # If input is a BaseOperator subclass this attempts to convert\n            # the object to an Operator so that we can extract the underlying\n            # numpy matrix from `Operator.data`.\n            data = data.to_operator().data\n        # Convert to numpy array in case not already an array\n        data = numpy.array(data, dtype=complex)\n        # Check input is unitary\n        if not is_unitary_matrix(data):\n            raise ExtensionError(\"Input matrix is not unitary.\")\n        # Check input is N-qubit matrix\n        input_dim, output_dim = data.shape\n        num_qubits = int(numpy.log2(input_dim))\n        if input_dim != output_dim or 2**num_qubits != input_dim:\n            raise ExtensionError(\"Input matrix is not an N-qubit operator.\")\n\n        # Store instruction params\n        super().__init__(\"unitary\", num_qubits, [data], label=label)\n\n    def __eq__(self, other):\n        if not isinstance(other, UnitaryGate):\n            return False\n        if self.label != other.label:\n            return False\n        # Should we match unitaries as equal if they are equal\n        # up to global phase?\n        return matrix_equal(self.params[0], other.params[0], ignore_phase=True)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return matrix for the unitary.\"\"\"\n        # pylint: disable=unused-argument\n        return self.params[0]\n\n    def inverse(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return self.adjoint()\n\n    def conjugate(self):\n        \"\"\"Return the conjugate of the unitary.\"\"\"\n        return UnitaryGate(numpy.conj(self.to_matrix()))\n\n    def adjoint(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return self.transpose().conjugate()\n\n    def transpose(self):\n        \"\"\"Return the transpose of the unitary.\"\"\"\n        return UnitaryGate(numpy.transpose(self.to_matrix()))\n\n    def _define(self):\n        \"\"\"Calculate a subcircuit that implements this unitary.\"\"\"\n        if self.num_qubits == 1:\n            q = QuantumRegister(1, \"q\")\n            qc = QuantumCircuit(q, name=self.name)\n            theta, phi, lam, global_phase = _DECOMPOSER1Q.angles_and_phase(self.to_matrix())\n            qc._append(U3Gate(theta, phi, lam), [q[0]], [])\n            qc.global_phase = global_phase\n            self.definition = qc\n        elif self.num_qubits == 2:\n            self.definition = two_qubit_cnot_decompose(self.to_matrix())\n        else:\n            from qiskit.quantum_info.synthesis.qsd import (  # pylint: disable=cyclic-import\n                qs_decomposition,\n            )\n\n            self.definition = qs_decomposition(self.to_matrix())\n\n    def control(self, num_ctrl_qubits=1, label=None, ctrl_state=None):\n        \"\"\"Return controlled version of gate\n\n        Args:\n            num_ctrl_qubits (int): number of controls to add to gate (default=1)\n            label (str): optional gate label\n            ctrl_state (int or str or None): The control state in decimal or as a\n                bit string (e.g. '1011'). If None, use 2**num_ctrl_qubits-1.\n\n        Returns:\n            UnitaryGate: controlled version of gate.\n\n        Raises:\n            QiskitError: Invalid ctrl_state.\n            ExtensionError: Non-unitary controlled unitary.\n        \"\"\"\n        mat = self.to_matrix()\n        cmat = _compute_control_matrix(mat, num_ctrl_qubits, ctrl_state=None)\n        iso = isometry.Isometry(cmat, 0, 0)\n        return ControlledGate(\n            \"c-unitary\",\n            num_qubits=self.num_qubits + num_ctrl_qubits,\n            params=[mat],\n            label=label,\n            num_ctrl_qubits=num_ctrl_qubits,\n            definition=iso.definition,\n            ctrl_state=ctrl_state,\n            base_gate=self.copy(),\n        )\n\n    def _qasm2_decomposition(self):\n        \"\"\"Return an unparameterized version of ourselves, so the OQ2 exporter doesn't choke on the\n        non-standard things in our `params` field.\"\"\"\n        out = self.definition.to_gate()\n        out.name = self.name\n        return out\n\n    def validate_parameter(self, parameter):\n        \"\"\"Unitary gate parameter has to be an ndarray.\"\"\"\n        if isinstance(parameter, numpy.ndarray):\n            return parameter\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} in gate {self.name}\")\n\n\ndef unitary(self, obj, qubits, label=None):\n    \"\"\"Apply unitary gate specified by ``obj`` to ``qubits``.\n\n    Args:\n        obj (matrix or Operator): unitary operator.\n        qubits (Union[int, Tuple[int]]): The circuit qubits to apply the\n            transformation to.\n        label (str): unitary name for backend [Default: None].\n\n    Returns:\n        QuantumCircuit: The quantum circuit.\n\n    Raises:\n        ExtensionError: if input data is not an N-qubit unitary operator.\n\n    Example:\n\n        Apply a gate specified by a unitary matrix to a quantum circuit\n\n        .. code-block:: python\n\n            from qiskit import QuantumCircuit\n            matrix = [[0, 0, 0, 1],\n                      [0, 0, 1, 0],\n                      [1, 0, 0, 0],\n                      [0, 1, 0, 0]]\n            circuit = QuantumCircuit(2)\n            circuit.unitary(matrix, [0, 1])\n    \"\"\"\n    gate = UnitaryGate(obj, label=label)\n    if isinstance(qubits, QuantumRegister):\n        qubits = qubits[:]\n    # for single qubit unitary gate, allow an 'int' or a 'list of ints' as qubits.\n    if gate.num_qubits == 1:\n        if isinstance(qubits, (int, Qubit)) or len(qubits) > 1:\n            qubits = [qubits]\n    return self.append(gate, qubits, [])\n\n\nQuantumCircuit.unitary = unitary\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c39c1f7ee332e175d0"
  },
  "id": "da59c2e5-6c43-4ab3-93d3-04ba7ade295e",
  "language": "Python",
  "extension": "qiskit",
  "author": "Ottermad",
  "name": "ProgrammingQuantumComputers",
  "path": "Python_qiskit_Ottermad_ProgrammingQuantumComputers_cnot_logic.py",
  "hybrid": true,
  "content": "\"\"\"Uses CNOT to implement some logic.\"\"\"\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile\nfrom qiskit.circuit.library.standard_gates import XGate\nfrom qiskit_aer import AerSimulator\n\n\nregister1 = QuantumRegister(3)\nregister2 = QuantumRegister(3)\nregister3 = QuantumRegister(3)\n\ncircuit = QuantumCircuit(register1, register2, register3)\n\n# c = not c\ncircuit.x(register1[2])\n\n# if (b) then c = not c\ncircuit.x(register2[1])\ncircuit.cx(register2[1], register2[2])\n\n# if (a and b) then c = not c\ncircuit.x(register3[0])\ncircuit.x(register3[1])\ncircuit.ccx(register3[0], register3[1], register3[2])\n\ncircuit.measure_all()\n\nsimulator = AerSimulator()\n\ncompiled_circuit = transpile(circuit, simulator)\n\njob = simulator.run(compiled_circuit, shots=1000)\n\nresult = job.result()\ncounts = result.get_counts(compiled_circuit)\n\nprint(counts)\n",
  "circuit": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 1.6666666666666667
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0.8
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 745,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\"], [\"X\", {\"CONTROL\": 2}, \"X\"], [\"X\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:14:19.035+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": [
      {
        "id": 0,
        "position": {
          "qubit": 2,
          "column": 0,
          "fragment": "[[\"X\"], [\"X\"], [\"X\"]]"
        }
      }
    ],
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c39c1f7ee332e175fa"
  },
  "id": "36198660-66da-4623-a294-46e185bbb7ec",
  "language": "Python",
  "extension": "qiskit",
  "author": "constatza",
  "name": "qlib",
  "path": "Python_qiskit_constatza_qlib_qlib.lde.hamiltonian_simulation.py",
  "hybrid": true,
  "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Sep 13 09:56:25 2022\n\n@author: archer\n\"\"\"\nimport matplotlib.pyplot as plt\nfrom qiskit.opflow import X, Y, Z, I, PauliTrotterEvolution\nfrom qiskit.circuit import Parameter, QuantumCircuit, QuantumRegister\nfrom qiskit.quantum_info.operators import Operator\nimport numpy as np \nfrom qiskit.opflow.primitive_ops import PrimitiveOp, PauliSumOp\nfrom qiskit.extensions import HamiltonianGate\nfrom qiskit import Aer, execute\nfrom scipy.linalg import expm\n\n\nrandom = np.array([[1, 0], \n                   [2, -1]], dtype=complex)\n\nskew = np.array([[0, 0],\n                 [1, 0]], dtype=complex)\n\nmatrix = 1j*(np.kron(skew, random) + -np.kron(skew.T.conjugate(), random.T.conjugate()))\n\n\nhamiltonian = PrimitiveOp(Operator(data=matrix))\n\n# hamiltonian = 3*(X^X^Z) - 1*(Z^X^Z)\nevo_time = Parameter('t')\nevolution_op = (evo_time*hamiltonian).exp_i()\nprint(evolution_op)\n# into circuit\nnum_time_slices = 3\ntrotterized_op = PauliTrotterEvolution(\n                    trotter_mode='trotter',\n                    reps=num_time_slices).convert(evolution_op)\n\n\n\n# fig, ax = plt.subplots()\n# trotterized_op.to_circuit().bind_parameters({evo_time:2}).decompose(reps=1).draw('mpl', ax=ax)\n# plt.show()\n\nqubits = QuantumRegister(2)\nqc = QuantumCircuit(qubits)\nhg = HamiltonianGate(matrix, evo_time)\nqc.append(hg, qubits)\n\n\nfig, ax = plt.subplots()\nqc.draw('mpl', ax=ax)\nplt.show()\n\nbackend = Aer.get_backend('statevector_simulator')\n\nqcs = []\n\ntime = np.linspace(0, 20, 100)\nfor i, t in enumerate(time):\n\n    qcs.append(qc.assign_parameters({evo_time: t}))\n    \nresult = execute(qcs, backend).result()\n\nsolutions = []\nexact = []\nfor i, t in enumerate(time):\n    \n    x = result.get_statevector(i).data.real[2:]\n    solutions.append(x)\n    exact.append( expm(random*t) @ np.array([0, 0])\n   \nsolutions = np.array(solutions)\nplt.plot(time, solutions[:, 0])",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c59c1f7ee332e177c8"
  },
  "id": "1e45e3d8-39a1-4937-9b23-f5c65d810065",
  "language": "Python",
  "extension": "qiskit",
  "author": "qiskit-community",
  "name": "qiskit-research",
  "path": "Python_qiskit_qiskit-community_qiskit-research_qiskit_research.utils.gates.py",
  "hybrid": true,
  "content": "# (C) Copyright IBM 2022.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Gates.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nimport numpy as np\nfrom qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.library import RZXGate, RZGate, U3Gate, XGate\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.qasm import pi\n\n\nclass XpGate(Gate):\n    r\"\"\"The single-qubit Pauli-X gate (:math:`\\sigma_x`), implemented\n    via RX(\\pi).\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Xp gate.\"\"\"\n        super().__init__(\"xp\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate xp a { u3(pi,0,pi) a; }\n        \"\"\"\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, 0, pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Gate inverse.\"\"\"\n        return XmGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix.\"\"\"\n        return np.array([[0, 1], [1, 0]], dtype=dtype)\n\n\nclass XmGate(Gate):\n    r\"\"\"The single-qubit Pauli-X gate (:math:`\\sigma_x`), implemented\n    via RX(-\\pi).\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Xm gate.\"\"\"\n        super().__init__(\"xm\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate xm a { u3(pi,0,pi) a; }\n        \"\"\"\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, 0, pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Gate inverse.\"\"\"\n        return XpGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix\"\"\"\n        return np.array([[0, 1], [1, 0]], dtype=dtype)\n\n\nclass YpGate(Gate):\n    r\"\"\"The single-qubit Pauli-Y gate (:math:`\\sigma_y`), implemented\n    via RY(\\pi).\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Yp gate.\"\"\"\n        super().__init__(\"yp\", 1, [], label=label)\n\n    def _define(self):\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, pi / 2, pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Return inverted Yp gate (:math:`Y{\\dagger} = Y`)\"\"\"\n        return YmGate()  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix.\"\"\"\n        return np.array([[0, -1j], [1j, 0]], dtype=dtype)\n\n\nclass YmGate(Gate):\n    r\"\"\"The single-qubit Pauli-Y gate (:math:`\\sigma_y`), implemented\n    via RY(-\\pi).\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Ym gate.\"\"\"\n        super().__init__(\"ym\", 1, [], label=label)\n\n    def _define(self):\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, pi / 2, pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Return inverted Ym gate (:math:`Y{\\dagger} = Y`)\"\"\"\n        return YpGate()  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix.\"\"\"\n        return np.array([[0, -1j], [1j, 0]], dtype=dtype)\n\n\nclass PiPhiGate(Gate):\n    r\"\"\"\n    Rotated X gate.\n\n    The 180-degree rotation about an axis offset by an angle :math:`\\\\phi` relative\n    to the X-axis in the XY-plane of the Bloch sphere.\n    \"\"\"\n\n    def __init__(\n        self,\n        phi: ParameterValueType,\n        label: Optional[str] = None,\n    ):\n        \"\"\"Create new PiPhi gate.\"\"\"\n        super().__init__(\"pi_phi\", 1, [phi], label=label)\n        self.phi = phi\n\n    def _define(self):\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RZGate(self.phi), [q[0]], []),\n            (XGate(), [q[0]], []),\n            (RZGate(-self.phi), [q[0]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Return inverted PiPhi gate (:math:`\\pi_\\phi{\\dagger}(\\phi) = \\pi_\\phi(-\\phi)`)\"\"\"\n        return PiPhiGate(-self.phi)  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix.\"\"\"\n        return np.cos(self.phi) * np.array([[0, 1], [1, 0]], dtype=dtype) + np.sin(\n            self.phi\n        ) * np.array([[0, -1j], [1j, 0]], dtype=dtype)\n\n\nclass SECRGate(Gate):\n    r\"\"\"The scaled echoed cross resonance gate, as detailed in\n    https://arxiv.org/abs/1603.04821 and\n    https://arxiv.org/abs/2202.12910.\n\n    Definitions are derived by appending an XGate() to q0\n    of an RZXGate.\n    \"\"\"\n\n    def __init__(self, theta: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new SECR gate.\"\"\"\n        super().__init__(\"secr\", 2, [theta], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate secr(theta) a, b { h b; cx a, b; u1(theta) b; cx a, b; h b; x a}\n        \"\"\"\n        theta = self.params[0]\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(RZXGate(theta), [q[0], q[1]], []), (XGate(), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc.append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        r\"\"\"Gate inverse.\"\"\"\n        return SECRGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Gate matrix.\"\"\"\n        half_theta = float(self.params[0]) / 2\n        cos = np.cos(half_theta)\n        isin = 1j * np.sin(half_theta)\n        return np.array(\n            [\n                [0, cos, 0, isin],\n                [cos, 0, -isin, 0],\n                [0, isin, 0, cos],\n                [-isin, 0, cos, 0],\n            ],\n            dtype=dtype,\n        )\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c59c1f7ee332e177f1"
  },
  "id": "6241f511-9034-4a3e-8cbd-87aeb1427c82",
  "language": "Python",
  "extension": "qiskit",
  "author": "qiskit-community",
  "name": "qiskit-research",
  "path": "Python_qiskit_qiskit-community_qiskit-research_test.utils.test_gate_decompositions.py",
  "hybrid": true,
  "content": "# (C) Copyright IBM 2022.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test Pauli twirling.\"\"\"\n\nimport unittest\n\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit.library import RZZGate, XXMinusYYGate, XXPlusYYGate\nfrom qiskit.quantum_info import Operator\nfrom qiskit.transpiler import PassManager\n\nfrom qiskit_research.utils.gates import PiPhiGate\nfrom qiskit_research.utils.gate_decompositions import (\n    ControlledRZZToCX,\n    RZXWeylDecomposition,\n    XXMinusYYtoRZX,\n    XXPlusYYtoRZX,\n)\n\n\nclass TestPasses(unittest.TestCase):\n    \"\"\"Test passes.\"\"\"\n\n    def test_controlled_rzz_to_cx(self):\n        \"\"\"Test controlled RZZGate to CXGate decomposition.\"\"\"\n        rng = np.random.default_rng()\n        theta = rng.uniform(-10, 10)\n        gate = RZZGate(theta).control(1)\n        register = QuantumRegister(3)\n        circuit = QuantumCircuit(register)\n        circuit.append(gate, register)\n        pass_ = ControlledRZZToCX()\n        pass_manager = PassManager([pass_])\n        decomposed = pass_manager.run(circuit)\n        self.assertTrue(Operator(circuit).equiv(Operator(decomposed)))\n\n    def test_xxplusyy_to_rzx(self):\n        \"\"\"Test XXPlusYYGate to RZXGate decomposition.\"\"\"\n        rng = np.random.default_rng()\n        theta = rng.uniform(-10, 10)\n        beta = rng.uniform(-10, 10)\n        gate = XXPlusYYGate(theta, beta)\n        register = QuantumRegister(2)\n        circuit = QuantumCircuit(register)\n        circuit.append(gate, register)\n        pass_ = XXPlusYYtoRZX()\n        pass_manager = PassManager([pass_])\n        decomposed = pass_manager.run(circuit)\n        self.assertTrue(Operator(circuit).equiv(Operator(decomposed)))\n\n    def test_xxminusyy_to_rzx(self):\n        \"\"\"Test XXMinusYYGate to RZXGate decomposition.\"\"\"\n        rng = np.random.default_rng()\n        theta = rng.uniform(-10, 10)\n        beta = rng.uniform(-10, 10)\n        gate = XXMinusYYGate(theta, beta)\n        register = QuantumRegister(2)\n        circuit = QuantumCircuit(register)\n        circuit.append(gate, register)\n        pass_ = XXMinusYYtoRZX()\n        pass_manager = PassManager([pass_])\n        decomposed = pass_manager.run(circuit)\n        self.assertTrue(Operator(circuit).equiv(Operator(decomposed)))\n\n    def test_rzx_weyl_decomposition(self):\n        \"\"\"Test RZXWeylDecomposition.\"\"\"\n\n        qc = QuantumCircuit(3)\n        qc.rxx(np.pi / 3, 0, 1)\n        qc.ryy(np.pi / 5, 1, 2)\n        qc.rzz(np.pi / 7, 2, 0)\n        pm = PassManager(RZXWeylDecomposition())\n        qc_w = pm.run(qc)\n\n        self.assertNotIn(\"rxx\", qc_w.count_ops())\n        self.assertNotIn(\"ryy\", qc_w.count_ops())\n        self.assertNotIn(\"rzz\", qc_w.count_ops())\n        self.assertIn(\"rzx\", qc_w.count_ops())\n        self.assertTrue(np.allclose(Operator(qc), Operator(qc_w), atol=1e-8))\n\n    def test_piphi_definition(self):\n        \"\"\"Test PiPhi Definition and Decomposition\"\"\"\n\n        rng = np.random.default_rng()\n        phi = rng.uniform(-np.pi, np.pi)\n        qc = QuantumCircuit(1)\n        qc.append(PiPhiGate(phi), [0])\n\n        self.assertTrue(Operator(qc).equiv(PiPhiGate(phi).to_matrix()))\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c69c1f7ee332e178ce"
  },
  "id": "7a8056b2-b717-48c0-80ae-6a47cb5b91c9",
  "language": "Python",
  "extension": "qiskit",
  "author": "matt-lourens",
  "name": "hierarqcal",
  "path": "Python_qiskit_matt-lourens_hierarqcal_hierarqcal.qiskit.qiskit_helper.py",
  "hybrid": true,
  "content": "\"\"\"\nHelper functions for qiskit\n\"\"\"\nimport numpy as np\nimport sympy as sp\nfrom hierarqcal.core import Primitive_Types\nfrom .qiskit_circuits import U2, V2\nimport warnings\nfrom qiskit.circuit import Parameter, QuantumCircuit, QuantumRegister\n\n\ndef get_qiskit_default_unitary(layer):\n    if layer.type in [\n        Primitive_Types.CYCLE,\n        Primitive_Types.PERMUTE,\n        Primitive_Types.PIVOT,\n    ]:\n        unitary_function = U2\n    elif layer.type in [Primitive_Types.MASK]:\n        unitary_function = V2\n    else:\n        warnings.warn(\n            f\"No default function mapping for primitive type: {layer.type}, please provide a mapping manually\"\n        )\n    # Give all edge mappings correct default unitary\n    return unitary_function\n\n\ndef get_circuit_qiskit(hierq, symbols=None, barriers=True):\n    \"\"\"\n    The main helper function for qiskit, it takes a qcnn(:py:class:`hierarqcal.core.Qcnn`) object that describes the cicruit architecture\n    and builds a qiskit.QuantumCircuit object with the correct function mappings and symbols.\n\n    If the qubits are provided as ints then the qubit will be named :code:`\"q0\"` and :code:`\"q1\"`, otherwise the qubits are assumed to be strings.\n\n    Args:\n        qcnn (hierarqcal.core.Qcnn): Qcnn object that describes the circuit architecture, consists of a sequence of motifs (hierarqcal.Qmotif)\n\n    Returns:\n        (tuple): Tuple containing:\n            * circuit (qiskit.QuantumCircuit): QuantumCircuit object\n            * symbols (tuple(Parameter)): Tuple of symbols (rotation angles) as a Qiskit Parameter object.\n    \"\"\"\n    circuit = QuantumCircuit()\n    new_bitnames = []\n    for q in hierq.tail.Q:\n        if type(q) == int:\n            # If bits were provided as ints then the qubit will be named \"q0\" and \"q1\"\n            circuit.add_register(QuantumRegister(1, f\"q{q}\"))\n            new_bitnames.append(f\"q{q}\")\n        else:\n            # Assume bits are strings and in the correct QASM format\n            circuit.add_register(QuantumRegister(1, q))\n    if len(new_bitnames) > 0:\n        hierq.update_Q(new_bitnames)\n    if not (symbols is None):\n        # If symbols were provided then set them\n        hierq.set_symbols(symbols)\n    else:\n        if any([isinstance(symbol, sp.Symbol) for symbol in hierq.get_symbols()]):\n            # If symbols are still symbolic, then convert to qiskit Parameter\n            hierq.set_symbols([Parameter(symbol.name) if isinstance(symbol, sp.Symbol) else symbol for symbol in hierq.get_symbols()])\n\n    for layer in hierq:\n        # If layer is default mapping we need to set it to qiskit default\n        if layer.is_default_mapping:\n            qiskit_default_unitary = get_qiskit_default_unitary(layer)\n            layer.set_edge_mapping(qiskit_default_unitary)\n        for unitary in layer.edge_mapping:\n\n            # If Qunitary.function is a string, we update the function to a Qiskit function\n            # based on the provided string\n            if isinstance(unitary.function, str):\n                unitary = get_qiskit_circuit_from_instructions(unitary)\n\n            circuit = unitary.function(\n                bits=unitary.edge, symbols=unitary.symbols, \n                circuit=circuit, get_circuit_from_string=get_qiskit_circuit_from_instructions\n            )\n        if barriers and layer.next:\n            # Add barrier between layers, except the last one.\n            circuit.barrier()\n    return circuit\n\n\ndef get_qiskit_circuit_from_instructions(qunitary):\n    \"\"\" Takes `qunitary` whose `function` attribute is a string, converts the string into a function,\n        and returns the updated `qunitary` class.\n\n        Args: \n            `qunitary (hierarcqal.core.Qunitary)`\n        Returns: \n            `qunitary (hierarcqal.core.Qunitary)`\n        \"\"\"\n\n    # breaking down the qunitary.function string into a list of gate instructions\n    instruction_list = qunitary.circuit_instructions\n\n    # building a function from the list of gate instructions\n    def circuit_fn(bits, symbols=None, circuit=None, **kwargs):\n        qubits = [QuantumRegister(1, bits[i]) for i in range(qunitary.arity)]\n\n        # for each gate in the instruction list\n        s_indx = 0\n        for circ_instruction in instruction_list:\n\n            gate_name = circ_instruction.gate_name\n            symbol_info = circ_instruction.symbol_info\n            sub_bits = circ_instruction.sub_bits\n            [n_symbols, param_ind, isinlist] = symbol_info\n\n            # apply a gate \n            gate = getattr(circuit, gate_name)\n            if n_symbols == 0:\n                gate(*(qubits[i] for i in sub_bits))\n            else:\n                qub_list = (qubits[i] for i in sub_bits)\n                if isinlist:\n                    gate(*symbols[param_ind:param_ind+1], *qub_list)\n                else:\n                    sym_list = symbols[s_indx:s_indx+n_symbols]\n                    gate(*sym_list,*qub_list)\n            \n            if not isinlist:\n                s_indx += n_symbols\n        return circuit\n    \n    qunitary.function = circuit_fn\n    return qunitary",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c79c1f7ee332e17a61"
  },
  "id": "13aec1a9-f056-4028-b4cf-dadf04795291",
  "language": "Python",
  "extension": "qiskit",
  "author": "DaisukeIto-ynu",
  "name": "KosakaQ",
  "path": "Python_qiskit_DaisukeIto-ynu_KosakaQ_test.py",
  "hybrid": true,
  "content": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep  2 14:04:25 2022\n\n@author: daisu\n\"\"\"\n\n# 必要なモジュールのimport\nfrom qiskit import IBMQ, QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom qiskit import execute, Aer\nimport sys\nsys.path.append(\".\")\nfrom KosakaQbackend import KosakaQbackend\nfrom qiskit.qasm import pi\nfrom qiskit.tools.visualization import plot_histogram, circuit_drawer\nimport numpy as np\nimport time\n\nbackend = KosakaQbackend(\"rabi\")\n\n\n# 量子レジスタqを生成する。\nq = QuantumRegister(1)\n\n# 古典レジスタcを生成する\nc = ClassicalRegister(1)\n\n# 量子レジスタqを生成する。\nq2 = QuantumRegister(1)\n\n# 古典レジスタcを生成する\nc2 = ClassicalRegister(1)\n\n# 量子レジスタqを生成する。\nq3 = QuantumRegister(1)\n\n# 古典レジスタcを生成する\nc3 = ClassicalRegister(1)\n\n\n# 量子レジスタqと古典レジスタc間で量子回路を生成する。\nqc = QuantumCircuit(q, c)\nqc.i(q[0])\njob = backend.run(qc)\n\n# qc2 = QuantumCircuit(q2, c2)\n# qc3 = QuantumCircuit(q3, c3)\n\n# # 1番目の量子ビットにxゲートをかける。\n# qc.h(q[0])\n# qc.z(q[0])\n# qc.h(q[0])\n\n# qc2.h(q2[0])\n# qc2.z(q2[0])\n# qc2.h(q2[0])\n# qc2.x(q2[0])\n\n# qc3.sx(q3[0])\n# qc3.s(q3[0])\n# qc3.y(q3[0])\n# qc3.s(q3[0])\n# qc3.sx(q3[0])\n\n\n# # 1番目の量子ビットの測定値を1番目の古典ビットに、2番目の量子ビットの測定値を2番目の古典ビットに渡す。\n# qc.measure(q[0], c[0])\n# qc2.measure(q2[0], c2[0])\n# qc3.measure(q3[0], c3[0])\n\n\n# # バックエンドで回路をshots回実行させ、測定結果を返させる\n# job = []\n# for i in range(2):\n#     job.append(backend.run(qc))\n#     job.append(backend.run(qc2))\n#     job.append(backend.run(qc3))\n\n# jobの監視\n# from qiskit.tools.monitor import job_monitor\n# job_monitor(job)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17b6b"
  },
  "id": "38e7934d-d7cf-4fd5-a1cc-115e7efb0d71",
  "language": "Python",
  "extension": "qiskit",
  "author": "DaisukeIto-ynu",
  "name": "KosakaQ_client",
  "path": "Python_qiskit_DaisukeIto-ynu_KosakaQ_client_kosakaq_provider.py",
  "hybrid": true,
  "content": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Nov 17 15:00:00 2022\n\n@author: Yokohama National University, Kosaka Lab\n\"\"\"\n\nimport requests\nfrom qiskit.providers import ProviderV1 as Provider #抽象クラスのインポート\nfrom qiskit.providers.exceptions import QiskitBackendNotFoundError #エラー用のクラスをインポート\nfrom exceptions import KosakaQTokenError, KosakaQBackendJobIdError, KosakaQBackendFilterError #エラー用のクラス（自作）をインポート\nfrom kosakaq_backend import KosakaQBackend \nfrom kosakaq_job import KosakaQJob\nfrom qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\nclass KosakaQProvider(Provider): #抽象クラスからの継承としてproviderクラスを作る\n\n    def __init__(self, access_token=None):#引数はself(必須)とtoken(認証が必要な場合)、ユーザーに自分でコピペしてもらう\n        super().__init__() #ソースコードは（）空なので真似した\n        self.access_token = access_token #トークン定義  \n        self.name = 'kosakaq_provider' #nameという変数を右辺に初期化、このproviderクラスの名づけ\n        self.url = 'http://192.168.1.82' #リンク変更可能\n        self.wjson = '/api/backends.json' #jsonに何を入れてサーバーに送るか\n        self.jobson = '/job/'\n    \n    \n    def backends(self, name=None, **kwargs):#API(サーバー)に今使えるbackendを聞く(Rabiが使えるとかunicornが使えるとかをreturn[使えるもの]で教えてくれる)\n        \"\"\"指定したフィルタリングと合うバックエンドたちを返すメソッド\n        引数:\n            name (str): バックエンドの名前(Rabiやunicorn).\n            **kwargs: フィルタリングに使用される辞書型\n        戻り値:\n            list[Backend]:　フィルタリング基準に合うバックエンドたちのリスト\n        \"\"\"\n        self._backend = [] #availableなバックエンドクラスのbkednameを入れていくためのリスト\n        res = requests.get(self.url + self.wjson, headers={\"Authorization\": \"Token \" + self.access_token})\n        response = res.json() #[{'id': 1, 'bkedid': 0, 'bkedname': 'Rabi', 'bkedstatus': 'unavailable','detail': 'Authentication credentials were not provided',...}, {'id': 2, 'bkedid': 1, 'bkedname': 'Unicorn', 'bkedstatus': 'available'}]\n        if 'detail' in response[0]: #トークンが違ったらdetailの辞書一つだけがresponseのリストに入っていることになる\n            raise KosakaQTokenError('access_token was wrong') #トークン間違いを警告\n        for i in range(len(response)):\n            if response[i]['bkedstatus'] =='available':\n                if name == None:\n                    self._backend.append(KosakaQBackend(self, response[i]['bkedname'], self.url, response[i]['bkedversion'], response[i]['bkednqubits'], 4096, 1))\n                elif name == response[i]['bkedname']:\n                    self._backend.append(KosakaQBackend(self, response[i]['bkedname'], self.url, response[i]['bkedversion'], response[i]['bkednqubits'], 4096, 1))  \n                else:\n                    pass\n        return self._backend#responseのstatusがavailableかつフィルタリングにあうバックエンドたちのバックエンドクラスのインスタンスリストを返す\n \n    \n    def get_backend(self, name=None, **kwargs): #ユーザーに\"Rabi\"などを引数として入れてもらう、もしbackendsメソッドのreturnにRabiがあればインスタンスを作れる\n        \"\"\"指定されたフィルタリングに合うバックエンドを一つだけ返す(一つ下のメソッドbackendsの一つ目を取り出す)\n       引数:\n           name (str): バックエンドの名前\n           **kwargs: フィルタリングに使用される辞書型\n       戻り値:\n           Backend: 指定されたフィルタリングに合うバックエンド\n       Raises:\n           QiskitBackendNotFoundError: バックエンドが見つからなかった場合、もしくは複数のバックエンドがフィルタリングに合う場合、もしくは一つもフィルタリング条件に合わない場合\n       \"\"\"\n        backends = self.backends(name, **kwargs) #backendsという変数にbackendsメソッドのreturnのリストを代入\n        if len(backends) > 1:\n            raise QiskitBackendNotFoundError('More than one backend matches criteria')\n        if not backends:\n            raise QiskitBackendNotFoundError('No backend matches criteria.')\n\n        return backends[0]\n\n\n    def retrieve_job(self, job_id: str):#jobidを文字列として代入してもらう（指定してもらう）,対応するJobを返す\n        \"\"\"このバックエンドに投入されたjobを一つだけ返す\n        引数:\n            job_id: 取得したいjobのID\n        戻り値:\n            与えられたIDのjob\n        Raises:\n            KosakaQBackendJobIdError: もしjobの取得に失敗した場合、ID間違いのせいにする\n        \"\"\"\n        res = requests.get(self.url + self.jobson, headers={\"Authorization\": \"Token \" + self.access_token}, params={\"jobid\": job_id})\n        response = res.json()#辞書型{bkedlist,jobist,qobjlist}\n        print(response)\n        if response['joblist'][0]['jobid'] == job_id:\n            for i in range(len(response['bkedlist'])):\n                if response['bkedlist'][i]['bkedid'] == response['joblist'][0]['bkedid']:\n                    bkedname = response['bkedlist'][i]['bkedname']\n            backend = KosakaQBackend(self, bkedname, self.url, response['bkedlist'][i]['bkedversion'], response['bkedlist'][i]['bkednqubits'], 4096, 1)  \n            #量子レジスタqを生成する。\n            q = QuantumRegister(1)\n            #古典レジスタcを生成する\n            c = ClassicalRegister(2)\n            qc = QuantumCircuit(q, c)\n            string = response['qobjlist'][0][0]['gates']\n            gateslist = eval(string) #gatelist=[\"H\",\"X\"]\n            for gate_name in gateslist:\n                if gate_name == \"I\":\n                    qc.i(q[0])\n                elif gate_name == \"X\":\n                    qc.x(q[0])\n                elif gate_name == \"Y\":\n                    qc.y(q[0])\n                elif gate_name == \"Z\":\n                    qc.z(q[0])\n                elif gate_name == \"H\":\n                    qc.h(q[0])\n                elif gate_name == \"S\":\n                    qc.s(q[0])\n                elif gate_name == \"SDG\":\n                    qc.sdg(q[0])\n                elif gate_name == \"SX\":\n                    qc.sx(q[0])\n                elif gate_name == \"SXDG\":\n                    qc.sxdg(q[0])\n                else:\n                    pass\n                \n            return KosakaQJob(backend, response['joblist'][0]['jobid'], self.access_token, qc)\n        else:\n            raise KosakaQBackendJobIdError('Job_id was wrong')\n     \n\n    def jobs(self,\n            limit: int = 10,\n            skip: int = 0,\n            jobstatus = None,\n            jobid = None,\n            begtime = None,\n            bkedid = None,\n            fintime = None,\n            job_num = None,\n            note = None,\n            posttime = None,\n            qobjid = None,\n            userid = None\n    ): #list[KosakaQJob]を返す\n        \"\"\"このバックエンドに送信されたjobのうち指定したフィルタに合うものを取得して、返す\n        引数:\n            limit: 取得するjobの上限数\n            skip: jobを飛ばしながら参照\n            jobstatus: このステータスを持つjobのみを取得する。\n                    指定方法の例 `status=JobStatus.RUNNING` or `status=\"RUNNING\"`\n                    or `status=[\"RUNNING\", \"ERROR\"]`\n            jobid: jobの名前でのフィルタリング用。 job名は部分的にマッチする、そして\n                    `regular expressions(正規表現)\n               <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions>`_\n               が使われる。\n            begtime: 指定された開始日（現地時間）でのフィルター用。これは作成日がこの指定した現地時間より後のjobを探すのに使われる。\n            fintime: 指定された終了日（現地時間）でのフィルター用。 これは作成日がこの指定された現地時間よりも前に作られたjobを見つけるために使われる。\n            job_num: jobの番号\n            note: メモ\n            posttime: 投稿時間\n            qobjid: qobjのID\n            userid: ユーザーID\n  \n        戻り値:\n           条件に合うjobのリスト\n        Raises:\n           KosakaQBackendFilterError: キーワード値が認識されない場合 (でも、メソッド内で使われてない)\n        \"\"\"\n        jobs_list = [] #返す用のリスト\n        res = requests.get(self.url + self.jobson, headers={\"Authorization\": \"Token \" + self.access_token})\n        response = res.json()#辞書型{bkedlist(ラビ、ユニコーン),jobist(jobnumがjobの数だけ),qobjlist(qobjnumがqobjの数だけ、ゲートもたくさん)}\n        print(response)\n        for i in range(len(response['joblist'])):\n            if response['joblist'][i]['begtime'] == begtime or response['joblist'][i]['begtime'] == None :\n                if response['joblist'][i]['bkedid'] == bkedid or response['joblist'][i]['bkedid'] == None:\n                    if response['joblist'][i]['fintime'] == fintime or response['joblist'][i]['fintime'] == None:\n                        if response['joblist'][i]['job_num'] == job_num or response['joblist'][i]['job_num'] == None:\n                            if response['joblist'][i]['jobid'] == jobid or response['joblist'][i]['jobid'] == None:\n                                if response['joblist'][i]['jobstatus'] == jobstatus or response['joblist'][i]['jobstatus'] == None:\n                                    if response['joblist'][i]['note'] == note or response['joblist'][i]['note'] == None:\n                                        if response['joblist'][i]['posttime'] == posttime or response['joblist'][i]['posttime'] == None:\n                                            if response['joblist'][i]['qobjid'] == qobjid or response['joblist'][i]['qobjid'] == None:\n                                                if response['joblist'][i]['userid'] == userid or response['joblist'][i]['userid'] == None:\n                                                    bked_id = response['joblist'][i]['bkedid']#代入用bkedid\n                                                    bked_posi =bked_id-1 #代入用バックエンド番号\n                                                    backend = KosakaQBackend(self, response['bkedlist'][bked_posi]['bkedname'], self.url, response['bkedlist'][bked_posi]['bkedversion'], response['bkedlist'][bked_posi]['bkednqubits'], 4096, 1)\n                                                    #量子レジスタqを生成する。\n                                                    q = QuantumRegister(1)\n                                                    #古典レジスタcを生成する\n                                                    c = ClassicalRegister(2)\n                                                    qc = QuantumCircuit(q, c)\n                                                    string = response['qobjlist'][i]['gates']\n                                                    gateslist = eval(string) #gatelist=[\"H\",\"X\"]\n                                                    for gate_name in gateslist:\n                                                        if gate_name == \"I\":\n                                                            qc.i(q[0])\n                                                        elif gate_name == \"X\":\n                                                            qc.x(q[0])\n                                                        elif gate_name == \"Y\":\n                                                            qc.y(q[0])\n                                                        elif gate_name == \"Z\":\n                                                            qc.z(q[0])\n                                                        elif gate_name == \"H\":\n                                                            qc.h(q[0])\n                                                        elif gate_name == \"S\":\n                                                            qc.s(q[0])\n                                                        elif gate_name == \"SDG\":\n                                                            qc.sdg(q[0])\n                                                        elif gate_name == \"SX\":\n                                                            qc.sx(q[0])\n                                                        elif gate_name == \"SXDG\":\n                                                            qc.sxdg(q[0])\n                                                        else:\n                                                            pass\n                                                    jobs_list.insert(i, KosakaQJob(backend, response['joblist'][i]['jobid'], self.access_token, qc))\n        if len(jobs_list) == 0:\n            raise KosakaQBackendFilterError('Filter was Error')\n        return jobs_list\n                \n \n    def __eq__(self, other): #等号の定義\n        \"\"\"Equality comparison.\n        By default, it is assumed that two `Providers` from the same class are\n        equal. Subclassed providers can override this behavior.\n        \"\"\"\n        return type(self).__name__ == type(other).__name__\n\n\n",
  "circuit": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 752,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"Y\", \"Z\", \"H\", \"S\"]]"
        },
        "timestamp": "2023-11-26T22:33:48.944+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[\"X\", \"Y\", \"Z\"]]"
        }
      }
    ],
    "superposition": [
      {
        "id": 1,
        "position": {
          "qubit": 0,
          "column": 3,
          "fragment": "[[\"_\", \"_\", \"_\", \"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17b70"
  },
  "id": "19793368-0dc7-459a-95e2-7438e12d539a",
  "language": "Python",
  "extension": "qiskit",
  "author": "DaisukeIto-ynu",
  "name": "KosakaQ_client",
  "path": "Python_qiskit_DaisukeIto-ynu_KosakaQ_client_test.py",
  "hybrid": false,
  "content": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Dec  1 14:52:05 2022\n\n@author: Daisuke Ito\n\"\"\"\n\nfrom kosakaq_provider import *\nfrom qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\nprovider = KosakaQProvider(\"8c8795d3fee73e69271bc8c9fc2e0c12e73e5879\")\nprint(provider.backends(),\"\\n\")\n# backend = provider.get_backend(\"Rabi\")\nbackend = provider.backends()[0]\nprint(backend.name,\"\\n\")\n\n#量子レジスタqを生成する。\nq = QuantumRegister(1)\n\n#古典レジスタcを生成する\nc = ClassicalRegister(1)\n\n#量子レジスタqと古典レジスタc間で量子回路を生成する。\nqc = QuantumCircuit(q, c)\n#1番目の量子ビットにHゲートをかける。\nqc.i(q[0])\n#1番目の量子ビットにXゲートをかける。\n# qc.x(q[0])\n\n#1番目の量子ビットの測定値を1番目の古典ビットに渡す。\nqc.measure(q[0], c[0])\n\nqc.draw()\n\njob = backend.run(qc)\n\nprint(job.get_counts(qc))",
  "circuit": "[[\"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 753,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:33:52.854+00:00"
      },
      "value": 1
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17c0c"
  },
  "id": "75bc11cd-8cff-4ac1-a146-0e83e1ae6a5c",
  "language": "Python",
  "extension": "qiskit",
  "author": "jdanielescanez",
  "name": "quantum-solver",
  "path": "Python_qiskit_jdanielescanez_quantum-solver_src.crypto.e91.eavesdropper.py",
  "hybrid": true,
  "content": "#!/usr/bin/env python3\n\n# Author: Daniel Escanez-Exposito\n\nfrom crypto.e91.receiver import Receiver\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom numpy.random import uniform\n\n## The Eveasdropper entity in the E91 implementation\n## @see https://qiskit.org/textbook/ch-algorithms/quantum-key-distribution.html\nclass Eveasdropper(Receiver):\n  ## Constructor\n  def __init__(self, name='', original_bits_size=0, qr=QuantumRegister(2, name=\"qr\"), cr=ClassicalRegister(4, name=\"cr\")):\n    super().__init__(name, original_bits_size, qr, cr)\n\n    ## Chosen measurements setter\n  def set_axes(self, axes=None, density=0.0):\n    self._calculate_measurements()\n    if axes == None:\n      self.axes = []\n      for _ in range(self.original_bits_size):\n        if uniform(0, 1) <= density:\n          if uniform(0, 1) <= 0.5: # in 50% of cases perform the WW measurement\n            self.axes.append(['ea2', 'eb1'])\n          else: # in 50% of cases perform the ZZ measurement\n            self.axes.append(['ea3', 'eb2'])\n        else:\n          self.axes.append(None)\n    else:\n      self.axes = axes\n\n  def _calculate_measurements(self):\n    self.measurements = {}\n    qr = self.qr\n    cr = self.cr\n    # Measurement of the spin projection of Alice's qubit onto the a_2 direction (W basis)\n    self.measurements['ea2'] = QuantumCircuit(qr, cr, name='measureEA2')\n    self.measurements['ea2'].s(qr[0])\n    self.measurements['ea2'].h(qr[0])\n    self.measurements['ea2'].t(qr[0])\n    self.measurements['ea2'].h(qr[0])\n    self.measurements['ea2'].measure(qr[0], cr[2])\n\n    # Measurement of the spin projection of Allice's qubit onto the a_3 direction (standard Z basis)\n    self.measurements['ea3'] = QuantumCircuit(qr, cr, name='measureEA3')\n    self.measurements['ea3'].measure(qr[0], cr[2])\n\n    # Measurement of the spin projection of Bob's qubit onto the b_1 direction (W basis)\n    self.measurements['eb1'] = QuantumCircuit(qr, cr, name='measureEB1')\n    self.measurements['eb1'].s(qr[1])\n    self.measurements['eb1'].h(qr[1])\n    self.measurements['eb1'].t(qr[1])\n    self.measurements['eb1'].h(qr[1])\n    self.measurements['eb1'].measure(qr[1], cr[3])\n\n    # Measurement of the spin projection of Bob's qubit onto the b_2 direction (standard Z measurement)\n    self.measurements['eb2'] = QuantumCircuit(qr, cr, name='measureEB2')\n    self.measurements['eb2'].measure(qr[1], cr[3])\n\n  # Create the key with the circuit measurement results\n  def create_values(self, result, circuits):\n    for i in range(self.original_bits_size):\n      if self.axes[i] != None:\n        res = list(result.get_counts(circuits[i]).keys())[0]\n        self.values.append([int(res[0]), int(res[1])])\n      else:\n        self.values.append([None, None])\n",
  "circuit": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 12
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 12
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 754,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:36:58.988+00:00"
      },
      "value": 1
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"_\", \"H\"], [\"_\", \"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17c33"
  },
  "id": "568c1192-373c-49b8-ae9d-a6add0f39dfc",
  "language": "Python",
  "extension": "qiskit",
  "author": "jdanielescanez",
  "name": "quantum-solver",
  "path": "Python_qiskit_jdanielescanez_quantum-solver_src.crypto.e91.receiver.py",
  "hybrid": true,
  "content": "#!/usr/bin/env python3\n\n# Author: Daniel Escanez-Exposito\n\nfrom crypto.e91.participant import Participant\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom numpy.random import rand\n\n## The Receiver entity in the E91 implementation\n## @see https://qiskit.org/textbook/ch-algorithms/quantum-key-distribution.html\nclass Receiver(Participant):\n  ## Constructor\n  def __init__(self, name='', original_bits_size=0, qr=QuantumRegister(2, name=\"qr\"), cr=ClassicalRegister(4, name=\"cr\")):\n    super().__init__(name, original_bits_size, qr, cr)\n\n  def _calculate_measurements(self):\n    self.measurements = {}\n    qr = self.qr\n    cr = self.cr\n    # Measure the spin projection of Bob's qubit onto the b_1 direction (W basis)\n    self.measurements['b1'] = QuantumCircuit(qr, cr, name='measureB1')\n    self.measurements['b1'].s(qr[1])\n    self.measurements['b1'].h(qr[1])\n    self.measurements['b1'].t(qr[1])\n    self.measurements['b1'].h(qr[1])\n    self.measurements['b1'].measure(qr[1], cr[1])\n\n    # Measure the spin projection of Bob's qubit onto the b_2 direction (standard Z basis)\n    self.measurements['b2'] = QuantumCircuit(qr, cr, name='measureB2')\n    self.measurements['b2'].measure(qr[1], cr[1])\n\n    # Measure the spin projection of Bob's qubit onto the b_3 direction (V basis)\n    self.measurements['b3'] = QuantumCircuit(qr, cr, name='measureB3')\n    self.measurements['b3'].s(qr[1])\n    self.measurements['b3'].h(qr[1])\n    self.measurements['b3'].tdg(qr[1])\n    self.measurements['b3'].h(qr[1])\n    self.measurements['b3'].measure(qr[1], cr[1])\n\n  # Create the key with the circuit measurement results\n  def create_values(self, result, circuits):\n    for i in range(self.original_bits_size):\n      res = list(result.get_counts(circuits[i]).keys())[0]\n      self.values.append(int(res[-1]))\n",
  "circuit": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 10
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 10
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 10
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 755,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"S\", \"H\", \"T\", \"H\", \"MEASURE\", \"MEASURE\", \"S\", \"H\", \"H\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T22:37:31.773+00:00"
      },
      "value": 0.5
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17c41"
  },
  "id": "25689fc2-e4bb-4dd0-8702-c6c2f21dda01",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.8.fixed_8.py",
  "hybrid": false,
  "content": "from qiskit import *\nfrom math import pi\nimport numpy as np\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nfrom qiskit.quantum_info.operators import Operator\n\ncirc = QuantumCircuit(3)\ncirc.crz(pi/2,0,1)\ncirc.crz(pi/4,0,2)\nU = Operator(circ)\n\nqae = QuantumRegister(2,'qae')\nreg_b = QuantumRegister(2,'b')\nqc = QuantumCircuit(qae,reg_b)\nqc.append(U,[qae[0],reg_b[0],reg_b[1]])\nuni = Operator(qc)\nprint(np.round(uni.data,1))\nqc.draw('mpl')\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c89c1f7ee332e17c4a"
  },
  "id": "c23784b8-d892-4ab6-b75d-444b81b19cb9",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.23.buggy_23.py",
  "hybrid": false,
  "content": "from qiskit import *\n\nqr = QuantumRegister(2)\ncr = ClassicalRegister(2)\n\nQc = QuantumCircuit(qr,cr)\n\nprint ('This is the initial state')\nprint(Qc.draw(output = 'mpl'))\nprint ('')\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c6a"
  },
  "id": "d31448d0-1bfa-4b15-9824-c375e898985a",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.16.fixed_16.py",
  "hybrid": false,
  "content": "from qiskit import *\n\nqr = QuantumRegister(5,'qr')\ncr = ClassicalRegister(5, 'cr')\nghz = QuantumCircuit(qr, cr)\n\nghz.h(qr[0])\nghz.cx(qr[0],qr[1])\nghz.cx(qr[1],qr[2])\nghz.cx(qr[2],qr[3])\nghz.cx(qr[3],qr[4])\nghz.barrier(qr)\nghz.draw()\n\nsim_backend = BasicAer.get_backend('statevector_simulator')\nsim_result = execute(ghz, sim_backend).result()\nprint(sim_result.get_statevector(0))\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0.2
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0.8
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0.2
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 760,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:38:34.179+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"], [], [], []]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c85"
  },
  "id": "22f15d7f-a77e-468b-82bf-8c3354a7c624",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.8.buggy_8.py",
  "hybrid": false,
  "content": "from qiskit import *\nfrom math import pi\nimport numpy as np\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nfrom qiskit.quantum_info.operators import Operator\n\ncirc = QuantumCircuit(3)\ncirc.crz(pi/2,2,0)\ncirc.crz(pi/4,2,1)\nU = Operator(circ)\n\nqae = QuantumRegister(2,'qae')\nreg_b = QuantumRegister(2,'b')\nqc = QuantumCircuit(qae,reg_b)\nqc.append(U,[qae[0],reg_b[0],reg_b[1]])\nuni = Operator(qc)\nprint(np.round(uni.data,1))\nqc.draw('mpl')\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c89"
  },
  "id": "c5289f94-097d-4efd-9fdb-6829d6462256",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.23.fixed_23.py",
  "hybrid": false,
  "content": "from qiskit import *\n\nqr = QuantumRegister(2)\ncr = ClassicalRegister(2)\n\nQc = QuantumCircuit(qr,cr)\n\nprint ('This is the initial state')\nQc.draw('mpl').show()\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c8f"
  },
  "id": "86a088bd-ca95-4fce-a80a-b5ce5f4c7470",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.24.buggy_24.py",
  "hybrid": false,
  "content": "import qiskit\nfrom qiskit import *\nfrom qiskit import IBMQ\nqr = QuantumRegister(2)\ncr = ClassicalRegister(2)\ncircuit = QuantumCircuit(qr, cr)\n#%matplotlib inline\ncircuit.draw(output='mpl')\ncircuit.h(qr(0))\n",
  "circuit": "[[\"H\"], []]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 763,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:04.644+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c9a"
  },
  "id": "11208961-9a0d-45af-81c7-f019f36a5dec",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.8.test_b8.py",
  "hybrid": true,
  "content": "from qiskit import *\nfrom math import pi\nimport numpy as np\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nfrom qiskit.quantum_info.operators import Operator\nimport unittest\n\nclass Test(unittest.TestCase):\n    def test_b8(self):\n        circ = QuantumCircuit(3)\n        circ.crz(pi/2,2,0)\n        circ.crz(pi/4,2,1)\n        U = Operator(circ)\n\n        qae = QuantumRegister(2,'qae')\n        reg_b = QuantumRegister(2,'b')\n        qc = QuantumCircuit(qae,reg_b)\n        qc.append(U,[qae[0],reg_b[0],reg_b[1]])\n        uni = Operator(qc)\n        print(np.round(uni.data,1))\n        qc.draw('mpl')\n        self.assertEqual(str(np.round(uni.data,1)),'[[1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0.4-0.9j 0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0.4-0.9j 0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.9+0.4j 0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.9+0.4j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0.9-0.4j 0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0.9-0.4j 0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.4+0.9j 0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.4+0.9j]]')\n        self.assertEqual(str(qc),'       ┌──────────┐\\nqae_0: ┤0         ├\\n       │          │\\nqae_1: ┤          ├\\n       │  Unitary │\\n  b_0: ┤1         ├\\n       │          │\\n  b_1: ┤2         ├\\n       └──────────┘')\n\n\nif __name__ == '__main__':\n    unittest.main(argv=[''])\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17c9f"
  },
  "id": "bb4fb5a5-ad71-4c2a-ac88-0623781f776e",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.16.test_f16.py",
  "hybrid": true,
  "content": "import unittest\nfrom qiskit import *\n\nclass Test(unittest.TestCase):\n    def test_f16(self):\n        \n        qr = QuantumRegister(5,'qr')\n        cr = ClassicalRegister(5, 'cr')\n        ghz = QuantumCircuit(qr, cr)\n\n        ghz.h(qr[0])\n        ghz.cx(qr[0],qr[1])\n        ghz.cx(qr[1],qr[2])\n        ghz.cx(qr[2],qr[3])\n        ghz.cx(qr[3],qr[4])\n        ghz.barrier(qr)\n        ghz.draw()\n\n        sim_backend = BasicAer.get_backend('statevector_simulator')\n        sim_result = execute(ghz, sim_backend).result()\n        print(sim_result.get_statevector(0))\n        \n\n        self.assertEqual(str(sim_result.get_statevector(0)),'[0.70710678+0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j\\n 0.        +0.j 0.        +0.j 0.        +0.j 0.70710678+0.j]')\n\n\nif __name__ == '__main__':\n    unittest.main(argv=[''])\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0.2
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0.8
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0.2
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 765,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\", {\"CONTROL\": 2}], [\"_\", \"_\", \"X\", {\"CONTROL\": 3}], [\"_\", \"_\", \"_\", \"X\", {\"CONTROL\": 4}], [\"_\", \"_\", \"_\", \"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:39:22.120+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"], [], [], []]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17cbb"
  },
  "id": "0fc90404-8318-4f86-9d7a-95aa3986ce93",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.24.test_b24.py",
  "hybrid": true,
  "content": "import unittest\nimport qiskit\nfrom qiskit import *\nfrom qiskit import IBMQ\n\nclass Test(unittest.TestCase):\n\tdef test_b24(self):\n\t\tqr = QuantumRegister(2)\n\t\tcr = ClassicalRegister(2)\n\t\tcircuit = QuantumCircuit(qr, cr)\n\t\t#%matplotlib inline\n\t\tcircuit.draw(output='mpl')\n\t\t\n\t\twith self.assertRaises(TypeError):\n\t\t\tcircuit.h(qr(0))\n\nif __name__ == '__main__':\n    unittest.main(argv=[''])\n",
  "circuit": "[[\"H\"], []]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 766,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"], []]"
        },
        "timestamp": "2023-11-26T22:39:41.247+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17cc7"
  },
  "id": "65fa9128-f503-4667-9bd6-f63af08e4a38",
  "language": "Python",
  "extension": "qiskit",
  "author": "Z-928",
  "name": "Bugs4Q-Framework",
  "path": "Python_qiskit_Z-928_Bugs4Q-Framework_qiskit.8.test_f8.py",
  "hybrid": true,
  "content": "from qiskit import *\nfrom math import pi\nimport numpy as np\nfrom qiskit.visualization import plot_bloch_multivector, plot_histogram\nfrom qiskit.quantum_info.operators import Operator\nimport unittest\n\nclass Test(unittest.TestCase):\n    def test_f8(self):\n        circ = QuantumCircuit(3)\n        circ.crz(pi/2,0,1)\n        circ.crz(pi/4,0,2)\n        U = Operator(circ)\n\n        qae = QuantumRegister(2,'qae')\n        reg_b = QuantumRegister(2,'b')\n        qc = QuantumCircuit(qae,reg_b)\n        qc.append(U,[qae[0],reg_b[0],reg_b[1]])\n        uni = Operator(qc)\n        print(np.round(uni.data,1))\n        qc.draw('mpl')\n        self.assertEqual(str(np.round(uni.data,1)),'[[1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0.4-0.9j 0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0.4-0.9j 0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.9+0.4j 0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.9+0.4j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0.9-0.4j 0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0.9-0.4j 0. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j  0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.4+0.9j 0. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  1. +0.j  0. +0.j ]\\n [0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j\\n  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0. +0.j  0.4+0.9j]]')\n        self.assertEqual(str(qc),'       ┌──────────┐\\nqae_0: ┤0         ├\\n       │          │\\nqae_1: ┤          ├\\n       │  Unitary │\\n  b_0: ┤1         ├\\n       │          │\\n  b_1: ┤2         ├\\n       └──────────┘')\n\n\nif __name__ == '__main__':\n    unittest.main(argv=[''])\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17d3b"
  },
  "id": "d930e2b2-8d29-4a7e-be41-ab0ba34ef833",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.r.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around an axis in x-y plane.\"\"\"\n\nimport math\nfrom cmath import exp\nfrom typing import Optional\nimport numpy\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RGate(Gate):\n    r\"\"\"Rotation θ around the cos(φ)x + sin(φ)y axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.r` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌──────┐\n        q_0: ┤ R(ϴ) ├\n             └──────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        R(\\theta, \\phi) = e^{-i \\th \\left(\\cos{\\phi} x + \\sin{\\phi} y\\right)} =\n            \\begin{pmatrix}\n                \\cos{\\th} & -i e^{-i \\phi} \\sin{\\th} \\\\\n                -i e^{i \\phi} \\sin{\\th} & \\cos{\\th}\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self, theta: ParameterValueType, phi: ParameterValueType, label: Optional[str] = None\n    ):\n        \"\"\"Create new r single-qubit gate.\"\"\"\n        super().__init__(\"r\", 1, [theta, phi], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate r(θ, φ) a {u3(θ, φ - π/2, -φ + π/2) a;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        theta = self.params[0]\n        phi = self.params[1]\n        rules = [(U3Gate(theta, phi - pi / 2, -phi + pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Invert this gate.\n\n        r(θ, φ)^dagger = r(-θ, φ)\n        \"\"\"\n        return RGate(-self.params[0], self.params[1])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the R gate.\"\"\"\n        theta, phi = float(self.params[0]), float(self.params[1])\n        cos = math.cos(theta / 2)\n        sin = math.sin(theta / 2)\n        exp_m = exp(-1j * phi)\n        exp_p = exp(1j * phi)\n        return numpy.array([[cos, -1j * exp_m * sin], [-1j * exp_p * sin, cos]], dtype=dtype)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5c99c1f7ee332e17d61"
  },
  "id": "aba4728a-e299-4d14-af32-5cc1cb1c055a",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.rx.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the X axis.\"\"\"\n\nimport math\nfrom typing import Optional, Union\nimport numpy\n\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RXGate(Gate):\n    r\"\"\"Single-qubit rotation about the X axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rx` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Rx(ϴ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        RX(\\theta) = \\exp\\left(-i \\th X\\right) =\n            \\begin{pmatrix}\n                \\cos{\\th}   & -i\\sin{\\th} \\\\\n                -i\\sin{\\th} & \\cos{\\th}\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(self, theta: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new RX gate.\"\"\"\n        super().__init__(\"rx\", 1, [theta], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate rx(theta) a {r(theta, 0) a;}\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .r import RGate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(RGate(self.params[0], 0), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RX gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRXGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RX gate.\n\n        :math:`RX(\\lambda)^{\\dagger} = RX(-\\lambda)`\n        \"\"\"\n        return RXGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RX gate.\"\"\"\n        cos = math.cos(self.params[0] / 2)\n        sin = math.sin(self.params[0] / 2)\n        return numpy.array([[cos, -1j * sin], [-1j * sin, cos]], dtype=dtype)\n\n\nclass CRXGate(ControlledGate):\n    r\"\"\"Controlled-RX gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.crx` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Rx(ϴ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        CRX(\\theta)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RX(\\theta) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & \\cos{\\th} & 0 & -i\\sin{\\th} \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & -i\\sin{\\th} & 0 & \\cos{\\th}\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Rx(ϴ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n            CRX(\\theta)\\ q_1, q_0 =\n            |0\\rangle\\langle0| \\otimes I + |1\\rangle\\langle1| \\otimes RX(\\theta) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & \\cos{\\th}   & -i\\sin{\\th} \\\\\n                    0 & 0 & -i\\sin{\\th} & \\cos{\\th}\n                \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Create new CRX gate.\"\"\"\n        super().__init__(\n            \"crx\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RXGate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cu3(theta,phi,lambda) c, t\n        { u1(pi/2) t;\n          cx c,t;\n          u3(-theta/2,0,0) t;\n          cx c,t;\n          u3(theta/2,-pi/2,0) t;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n        from .u3 import U3Gate\n        from .x import CXGate\n\n        # q_0: ─────────────■───────────────────■────────────────────\n        #      ┌─────────┐┌─┴─┐┌─────────────┐┌─┴─┐┌────────────────┐\n        # q_1: ┤ U1(π/2) ├┤ X ├┤ U3(0/2,0,0) ├┤ X ├┤ U3(0/2,-π/2,0) ├\n        #      └─────────┘└───┘└─────────────┘└───┘└────────────────┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (U1Gate(pi / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U3Gate(-self.params[0] / 2, 0, 0), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (U3Gate(self.params[0] / 2, -pi / 2, 0), [q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRX gate (i.e. with the negative rotation angle).\"\"\"\n        return CRXGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRX gate.\"\"\"\n        half_theta = float(self.params[0]) / 2\n        cos = math.cos(half_theta)\n        isin = 1j * math.sin(half_theta)\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, cos, 0, -isin], [0, 0, 1, 0], [0, -isin, 0, cos]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[cos, 0, -isin, 0], [0, 1, 0, 0], [-isin, 0, cos, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17d92"
  },
  "id": "e046f291-58f0-4988-9843-be6ec6006725",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.transpiler.test_pass_scheduler.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Transpiler testing\"\"\"\n\nimport io\nfrom logging import StreamHandler, getLogger\nimport unittest.mock\nimport sys\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.transpiler import PassManager, TranspilerError\nfrom qiskit.transpiler.runningpassmanager import (\n    DoWhileController,\n    ConditionalController,\n    FlowController,\n)\nfrom qiskit.test import QiskitTestCase\nfrom ._dummy_passes import (\n    PassA_TP_NR_NP,\n    PassB_TP_RA_PA,\n    PassC_TP_RA_PA,\n    PassD_TP_NR_NP,\n    PassE_AP_NR_NP,\n    PassF_reduce_dag_property,\n    PassI_Bad_AP,\n    PassJ_Bad_NoReturn,\n    PassK_check_fixed_point_property,\n    PassM_AP_NR_NP,\n)\n\n\nclass SchedulerTestCase(QiskitTestCase):\n    \"\"\"Asserts for the scheduler.\"\"\"\n\n    def assertScheduler(self, circuit, passmanager, expected):\n        \"\"\"\n        Run `transpile(circuit, passmanager)` and check\n        if the passes run as expected.\n\n        Args:\n            circuit (QuantumCircuit): Circuit to transform via transpilation.\n            passmanager (PassManager): pass manager instance for the transpilation process\n            expected (list): List of things the passes are logging\n        \"\"\"\n        logger = \"LocalLogger\"\n        with self.assertLogs(logger, level=\"INFO\") as cm:\n            out = passmanager.run(circuit)\n        self.assertIsInstance(out, QuantumCircuit)\n        self.assertEqual([record.message for record in cm.records], expected)\n\n    def assertSchedulerRaises(self, circuit, passmanager, expected, exception_type):\n        \"\"\"\n        Run `transpile(circuit, passmanager)` and check\n        if the passes run as expected until exception_type is raised.\n\n        Args:\n            circuit (QuantumCircuit): Circuit to transform via transpilation\n            passmanager (PassManager): pass manager instance for the transpilation process\n            expected (list): List of things the passes are logging\n            exception_type (Exception): Exception that is expected to be raised.\n        \"\"\"\n        logger = \"LocalLogger\"\n        with self.assertLogs(logger, level=\"INFO\") as cm:\n            self.assertRaises(exception_type, passmanager.run, circuit)\n        self.assertEqual([record.message for record in cm.records], expected)\n\n\nclass TestPassManagerInit(SchedulerTestCase):\n    \"\"\"The pass manager sets things at init time.\"\"\"\n\n    def test_passes(self):\n        \"\"\"A single chain of passes, with Requests and Preserves, at __init__ time\"\"\"\n        circuit = QuantumCircuit(QuantumRegister(1))\n        passmanager = PassManager(\n            passes=[\n                PassC_TP_RA_PA(),  # Request: PassA / Preserves: PassA\n                PassB_TP_RA_PA(),  # Request: PassA / Preserves: PassA\n                PassD_TP_NR_NP(argument1=[1, 2]),  # Requires: {}/ Preserves: {}\n                PassB_TP_RA_PA(),\n            ]\n        )\n        self.assertScheduler(\n            circuit,\n            passmanager,\n            [\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassC_TP_RA_PA\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassD_TP_NR_NP\",\n                \"argument [1, 2]\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassB_TP_RA_PA\",\n            ],\n        )\n\n\nclass TestUseCases(SchedulerTestCase):\n    \"\"\"Combine passes in different ways and checks that passes are run\n    in the right order.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n        self.passmanager = PassManager()\n\n    def test_chain(self):\n        \"\"\"A single chain of passes, with Requires and Preserves.\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Requires: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Requires: PassA / Preserves: PassA\n        self.passmanager.append(PassD_TP_NR_NP(argument1=[1, 2]))  # Requires: {}/ Preserves: {}\n        self.passmanager.append(PassB_TP_RA_PA())\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassC_TP_RA_PA\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassD_TP_NR_NP\",\n                \"argument [1, 2]\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassB_TP_RA_PA\",\n            ],\n        )\n\n    def test_conditional_passes_true(self):\n        \"\"\"A pass set with a conditional parameter. The callable is True.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(True))\n        self.passmanager.append(\n            PassA_TP_NR_NP(), condition=lambda property_set: property_set[\"property\"]\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassE_AP_NR_NP\",\n                \"set property as True\",\n                \"run transformation pass PassA_TP_NR_NP\",\n            ],\n        )\n\n    def test_conditional_passes_true_fc(self):\n        \"\"\"A pass set with a conditional parameter (with FlowController). The callable is True.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(True))\n\n        self.passmanager.append(\n            ConditionalController(\n                [PassA_TP_NR_NP()], condition=lambda property_set: property_set[\"property\"]\n            )\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassE_AP_NR_NP\",\n                \"set property as True\",\n                \"run transformation pass PassA_TP_NR_NP\",\n            ],\n        )\n\n    def test_conditional_passes_false(self):\n        \"\"\"A pass set with a conditional parameter. The callable is False.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(False))\n        self.passmanager.append(\n            PassA_TP_NR_NP(), condition=lambda property_set: property_set[\"property\"]\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\"run analysis pass PassE_AP_NR_NP\", \"set property as False\"],\n        )\n\n    def test_conditional_and_loop(self):\n        \"\"\"Run a conditional first, then a loop.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(True))\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            condition=lambda property_set: property_set[\"property\"],\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassE_AP_NR_NP\",\n                \"set property as True\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 8 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 6\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 6 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 5\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 5 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 4\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 4 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 3\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 3 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n            ],\n        )\n\n    def test_loop_and_conditional(self):\n        \"\"\"Run a loop first, then a conditional.\"\"\"\n        FlowController.remove_flow_controller(\"condition\")\n        FlowController.add_flow_controller(\"condition\", ConditionalController)\n\n        self.passmanager.append(PassK_check_fixed_point_property())\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            condition=lambda property_set: not property_set[\"property_fixed_point\"],\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 8 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 6\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 6 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 5\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 5 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 4\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 4 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 3\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 3 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n            ],\n        )\n\n    def test_do_not_repeat_based_on_preservation(self):\n        \"\"\"When a pass is still a valid pass (because the following passes\n        preserved it), it should not run again.\"\"\"\n        self.passmanager.append([PassB_TP_RA_PA(), PassA_TP_NR_NP(), PassB_TP_RA_PA()])\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\"run transformation pass PassA_TP_NR_NP\", \"run transformation pass PassB_TP_RA_PA\"],\n        )\n\n    def test_do_not_repeat_based_on_idempotence(self):\n        \"\"\"Repetition can be optimized to a single execution when\n        the pass is idempotent.\"\"\"\n        self.passmanager.append(PassA_TP_NR_NP())\n        self.passmanager.append([PassA_TP_NR_NP(), PassA_TP_NR_NP()])\n        self.passmanager.append(PassA_TP_NR_NP())\n        self.assertScheduler(\n            self.circuit, self.passmanager, [\"run transformation pass PassA_TP_NR_NP\"]\n        )\n\n    def test_non_idempotent_pass(self):\n        \"\"\"Two or more runs of a non-idempotent pass cannot be optimized.\"\"\"\n        self.passmanager.append(PassF_reduce_dag_property())\n        self.passmanager.append([PassF_reduce_dag_property(), PassF_reduce_dag_property()])\n        self.passmanager.append(PassF_reduce_dag_property())\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 6\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 5\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 4\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 3\",\n            ],\n        )\n\n    def test_fenced_dag(self):\n        \"\"\"Analysis passes are not allowed to modified the DAG.\"\"\"\n        qr = QuantumRegister(2)\n        circ = QuantumCircuit(qr)\n        circ.cx(qr[0], qr[1])\n        circ.cx(qr[0], qr[1])\n        circ.cx(qr[1], qr[0])\n        circ.cx(qr[1], qr[0])\n\n        self.passmanager.append(PassI_Bad_AP())\n        self.assertSchedulerRaises(\n            circ,\n            self.passmanager,\n            [\"run analysis pass PassI_Bad_AP\", \"cx_runs: {(4, 5, 6, 7)}\"],\n            TranspilerError,\n        )\n\n    def test_analysis_pass_is_idempotent(self):\n        \"\"\"Analysis passes are idempotent.\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassE_AP_NR_NP(argument1=1))\n        passmanager.append(PassE_AP_NR_NP(argument1=1))\n        self.assertScheduler(\n            self.circuit, passmanager, [\"run analysis pass PassE_AP_NR_NP\", \"set property as 1\"]\n        )\n\n    def test_ap_before_and_after_a_tp(self):\n        \"\"\"A default transformation does not preserves anything\n        and analysis passes need to be re-run\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassE_AP_NR_NP(argument1=1))\n        passmanager.append(PassA_TP_NR_NP())\n        passmanager.append(PassE_AP_NR_NP(argument1=1))\n        self.assertScheduler(\n            self.circuit,\n            passmanager,\n            [\n                \"run analysis pass PassE_AP_NR_NP\",\n                \"set property as 1\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run analysis pass PassE_AP_NR_NP\",\n                \"set property as 1\",\n            ],\n        )\n\n    def test_pass_no_return(self):\n        \"\"\"Transformation passes that don't return a DAG raise error.\"\"\"\n        self.passmanager.append(PassJ_Bad_NoReturn())\n        self.assertSchedulerRaises(\n            self.circuit,\n            self.passmanager,\n            [\"run transformation pass PassJ_Bad_NoReturn\"],\n            TranspilerError,\n        )\n\n    def test_fixed_point_pass(self):\n        \"\"\"A pass set with a do_while parameter that checks for a fixed point.\"\"\"\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n        )\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 8 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 6\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 6 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 5\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 5 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 4\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 4 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 3\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 3 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 2 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 2\",\n            ],\n        )\n\n    def test_fixed_point_fc(self):\n        \"\"\"A fixed point scheduler with flow control.\"\"\"\n        self.passmanager.append(\n            DoWhileController(\n                [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n                do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            )\n        )\n\n        expected = [\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 8 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 6\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 6 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 5\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 5 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 4\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 4 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 3\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 3 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n        ]\n\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_fixed_point_pass_max_iteration(self):\n        \"\"\"A pass set with a do_while parameter that checks that\n        the max_iteration is raised.\"\"\"\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            max_iteration=2,\n        )\n        self.assertSchedulerRaises(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 8 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 6\",\n                \"run analysis pass PassG_calculates_dag_property\",\n                \"set property as 6 (from dag.property)\",\n                \"run analysis pass PassK_check_fixed_point_property\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassF_reduce_dag_property\",\n                \"dag property = 5\",\n            ],\n            TranspilerError,\n        )\n\n    def test_fresh_initial_state(self):\n        \"\"\"New construction gives fresh instance.\"\"\"\n        self.passmanager.append(PassM_AP_NR_NP(argument1=1))\n        self.passmanager.append(PassA_TP_NR_NP())\n        self.passmanager.append(PassM_AP_NR_NP(argument1=1))\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run analysis pass PassM_AP_NR_NP\",\n                \"self.argument1 = 2\",\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run analysis pass PassM_AP_NR_NP\",\n                \"self.argument1 = 2\",\n            ],\n        )\n\n    def test_nested_conditional_in_loop(self):\n        \"\"\"Run a loop with a nested conditional.\"\"\"\n        nested_conditional = [\n            ConditionalController(\n                [PassA_TP_NR_NP()], condition=lambda property_set: property_set[\"property\"] >= 5\n            )\n        ]\n        self.passmanager.append(\n            [PassK_check_fixed_point_property()]\n            + nested_conditional\n            + [PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n        )\n        expected = [\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 8 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 6\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 6 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 5\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 5 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 4\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 4 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 3\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 3 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n\nclass DoXTimesController(FlowController):\n    \"\"\"A control-flow plugin for running a set of passes an X amount of times.\"\"\"\n\n    def __init__(self, passes, options, do_x_times=0, **_):\n        self.do_x_times = do_x_times()\n        super().__init__(passes, options)\n\n    def __iter__(self):\n        for _ in range(self.do_x_times):\n            yield from self.passes\n\n\nclass TestControlFlowPlugin(SchedulerTestCase):\n    \"\"\"Testing the control flow plugin system.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.passmanager = PassManager()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def test_control_flow_plugin(self):\n        \"\"\"Adds a control flow plugin with a single parameter and runs it.\"\"\"\n        FlowController.add_flow_controller(\"do_x_times\", DoXTimesController)\n        self.passmanager.append([PassB_TP_RA_PA(), PassC_TP_RA_PA()], do_x_times=lambda x: 3)\n        self.assertScheduler(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassC_TP_RA_PA\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassC_TP_RA_PA\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassC_TP_RA_PA\",\n            ],\n        )\n\n    def test_callable_control_flow_plugin(self):\n        \"\"\"Removes do_while, then adds it back. Checks max_iteration still working.\"\"\"\n        controllers_length = len(FlowController.registered_controllers)\n        FlowController.remove_flow_controller(\"do_while\")\n        self.assertEqual(controllers_length - 1, len(FlowController.registered_controllers))\n        FlowController.add_flow_controller(\"do_while\", DoWhileController)\n        self.assertEqual(controllers_length, len(FlowController.registered_controllers))\n        self.passmanager.append(\n            [PassB_TP_RA_PA(), PassC_TP_RA_PA()],\n            do_while=lambda property_set: True,\n            max_iteration=2,\n        )\n        self.assertSchedulerRaises(\n            self.circuit,\n            self.passmanager,\n            [\n                \"run transformation pass PassA_TP_NR_NP\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassC_TP_RA_PA\",\n                \"run transformation pass PassB_TP_RA_PA\",\n                \"run transformation pass PassC_TP_RA_PA\",\n            ],\n            TranspilerError,\n        )\n\n    def test_remove_nonexistent_plugin(self):\n        \"\"\"Tries to remove a plugin that does not exist.\"\"\"\n        self.assertRaises(KeyError, FlowController.remove_flow_controller, \"foo\")\n\n    def test_bad_conditional(self):\n        \"\"\"Flow controller are not allowed to modify the property set.\"\"\"\n\n        def bad_condition(property_set):\n            property_set[\"property\"] = \"forbidden write\"\n\n        self.passmanager.append(PassA_TP_NR_NP(), condition=bad_condition)\n        self.assertRaises(TranspilerError, self.passmanager.run, self.circuit)\n\n\nclass TestDumpPasses(SchedulerTestCase):\n    \"\"\"Testing the passes method.\"\"\"\n\n    def test_passes(self):\n        \"\"\"Dump passes in different FlowControllerLinear\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassC_TP_RA_PA())\n        passmanager.append(PassB_TP_RA_PA())\n\n        expected = [\n            {\"flow_controllers\": {}, \"passes\": [PassC_TP_RA_PA()]},\n            {\"flow_controllers\": {}, \"passes\": [PassB_TP_RA_PA()]},\n        ]\n        self.assertEqual(expected, passmanager.passes())\n\n    def test_passes_in_linear(self):\n        \"\"\"Dump passes in the same FlowControllerLinear\"\"\"\n        passmanager = PassManager(\n            passes=[\n                PassC_TP_RA_PA(),\n                PassB_TP_RA_PA(),\n                PassD_TP_NR_NP(argument1=[1, 2]),\n                PassB_TP_RA_PA(),\n            ]\n        )\n\n        expected = [\n            {\n                \"flow_controllers\": {},\n                \"passes\": [\n                    PassC_TP_RA_PA(),\n                    PassB_TP_RA_PA(),\n                    PassD_TP_NR_NP(argument1=[1, 2]),\n                    PassB_TP_RA_PA(),\n                ],\n            }\n        ]\n        self.assertEqual(expected, passmanager.passes())\n\n    def test_control_flow_plugin(self):\n        \"\"\"Dump passes in a custom flow controller.\"\"\"\n        passmanager = PassManager()\n        FlowController.add_flow_controller(\"do_x_times\", DoXTimesController)\n        passmanager.append([PassB_TP_RA_PA(), PassC_TP_RA_PA()], do_x_times=lambda x: 3)\n\n        expected = [\n            {\"passes\": [PassB_TP_RA_PA(), PassC_TP_RA_PA()], \"flow_controllers\": {\"do_x_times\"}}\n        ]\n        self.assertEqual(expected, passmanager.passes())\n\n    def test_conditional_and_loop(self):\n        \"\"\"Dump passes with a conditional and a loop.\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassE_AP_NR_NP(True))\n        passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            condition=lambda property_set: property_set[\"property_fixed_point\"],\n        )\n\n        expected = [\n            {\"passes\": [PassE_AP_NR_NP(True)], \"flow_controllers\": {}},\n            {\n                \"passes\": [\n                    PassK_check_fixed_point_property(),\n                    PassA_TP_NR_NP(),\n                    PassF_reduce_dag_property(),\n                ],\n                \"flow_controllers\": {\"condition\", \"do_while\"},\n            },\n        ]\n        self.assertEqual(expected, passmanager.passes())\n\n\nclass StreamHandlerRaiseException(StreamHandler):\n    \"\"\"Handler class that will raise an exception on formatting errors.\"\"\"\n\n    def handleError(self, record):\n        raise sys.exc_info()\n\n\nclass TestLogPasses(QiskitTestCase):\n    \"\"\"Testing the log_passes option.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        logger = getLogger()\n        self.addCleanup(logger.setLevel, logger.level)\n        logger.setLevel(\"DEBUG\")\n        self.output = io.StringIO()\n        logger.addHandler(StreamHandlerRaiseException(self.output))\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def assertPassLog(self, passmanager, list_of_passes):\n        \"\"\"Runs the passmanager and checks that the elements in\n        passmanager.property_set['pass_log'] match list_of_passes (the names).\"\"\"\n        passmanager.run(self.circuit)\n        self.output.seek(0)\n        # Filter unrelated log lines\n        output_lines = self.output.readlines()\n        pass_log_lines = [x for x in output_lines if x.startswith(\"Pass:\")]\n        for index, pass_name in enumerate(list_of_passes):\n            self.assertTrue(pass_log_lines[index].startswith(\"Pass: %s -\" % pass_name))\n\n    def test_passes(self):\n        \"\"\"Dump passes in different FlowControllerLinear\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassC_TP_RA_PA())\n        passmanager.append(PassB_TP_RA_PA())\n\n        self.assertPassLog(passmanager, [\"PassA_TP_NR_NP\", \"PassC_TP_RA_PA\", \"PassB_TP_RA_PA\"])\n\n    def test_passes_in_linear(self):\n        \"\"\"Dump passes in the same FlowControllerLinear\"\"\"\n        passmanager = PassManager(\n            passes=[\n                PassC_TP_RA_PA(),\n                PassB_TP_RA_PA(),\n                PassD_TP_NR_NP(argument1=[1, 2]),\n                PassB_TP_RA_PA(),\n            ]\n        )\n\n        self.assertPassLog(\n            passmanager,\n            [\n                \"PassA_TP_NR_NP\",\n                \"PassC_TP_RA_PA\",\n                \"PassB_TP_RA_PA\",\n                \"PassD_TP_NR_NP\",\n                \"PassA_TP_NR_NP\",\n                \"PassB_TP_RA_PA\",\n            ],\n        )\n\n    def test_control_flow_plugin(self):\n        \"\"\"Dump passes in a custom flow controller.\"\"\"\n        passmanager = PassManager()\n        FlowController.add_flow_controller(\"do_x_times\", DoXTimesController)\n        passmanager.append([PassB_TP_RA_PA(), PassC_TP_RA_PA()], do_x_times=lambda x: 3)\n        self.assertPassLog(\n            passmanager,\n            [\n                \"PassA_TP_NR_NP\",\n                \"PassB_TP_RA_PA\",\n                \"PassC_TP_RA_PA\",\n                \"PassB_TP_RA_PA\",\n                \"PassC_TP_RA_PA\",\n                \"PassB_TP_RA_PA\",\n                \"PassC_TP_RA_PA\",\n            ],\n        )\n\n    def test_conditional_and_loop(self):\n        \"\"\"Dump passes with a conditional and a loop\"\"\"\n        passmanager = PassManager()\n        passmanager.append(PassE_AP_NR_NP(True))\n        passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n            condition=lambda property_set: property_set[\"property_fixed_point\"],\n        )\n        self.assertPassLog(passmanager, [\"PassE_AP_NR_NP\"])\n\n\nclass TestPassManagerReuse(SchedulerTestCase):\n    \"\"\"The PassManager instance should be reusable.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.passmanager = PassManager()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def test_chain_twice(self):\n        \"\"\"Run a chain twice.\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n            \"run transformation pass PassB_TP_RA_PA\",\n        ]\n\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_conditional_twice(self):\n        \"\"\"Run a conditional twice.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(True))\n        self.passmanager.append(\n            PassA_TP_NR_NP(), condition=lambda property_set: property_set[\"property\"]\n        )\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as True\",\n            \"run transformation pass PassA_TP_NR_NP\",\n        ]\n\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_fixed_point_twice(self):\n        \"\"\"A fixed point scheduler, twice.\"\"\"\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n        )\n\n        expected = [\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 8 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 6\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 6 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 5\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 5 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 4\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 4 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 3\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 3 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n        ]\n\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n\nclass TestPassManagerChanges(SchedulerTestCase):\n    \"\"\"Test PassManager manipulation with changes\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.passmanager = PassManager()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def test_replace0(self):\n        \"\"\"Test passmanager.replace(0, ...).\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager.replace(0, PassB_TP_RA_PA())\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_replace1(self):\n        \"\"\"Test passmanager.replace(1, ...).\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager.replace(1, PassC_TP_RA_PA())\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_remove0(self):\n        \"\"\"Test passmanager.remove(0).\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager.remove(0)\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_remove1(self):\n        \"\"\"Test passmanager.remove(1).\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager.remove(1)\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_remove_minus_1(self):\n        \"\"\"Test passmanager.remove(-1).\"\"\"\n        self.passmanager.append(PassA_TP_NR_NP())\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager.remove(-1)\n\n        expected = [\"run transformation pass PassA_TP_NR_NP\"]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_setitem(self):\n        \"\"\"Test passmanager[1] = ...\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())  # Request: PassA / Preserves: PassA\n        self.passmanager.append(PassB_TP_RA_PA())  # Request: PassA / Preserves: PassA\n\n        self.passmanager[1] = PassC_TP_RA_PA()\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_replace_with_conditional(self):\n        \"\"\"Replace a pass with a conditional pass.\"\"\"\n        self.passmanager.append(PassE_AP_NR_NP(False))\n        self.passmanager.append(PassB_TP_RA_PA())\n\n        self.passmanager.replace(\n            1, PassA_TP_NR_NP(), condition=lambda property_set: property_set[\"property\"]\n        )\n\n        expected = [\"run analysis pass PassE_AP_NR_NP\", \"set property as False\"]\n        self.assertScheduler(self.circuit, self.passmanager, expected)\n\n    def test_replace_error(self):\n        \"\"\"Replace a non-existing index.\"\"\"\n        self.passmanager.append(PassB_TP_RA_PA())\n\n        with self.assertRaises(TranspilerError):\n            self.passmanager.replace(99, PassA_TP_NR_NP())\n\n\nclass TestPassManagerSlicing(SchedulerTestCase):\n    \"\"\"test PassManager slicing.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.passmanager = PassManager()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def test_empty_passmanager_length(self):\n        \"\"\"test len(PassManager) when PassManager is empty\"\"\"\n        length = len(self.passmanager)\n\n        expected_length = 0\n        self.assertEqual(length, expected_length)\n\n    def test_passmanager_length(self):\n        \"\"\"test len(PassManager) when PassManager is not empty\"\"\"\n        self.passmanager.append(PassA_TP_NR_NP())\n        self.passmanager.append(PassA_TP_NR_NP())\n\n        length = len(self.passmanager)\n\n        expected_length = 2\n        self.assertEqual(length, expected_length)\n\n    def test_accessing_passmanager_by_index(self):\n        \"\"\"test accessing PassManager's passes by index\"\"\"\n        self.passmanager.append(PassB_TP_RA_PA())\n        self.passmanager.append(PassC_TP_RA_PA())\n\n        new_passmanager = self.passmanager[1]\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_accessing_passmanager_by_index_with_condition(self):\n        \"\"\"test accessing PassManager's conditioned passes by index\"\"\"\n        self.passmanager.append(PassF_reduce_dag_property())\n        self.passmanager.append(\n            [PassK_check_fixed_point_property(), PassA_TP_NR_NP(), PassF_reduce_dag_property()],\n            condition=lambda property_set: True,\n            do_while=lambda property_set: not property_set[\"property_fixed_point\"],\n        )\n\n        new_passmanager = self.passmanager[1]\n\n        expected = [\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 8 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 6\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 6 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 5\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 5 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 4\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 4 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 3\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 3 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n            \"run analysis pass PassG_calculates_dag_property\",\n            \"set property as 2 (from dag.property)\",\n            \"run analysis pass PassK_check_fixed_point_property\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassF_reduce_dag_property\",\n            \"dag property = 2\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_accessing_passmanager_by_range(self):\n        \"\"\"test accessing PassManager's passes by range\"\"\"\n        self.passmanager.append(PassC_TP_RA_PA())\n        self.passmanager.append(PassB_TP_RA_PA())\n        self.passmanager.append(PassC_TP_RA_PA())\n        self.passmanager.append(PassD_TP_NR_NP())\n\n        new_passmanager = self.passmanager[1:3]\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_accessing_passmanager_by_range_with_condition(self):\n        \"\"\"test accessing PassManager's passes by range with condition\"\"\"\n        self.passmanager.append(PassB_TP_RA_PA())\n        self.passmanager.append(PassE_AP_NR_NP(True))\n        self.passmanager.append(\n            PassA_TP_NR_NP(), condition=lambda property_set: property_set[\"property\"]\n        )\n        self.passmanager.append(PassB_TP_RA_PA())\n\n        new_passmanager = self.passmanager[1:3]\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as True\",\n            \"run transformation pass PassA_TP_NR_NP\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_accessing_passmanager_error(self):\n        \"\"\"testing accessing a pass item not in list\"\"\"\n        self.passmanager.append(PassB_TP_RA_PA())\n\n        with self.assertRaises(IndexError):\n            self.passmanager = self.passmanager[99]\n\n\nclass TestPassManagerConcatenation(SchedulerTestCase):\n    \"\"\"test PassManager concatenation by + operator.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.passmanager1 = PassManager()\n        self.passmanager2 = PassManager()\n        self.circuit = QuantumCircuit(QuantumRegister(1))\n\n    def test_concatenating_passmanagers(self):\n        \"\"\"test adding two PassManagers together\"\"\"\n        self.passmanager1.append(PassB_TP_RA_PA())\n        self.passmanager2.append(PassC_TP_RA_PA())\n\n        new_passmanager = self.passmanager1 + self.passmanager2\n\n        expected = [\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_concatenating_passmanagers_with_condition(self):\n        \"\"\"test adding two pass managers with condition\"\"\"\n        self.passmanager1.append(PassE_AP_NR_NP(True))\n        self.passmanager1.append(PassB_TP_RA_PA())\n        self.passmanager2.append(\n            PassC_TP_RA_PA(), condition=lambda property_set: property_set[\"property\"]\n        )\n        self.passmanager2.append(PassB_TP_RA_PA())\n\n        new_passmanager = self.passmanager1 + self.passmanager2\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as True\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n            \"run transformation pass PassC_TP_RA_PA\",\n            \"run transformation pass PassB_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, new_passmanager, expected)\n\n    def test_adding_pass_to_passmanager(self):\n        \"\"\"test adding a pass to PassManager\"\"\"\n        self.passmanager1.append(PassE_AP_NR_NP(argument1=1))\n        self.passmanager1.append(PassB_TP_RA_PA())\n\n        self.passmanager1 += PassC_TP_RA_PA()\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as 1\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager1, expected)\n\n    def test_adding_list_of_passes_to_passmanager(self):\n        \"\"\"test adding a list of passes to PassManager\"\"\"\n        self.passmanager1.append(PassE_AP_NR_NP(argument1=1))\n        self.passmanager1.append(PassB_TP_RA_PA())\n\n        self.passmanager1 += [PassC_TP_RA_PA(), PassB_TP_RA_PA()]\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as 1\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassB_TP_RA_PA\",\n            \"run transformation pass PassC_TP_RA_PA\",\n            \"run transformation pass PassB_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager1, expected)\n\n    def test_adding_list_of_passes_to_passmanager_with_condition(self):\n        \"\"\"test adding a list of passes to a PassManager that have conditions\"\"\"\n        self.passmanager1.append(PassE_AP_NR_NP(False))\n        self.passmanager1.append(\n            PassB_TP_RA_PA(), condition=lambda property_set: property_set[\"property\"]\n        )\n\n        self.passmanager1 += PassC_TP_RA_PA()\n\n        expected = [\n            \"run analysis pass PassE_AP_NR_NP\",\n            \"set property as False\",\n            \"run transformation pass PassA_TP_NR_NP\",\n            \"run transformation pass PassC_TP_RA_PA\",\n        ]\n        self.assertScheduler(self.circuit, self.passmanager1, expected)\n\n    def test_adding_pass_to_passmanager_error(self):\n        \"\"\"testing adding a non-pass item to PassManager\"\"\"\n        with self.assertRaises(TypeError):\n            self.passmanager1 += \"not a pass\"\n\n    def test_adding_list_to_passmanager_error(self):\n        \"\"\"testing adding a list having a non-pass item to PassManager\"\"\"\n        with self.assertRaises(TypeError):\n            self.passmanager1 += [PassB_TP_RA_PA(), \"not a pass\"]\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17d9e"
  },
  "id": "a7d79221-d6f9-4160-adb9-ec6188a967e7",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.converters.test_circuit_to_dagdependency.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test for the converter dag dependency to circuit and circuit to dag\ndependency.\"\"\"\n\nimport unittest\n\nfrom qiskit.converters.dagdependency_to_circuit import dagdependency_to_circuit\nfrom qiskit.converters.circuit_to_dagdependency import circuit_to_dagdependency\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestCircuitToDagCanonical(QiskitTestCase):\n    \"\"\"Test QuantumCircuit to DAGDependency.\"\"\"\n\n    def test_circuit_and_dag_canonical(self):\n        \"\"\"Check convert to dag dependency and back\"\"\"\n        qr = QuantumRegister(3)\n        cr = ClassicalRegister(3)\n        circuit_in = QuantumCircuit(qr, cr)\n        circuit_in.h(qr[0])\n        circuit_in.h(qr[1])\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.x(qr[0]).c_if(cr, 0x3)\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.measure(qr[2], cr[2])\n        dag_dependency = circuit_to_dagdependency(circuit_in)\n        circuit_out = dagdependency_to_circuit(dag_dependency)\n        self.assertEqual(circuit_out, circuit_in)\n\n    def test_circuit_and_dag_canonical2(self):\n        \"\"\"Check convert to dag dependency and back\n        also when the option ``create_preds_and_succs`` is False.\"\"\"\n        qr = QuantumRegister(3)\n        cr = ClassicalRegister(3)\n        circuit_in = QuantumCircuit(qr, cr)\n        circuit_in.h(qr[0])\n        circuit_in.h(qr[1])\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.x(qr[0]).c_if(cr, 0x3)\n        circuit_in.measure(qr[0], cr[0])\n        circuit_in.measure(qr[1], cr[1])\n        circuit_in.measure(qr[2], cr[2])\n        dag_dependency = circuit_to_dagdependency(circuit_in, create_preds_and_succs=False)\n        circuit_out = dagdependency_to_circuit(dag_dependency)\n        self.assertEqual(circuit_out, circuit_in)\n\n    def test_calibrations(self):\n        \"\"\"Test that calibrations are properly copied over.\"\"\"\n        circuit_in = QuantumCircuit(1)\n        circuit_in.add_calibration(\"h\", [0], None)\n        self.assertEqual(len(circuit_in.calibrations), 1)\n\n        dag_dependency = circuit_to_dagdependency(circuit_in)\n        self.assertEqual(len(dag_dependency.calibrations), 1)\n\n        circuit_out = dagdependency_to_circuit(dag_dependency)\n        self.assertEqual(len(circuit_out.calibrations), 1)\n\n    def test_metadata(self):\n        \"\"\"Test circuit metadata is preservered through conversion.\"\"\"\n        meta_dict = dict(experiment_id=\"1234\", execution_number=4)\n        qr = QuantumRegister(2)\n        circuit_in = QuantumCircuit(qr, metadata=meta_dict)\n        circuit_in.h(qr[0])\n        circuit_in.cx(qr[0], qr[1])\n        circuit_in.measure_all()\n        dag_dependency = circuit_to_dagdependency(circuit_in)\n        self.assertEqual(dag_dependency.metadata, meta_dict)\n        circuit_out = dagdependency_to_circuit(dag_dependency)\n        self.assertEqual(circuit_out.metadata, meta_dict)\n\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)\n",
  "circuit": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 771,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        },
        "timestamp": "2023-11-26T22:46:07.303+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": [
      {
        "id": 0,
        "position": {
          "qubit": 1,
          "column": 1,
          "fragment": "[[\"H\", {\"CONTROL\": 1}], [\"_\", \"X\"]]"
        }
      }
    ],
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17ddf"
  },
  "id": "4980e625-03cd-4801-9839-c9cd9e096bf1",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.rz.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the Z axis.\"\"\"\nfrom cmath import exp\nfrom typing import Optional, Union\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RZGate(Gate):\n    r\"\"\"Single-qubit rotation about the Z axis.\n\n    This is a diagonal gate. It can be implemented virtually in hardware\n    via framechanges (i.e. at zero error and duration).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.rz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        RZ(\\lambda) = \\exp\\left(-i\\frac{\\lambda}{2}Z\\right) =\n            \\begin{pmatrix}\n                e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.U1Gate`\n        This gate is equivalent to U1 up to a phase factor.\n\n            .. math::\n\n                U1(\\lambda) = e^{i{\\lambda}/2}RZ(\\lambda)\n\n        Reference for virtual Z gate implementation:\n        `1612.00858 <https://arxiv.org/abs/1612.00858>`_\n    \"\"\"\n\n    def __init__(self, phi: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new RZ gate.\"\"\"\n        super().__init__(\"rz\", 1, [phi], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate rz(phi) a { u1(phi) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        theta = self.params[0]\n        qc = QuantumCircuit(q, name=self.name, global_phase=-theta / 2)\n        rules = [(U1Gate(theta), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRZGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RZ gate\n\n        :math:`RZ(\\lambda){\\dagger} = RZ(-\\lambda)`\n        \"\"\"\n        return RZGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RZ gate.\"\"\"\n        import numpy as np\n\n        ilam2 = 0.5j * float(self.params[0])\n        return np.array([[exp(-ilam2), 0], [0, exp(ilam2)]], dtype=dtype)\n\n\nclass CRZGate(ControlledGate):\n    r\"\"\"Controlled-RZ gate.\n\n    This is a diagonal but non-symmetric gate that induces a\n    phase on the state of the target qubit, depending on the control state.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.crz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Rz(λ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CRZ(\\lambda)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RZ(\\lambda) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & e^{-i\\frac{\\lambda}{2}} & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Rz(λ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            CRZ(\\lambda)\\ q_1, q_0 =\n                |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes RZ(\\lambda) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & e^{-i\\frac{\\lambda}{2}} & 0 \\\\\n                    0 & 0 & 0 & e^{i\\frac{\\lambda}{2}}\n                \\end{pmatrix}\n\n    .. seealso::\n\n        :class:`~qiskit.circuit.library.standard_gates.CU1Gate`:\n        Due to the global phase difference in the matrix definitions\n        of U1 and RZ, CU1 and CRZ are different gates with a relative\n        phase difference.\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Create new CRZ gate.\"\"\"\n        super().__init__(\n            \"crz\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RZGate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate crz(lambda) a,b\n        { rz(lambda/2) b; cx a,b;\n          rz(-lambda/2) b; cx a,b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate\n\n        # q_0: ─────────────■────────────────■──\n        #      ┌─────────┐┌─┴─┐┌──────────┐┌─┴─┐\n        # q_1: ┤ Rz(λ/2) ├┤ X ├┤ Rz(-λ/2) ├┤ X ├\n        #      └─────────┘└───┘└──────────┘└───┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RZGate(self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (RZGate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRZ gate (i.e. with the negative rotation angle).\"\"\"\n        return CRZGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRZ gate.\"\"\"\n        import numpy\n\n        arg = 1j * float(self.params[0]) / 2\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, exp(-arg), 0, 0], [0, 0, 1, 0], [0, 0, 0, exp(arg)]],\n                dtype=dtype,\n            )\n        else:\n            return numpy.array(\n                [[exp(-arg), 0, 0, 0], [0, 1, 0, 0], [0, 0, exp(arg), 0], [0, 0, 0, 1]],\n                dtype=dtype,\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17e32"
  },
  "id": "f89a31b1-6c13-4fb2-ac90-d8fa2cc35cbc",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.y.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Y and CY gates.\"\"\"\n\nfrom typing import Optional, Union\nimport numpy\nfrom qiskit.qasm import pi\n\n# pylint: disable=cyclic-import\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\n\nclass YGate(Gate):\n    r\"\"\"The single-qubit Pauli-Y gate (:math:`\\sigma_y`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.y` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Y = \\begin{pmatrix}\n                0 & -i \\\\\n                i & 0\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Y ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Y axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RY(\\pi)` and :math:`Y`.\n\n        .. math::\n\n            RY(\\pi) = \\begin{pmatrix}\n                        0 & -1 \\\\\n                        1 & 0\n                      \\end{pmatrix}\n                    = -i Y\n\n    The gate is equivalent to a bit and phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow i|1\\rangle \\\\\n        |1\\rangle \\rightarrow -i|0\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Y gate.\"\"\"\n        super().__init__(\"y\", 1, [], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u3 import U3Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U3Gate(pi, pi / 2, pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Y gate.\n\n        One control returns a CY gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CYGate(label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted Y gate (:math:`Y{\\dagger} = Y`)\"\"\"\n        return YGate()  # self-inverse\n\n    def __array__(self, dtype=complex):\n        \"\"\"Return a numpy.array for the Y gate.\"\"\"\n        return numpy.array([[0, -1j], [1j, 0]], dtype=dtype)\n\n\nclass CYGate(ControlledGate):\n    r\"\"\"Controlled-Y gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cy` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ Y ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CY\\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + Y \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & -i \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & i & 0 & 0\n            \\end{pmatrix}\n\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───┐\n            q_0: ┤ Y ├\n                 └─┬─┘\n            q_1: ──■──\n\n        .. math::\n\n            CY\\ q_1, q_0 =\n                |0 \\rangle\\langle 0| \\otimes I + |1 \\rangle\\langle 1| \\otimes Y =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & 0 & -i \\\\\n                    0 & 0 & i & 0\n                \\end{pmatrix}\n\n    \"\"\"\n    # Define class constants. This saves future allocation time.\n    _matrix1 = numpy.array([[1, 0, 0, 0], [0, 0, 0, -1j], [0, 0, 1, 0], [0, 1j, 0, 0]])\n    _matrix0 = numpy.array([[0, 0, -1j, 0], [0, 1, 0, 0], [1j, 0, 0, 0], [0, 0, 0, 1]])\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CY gate.\"\"\"\n        super().__init__(\n            \"cy\", 2, [], num_ctrl_qubits=1, label=label, ctrl_state=ctrl_state, base_gate=YGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cy a,b { sdg b; cx a,b; s b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .s import SGate, SdgGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(SdgGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (SGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CY gate (itself).\"\"\"\n        return CYGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CY gate.\"\"\"\n        mat = self._matrix1 if self.ctrl_state else self._matrix0\n        if dtype:\n            return numpy.asarray(mat, dtype=dtype)\n        return mat\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17e3c"
  },
  "id": "882d88ce-ebee-469a-bdc9-e1ab71b1f73c",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.quantum_info.synthesis.one_qubit_decompose.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nDecompose a single-qubit unitary via Euler angles.\n\"\"\"\n\nimport math\nimport cmath\nimport numpy as np\n\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.library.standard_gates import (\n    UGate,\n    PhaseGate,\n    U3Gate,\n    U2Gate,\n    U1Gate,\n    RXGate,\n    RYGate,\n    RZGate,\n    RGate,\n    SXGate,\n    XGate,\n)\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.quantum_info.operators.predicates import is_unitary_matrix\n\nDEFAULT_ATOL = 1e-12\n\nONE_QUBIT_EULER_BASIS_GATES = {\n    \"U3\": [\"u3\"],\n    \"U321\": [\"u3\", \"u2\", \"u1\"],\n    \"U\": [\"u\"],\n    \"PSX\": [\"p\", \"sx\"],\n    \"U1X\": [\"u1\", \"rx\"],\n    \"RR\": [\"r\"],\n    \"ZYZ\": [\"rz\", \"ry\"],\n    \"ZXZ\": [\"rz\", \"rx\"],\n    \"XZX\": [\"rz\", \"rx\"],\n    \"XYX\": [\"rx\", \"ry\"],\n    \"ZSXX\": [\"rz\", \"sx\", \"x\"],\n    \"ZSX\": [\"rz\", \"sx\"],\n}\n\n\nclass OneQubitEulerDecomposer:\n    r\"\"\"A class for decomposing 1-qubit unitaries into Euler angle rotations.\n\n    The resulting decomposition is parameterized by 3 Euler rotation angle\n    parameters :math:`(\\theta, \\phi, \\lambda)`, and a phase parameter\n    :math:`\\gamma`. The value of the parameters for an input unitary depends\n    on the decomposition basis. Allowed bases and the resulting circuits are\n    shown in the following table. Note that for the non-Euler bases (U3, U1X,\n    RR), the ZYZ Euler parameters are used.\n\n    .. list-table:: Supported circuit bases\n        :widths: auto\n        :header-rows: 1\n\n        * - Basis\n          - Euler Angle Basis\n          - Decomposition Circuit\n        * - 'ZYZ'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} R_Z(\\phi).R_Y(\\theta).R_Z(\\lambda)`\n        * - 'ZXZ'\n          - :math:`Z(\\phi) X(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} R_Z(\\phi).R_X(\\theta).R_Z(\\lambda)`\n        * - 'XYX'\n          - :math:`X(\\phi) Y(\\theta) X(\\lambda)`\n          - :math:`e^{i\\gamma} R_X(\\phi).R_Y(\\theta).R_X(\\lambda)`\n        * - 'XZX'\n          - :math:`X(\\phi) Z(\\theta) X(\\lambda)`\n          - :math:`e^{i\\gamma} R_X(\\phi).R_Z(\\theta).R_X(\\lambda)`\n        * - 'U3'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} U_3(\\theta,\\phi,\\lambda)`\n        * - 'U321'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} U_3(\\theta,\\phi,\\lambda)`\n        * - 'U'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} U_3(\\theta,\\phi,\\lambda)`\n        * - 'PSX'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} U_1(\\phi+\\pi).R_X\\left(\\frac{\\pi}{2}\\right).`\n            :math:`U_1(\\theta+\\pi).R_X\\left(\\frac{\\pi}{2}\\right).U_1(\\lambda)`\n        * - 'ZSX'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} R_Z(\\phi+\\pi).\\sqrt{X}.`\n            :math:`R_Z(\\theta+\\pi).\\sqrt{X}.R_Z(\\lambda)`\n        * - 'ZSXX'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} R_Z(\\phi+\\pi).\\sqrt{X}.R_Z(\\theta+\\pi).\\sqrt{X}.R_Z(\\lambda)`\n            or\n            :math:`e^{i\\gamma} R_Z(\\phi+\\pi).X.R_Z(\\lambda)`\n        * - 'U1X'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} U_1(\\phi+\\pi).R_X\\left(\\frac{\\pi}{2}\\right).`\n            :math:`U_1(\\theta+\\pi).R_X\\left(\\frac{\\pi}{2}\\right).U_1(\\lambda)`\n        * - 'RR'\n          - :math:`Z(\\phi) Y(\\theta) Z(\\lambda)`\n          - :math:`e^{i\\gamma} R\\left(-\\pi,\\frac{\\phi-\\lambda+\\pi}{2}\\right).`\n            :math:`R\\left(\\theta+\\pi,\\frac{\\pi}{2}-\\lambda\\right)`\n    \"\"\"\n\n    def __init__(self, basis=\"U3\"):\n        \"\"\"Initialize decomposer\n\n        Supported bases are: 'U', 'PSX', 'ZSXX', 'ZSX', 'U321', 'U3', 'U1X', 'RR', 'ZYZ', 'ZXZ',\n        'XYX', 'XZX'.\n\n        Args:\n            basis (str): the decomposition basis [Default: 'U3']\n\n        Raises:\n            QiskitError: If input basis is not recognized.\n        \"\"\"\n        self.basis = basis  # sets: self._basis, self._params, self._circuit\n\n    def __call__(self, unitary, simplify=True, atol=DEFAULT_ATOL):\n        \"\"\"Decompose single qubit gate into a circuit.\n\n        Args:\n            unitary (Operator or Gate or array): 1-qubit unitary matrix\n            simplify (bool): reduce gate count in decomposition [Default: True].\n            atol (float): absolute tolerance for checking angles when simplifying\n                         returned circuit [Default: 1e-12].\n        Returns:\n            QuantumCircuit: the decomposed single-qubit gate circuit\n\n        Raises:\n            QiskitError: if input is invalid or synthesis fails.\n        \"\"\"\n        if hasattr(unitary, \"to_operator\"):\n            # If input is a BaseOperator subclass this attempts to convert\n            # the object to an Operator so that we can extract the underlying\n            # numpy matrix from `Operator.data`.\n            unitary = unitary.to_operator().data\n        elif hasattr(unitary, \"to_matrix\"):\n            # If input is Gate subclass or some other class object that has\n            # a to_matrix method this will call that method.\n            unitary = unitary.to_matrix()\n        # Convert to numpy array in case not already an array\n        unitary = np.asarray(unitary, dtype=complex)\n\n        # Check input is a 2-qubit unitary\n        if unitary.shape != (2, 2):\n            raise QiskitError(\"OneQubitEulerDecomposer: expected 2x2 input matrix\")\n        if not is_unitary_matrix(unitary):\n            raise QiskitError(\"OneQubitEulerDecomposer: input matrix is not unitary.\")\n        return self._decompose(unitary, simplify=simplify, atol=atol)\n\n    def _decompose(self, unitary, simplify=True, atol=DEFAULT_ATOL):\n        theta, phi, lam, phase = self._params(unitary)\n        circuit = self._circuit(theta, phi, lam, phase, simplify=simplify, atol=atol)\n        return circuit\n\n    @property\n    def basis(self):\n        \"\"\"The decomposition basis.\"\"\"\n        return self._basis\n\n    @basis.setter\n    def basis(self, basis):\n        \"\"\"Set the decomposition basis.\"\"\"\n        basis_methods = {\n            \"U321\": (self._params_u3, self._circuit_u321),\n            \"U3\": (self._params_u3, self._circuit_u3),\n            \"U\": (self._params_u3, self._circuit_u),\n            \"PSX\": (self._params_u1x, self._circuit_psx),\n            \"ZSX\": (self._params_u1x, self._circuit_zsx),\n            \"ZSXX\": (self._params_u1x, self._circuit_zsxx),\n            \"U1X\": (self._params_u1x, self._circuit_u1x),\n            \"RR\": (self._params_zyz, self._circuit_rr),\n            \"ZYZ\": (self._params_zyz, self._circuit_zyz),\n            \"ZXZ\": (self._params_zxz, self._circuit_zxz),\n            \"XYX\": (self._params_xyx, self._circuit_xyx),\n            \"XZX\": (self._params_xzx, self._circuit_xzx),\n        }\n        if basis not in basis_methods:\n            raise QiskitError(f\"OneQubitEulerDecomposer: unsupported basis {basis}\")\n        self._basis = basis\n        self._params, self._circuit = basis_methods[self._basis]\n\n    def angles(self, unitary):\n        \"\"\"Return the Euler angles for input array.\n\n        Args:\n            unitary (np.ndarray): 2x2 unitary matrix.\n\n        Returns:\n            tuple: (theta, phi, lambda).\n        \"\"\"\n        theta, phi, lam, _ = self._params(unitary)\n        return theta, phi, lam\n\n    def angles_and_phase(self, unitary):\n        \"\"\"Return the Euler angles and phase for input array.\n\n        Args:\n            unitary (np.ndarray): 2x2 unitary matrix.\n\n        Returns:\n            tuple: (theta, phi, lambda, phase).\n        \"\"\"\n        return self._params(unitary)\n\n    @staticmethod\n    def _params_zyz(mat):\n        \"\"\"Return the Euler angles and phase for the ZYZ basis.\"\"\"\n        # We rescale the input matrix to be special unitary (det(U) = 1)\n        # This ensures that the quaternion representation is real\n        coeff = np.linalg.det(mat) ** (-0.5)\n        phase = -cmath.phase(coeff)\n        su_mat = coeff * mat  # U in SU(2)\n        # OpenQASM SU(2) parameterization:\n        # U[0, 0] = exp(-i(phi+lambda)/2) * cos(theta/2)\n        # U[0, 1] = -exp(-i(phi-lambda)/2) * sin(theta/2)\n        # U[1, 0] = exp(i(phi-lambda)/2) * sin(theta/2)\n        # U[1, 1] = exp(i(phi+lambda)/2) * cos(theta/2)\n        theta = 2 * math.atan2(abs(su_mat[1, 0]), abs(su_mat[0, 0]))\n        phiplambda2 = cmath.phase(su_mat[1, 1])\n        phimlambda2 = cmath.phase(su_mat[1, 0])\n        phi = phiplambda2 + phimlambda2\n        lam = phiplambda2 - phimlambda2\n        return theta, phi, lam, phase\n\n    @staticmethod\n    def _params_zxz(mat):\n        \"\"\"Return the Euler angles and phase for the ZXZ basis.\"\"\"\n        theta, phi, lam, phase = OneQubitEulerDecomposer._params_zyz(mat)\n        return theta, phi + np.pi / 2, lam - np.pi / 2, phase\n\n    @staticmethod\n    def _params_xyx(mat):\n        \"\"\"Return the Euler angles and phase for the XYX basis.\"\"\"\n        # We use the fact that\n        # Rx(a).Ry(b).Rx(c) = H.Rz(a).Ry(-b).Rz(c).H\n        mat_zyz = 0.5 * np.array(\n            [\n                [\n                    mat[0, 0] + mat[0, 1] + mat[1, 0] + mat[1, 1],\n                    mat[0, 0] - mat[0, 1] + mat[1, 0] - mat[1, 1],\n                ],\n                [\n                    mat[0, 0] + mat[0, 1] - mat[1, 0] - mat[1, 1],\n                    mat[0, 0] - mat[0, 1] - mat[1, 0] + mat[1, 1],\n                ],\n            ],\n            dtype=complex,\n        )\n        theta, phi, lam, phase = OneQubitEulerDecomposer._params_zyz(mat_zyz)\n        newphi, newlam = _mod_2pi(phi + np.pi), _mod_2pi(lam + np.pi)\n        return theta, newphi, newlam, phase + (newphi + newlam - phi - lam) / 2\n\n    @staticmethod\n    def _params_xzx(umat):\n        det = np.linalg.det(umat)\n        phase = (-1j * np.log(det)).real / 2\n        mat = umat / np.sqrt(det)\n        mat_zxz = _h_conjugate(mat)\n        theta, phi, lam, phase_zxz = OneQubitEulerDecomposer._params_zxz(mat_zxz)\n        return theta, phi, lam, phase + phase_zxz\n\n    @staticmethod\n    def _params_u3(mat):\n        \"\"\"Return the Euler angles and phase for the U3 basis.\"\"\"\n        # The determinant of U3 gate depends on its params\n        # via det(u3(theta, phi, lam)) = exp(1j*(phi+lam))\n        # Since the phase is wrt to a SU matrix we must rescale\n        # phase to correct this\n        theta, phi, lam, phase = OneQubitEulerDecomposer._params_zyz(mat)\n        return theta, phi, lam, phase - 0.5 * (phi + lam)\n\n    @staticmethod\n    def _params_u1x(mat):\n        \"\"\"Return the Euler angles and phase for the U1X basis.\"\"\"\n        # The determinant of this decomposition depends on its params\n        # Since the phase is wrt to a SU matrix we must rescale\n        # phase to correct this\n        theta, phi, lam, phase = OneQubitEulerDecomposer._params_zyz(mat)\n        return theta, phi, lam, phase - 0.5 * (theta + phi + lam)\n\n    @staticmethod\n    def _circuit_kak(\n        theta,\n        phi,\n        lam,\n        phase,\n        simplify=True,\n        atol=DEFAULT_ATOL,\n        allow_non_canonical=True,\n        k_gate=RZGate,\n        a_gate=RYGate,\n    ):\n        \"\"\"\n        Installs the angles phi, theta, and lam into a KAK-type decomposition of the form\n        K(phi) . A(theta) . K(lam) , where K and A are an orthogonal pair drawn from RZGate, RYGate,\n        and RXGate.\n\n        Args:\n            theta (float): The middle KAK parameter.  Expected to lie in [0, pi).\n            phi (float): The first KAK parameter.\n            lam (float): The final KAK parameter.\n            phase (float): The input global phase.\n            k_gate (Callable): The constructor for the K gate Instruction.\n            a_gate (Callable): The constructor for the A gate Instruction.\n            simplify (bool): Indicates whether gates should be elided / coalesced where possible.\n            allow_non_canonical (bool): Indicates whether we are permitted to reverse the sign of\n                the middle parameter, theta, in the output.  When this and `simplify` are both\n                enabled, we take the opportunity to commute half-rotations in the outer gates past\n                the middle gate, which permits us to coalesce them at the cost of reversing the sign\n                of theta.\n\n        Returns:\n            QuantumCircuit: The assembled circuit.\n        \"\"\"\n        gphase = phase - (phi + lam) / 2\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr)\n        if not simplify:\n            atol = -1.0\n        # Early return for the middle-gate-free case\n        if abs(theta) < atol:\n            lam, phi = lam + phi, 0\n            # NOTE: The following normalization is safe, because the gphase correction below\n            #       fixes a particular diagonal entry to 1, which prevents any potential phase\n            #       slippage coming from _mod_2pi injecting multiples of 2pi.\n            lam = _mod_2pi(lam, atol)\n            if abs(lam) > atol:\n\n                circuit._append(k_gate(lam), [qr[0]], [])\n                gphase += lam / 2\n            circuit.global_phase = gphase\n            return circuit\n        if abs(theta - np.pi) < atol:\n            gphase += phi\n            lam, phi = lam - phi, 0\n        if allow_non_canonical and (\n            abs(_mod_2pi(lam + np.pi)) < atol or abs(_mod_2pi(phi + np.pi)) < atol\n        ):\n            lam, theta, phi = lam + np.pi, -theta, phi + np.pi\n        lam = _mod_2pi(lam, atol)\n        if abs(lam) > atol:\n            gphase += lam / 2\n            circuit._append(k_gate(lam), [qr[0]], [])\n        circuit._append(a_gate(theta), [qr[0]], [])\n        phi = _mod_2pi(phi, atol)\n        if abs(phi) > atol:\n            gphase += phi / 2\n            circuit._append(k_gate(phi), [qr[0]], [])\n        circuit.global_phase = gphase\n        return circuit\n\n    def _circuit_zyz(\n        self, theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL, allow_non_canonical=True\n    ):\n        return self._circuit_kak(\n            theta,\n            phi,\n            lam,\n            phase,\n            simplify=simplify,\n            atol=atol,\n            allow_non_canonical=allow_non_canonical,\n            k_gate=RZGate,\n            a_gate=RYGate,\n        )\n\n    def _circuit_zxz(\n        self, theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL, allow_non_canonical=True\n    ):\n        return self._circuit_kak(\n            theta,\n            phi,\n            lam,\n            phase,\n            simplify=simplify,\n            atol=atol,\n            allow_non_canonical=allow_non_canonical,\n            k_gate=RZGate,\n            a_gate=RXGate,\n        )\n\n    def _circuit_xzx(\n        self, theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL, allow_non_canonical=True\n    ):\n        return self._circuit_kak(\n            theta,\n            phi,\n            lam,\n            phase,\n            simplify=simplify,\n            atol=atol,\n            allow_non_canonical=allow_non_canonical,\n            k_gate=RXGate,\n            a_gate=RZGate,\n        )\n\n    def _circuit_xyx(\n        self, theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL, allow_non_canonical=True\n    ):\n        return self._circuit_kak(\n            theta,\n            phi,\n            lam,\n            phase,\n            simplify=simplify,\n            atol=atol,\n            allow_non_canonical=allow_non_canonical,\n            k_gate=RXGate,\n            a_gate=RYGate,\n        )\n\n    @staticmethod\n    def _circuit_u3(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, global_phase=phase)\n        phi = _mod_2pi(phi, atol)\n        lam = _mod_2pi(lam, atol)\n        if not simplify or abs(theta) > atol or abs(phi) > atol or abs(lam) > atol:\n            circuit._append(U3Gate(theta, phi, lam), [qr[0]], [])\n        return circuit\n\n    @staticmethod\n    def _circuit_u321(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, global_phase=phase)\n        if not simplify:\n            atol = -1.0\n        if abs(theta) < atol:\n            tot = _mod_2pi(phi + lam, atol)\n            if abs(tot) > atol:\n                circuit._append(U1Gate(tot), [qr[0]], [])\n        elif abs(theta - np.pi / 2) < atol:\n            circuit._append(U2Gate(_mod_2pi(phi, atol), _mod_2pi(lam, atol)), [qr[0]], [])\n        else:\n            circuit._append(U3Gate(theta, _mod_2pi(phi, atol), _mod_2pi(lam, atol)), [qr[0]], [])\n        return circuit\n\n    @staticmethod\n    def _circuit_u(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, global_phase=phase)\n        if not simplify:\n            atol = -1.0\n        phi = _mod_2pi(phi, atol)\n        lam = _mod_2pi(lam, atol)\n        if abs(theta) > atol or abs(phi) > atol or abs(lam) > atol:\n            circuit._append(UGate(theta, phi, lam), [qr[0]], [])\n        return circuit\n\n    @staticmethod\n    def _circuit_psx_gen(theta, phi, lam, phase, atol, pfun, xfun, xpifun=None):\n        \"\"\"\n        Generic X90, phase decomposition\n\n        NOTE: `pfun` is responsible for eliding gates where appropriate (e.g., at angle value 0).\n        \"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, global_phase=phase)\n        # Early return for zero SX decomposition\n        if np.abs(theta) < atol:\n            pfun(circuit, qr, lam + phi)\n            return circuit\n        # Early return for single SX decomposition\n        if abs(theta - np.pi / 2) < atol:\n            pfun(circuit, qr, lam - np.pi / 2)\n            xfun(circuit, qr)\n            pfun(circuit, qr, phi + np.pi / 2)\n            return circuit\n        # General double SX decomposition\n        if abs(theta - np.pi) < atol:\n            circuit.global_phase += lam\n            phi, lam = phi - lam, 0\n        if abs(_mod_2pi(lam + np.pi)) < atol or abs(_mod_2pi(phi)) < atol:\n            lam, theta, phi = lam + np.pi, -theta, phi + np.pi\n            circuit.global_phase -= theta\n        # Shift theta and phi to turn the decomposition from\n        # RZ(phi).RY(theta).RZ(lam) = RZ(phi).RX(-pi/2).RZ(theta).RX(pi/2).RZ(lam)\n        # into RZ(phi+pi).SX.RZ(theta+pi).SX.RZ(lam) .\n        theta, phi = theta + np.pi, phi + np.pi\n        circuit.global_phase -= np.pi / 2\n        # Emit circuit\n        pfun(circuit, qr, lam)\n        if xpifun and abs(_mod_2pi(theta)) < atol:\n            xpifun(circuit, qr)\n        else:\n            xfun(circuit, qr)\n            pfun(circuit, qr, theta)\n            xfun(circuit, qr)\n        pfun(circuit, qr, phi)\n\n        return circuit\n\n    @staticmethod\n    def _circuit_psx(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        if not simplify:\n            atol = -1.0\n\n        def fnz(circuit, qr, phi):\n            phi = _mod_2pi(phi, atol)\n            if abs(phi) > atol:\n                circuit._append(PhaseGate(phi), [qr[0]], [])\n\n        def fnx(circuit, qr):\n            circuit._append(SXGate(), [qr[0]], [])\n\n        return OneQubitEulerDecomposer._circuit_psx_gen(theta, phi, lam, phase, atol, fnz, fnx)\n\n    @staticmethod\n    def _circuit_zsx(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        if not simplify:\n            atol = -1.0\n\n        def fnz(circuit, qr, phi):\n            phi = _mod_2pi(phi, atol)\n            if abs(phi) > atol:\n                circuit._append(RZGate(phi), [qr[0]], [])\n                circuit.global_phase += phi / 2\n\n        def fnx(circuit, qr):\n            circuit._append(SXGate(), [qr[0]], [])\n\n        return OneQubitEulerDecomposer._circuit_psx_gen(theta, phi, lam, phase, atol, fnz, fnx)\n\n    @staticmethod\n    def _circuit_u1x(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        if not simplify:\n            atol = -1.0\n\n        def fnz(circuit, qr, phi):\n            phi = _mod_2pi(phi, atol)\n            if abs(phi) > atol:\n                circuit._append(U1Gate(phi), [qr[0]], [])\n\n        def fnx(circuit, qr):\n            circuit.global_phase += np.pi / 4\n            circuit._append(RXGate(np.pi / 2), [qr[0]], [])\n\n        return OneQubitEulerDecomposer._circuit_psx_gen(theta, phi, lam, phase, atol, fnz, fnx)\n\n    @staticmethod\n    def _circuit_zsxx(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        if not simplify:\n            atol = -1.0\n\n        def fnz(circuit, qr, phi):\n            phi = _mod_2pi(phi, atol)\n            if abs(phi) > atol:\n                circuit._append(RZGate(phi), [qr[0]], [])\n                circuit.global_phase += phi / 2\n\n        def fnx(circuit, qr):\n            circuit._append(SXGate(), [qr[0]], [])\n\n        def fnxpi(circuit, qr):\n            circuit._append(XGate(), [qr[0]], [])\n\n        return OneQubitEulerDecomposer._circuit_psx_gen(\n            theta, phi, lam, phase, atol, fnz, fnx, fnxpi\n        )\n\n    @staticmethod\n    def _circuit_rr(theta, phi, lam, phase, simplify=True, atol=DEFAULT_ATOL):\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, global_phase=phase)\n        if not simplify:\n            atol = -1.0\n        if abs(theta) < atol and abs(phi) < atol and abs(lam) < atol:\n            return circuit\n        if abs(theta - np.pi) > atol:\n            circuit._append(RGate(theta - np.pi, _mod_2pi(np.pi / 2 - lam, atol)), [qr[0]], [])\n        circuit._append(RGate(np.pi, _mod_2pi(0.5 * (phi - lam + np.pi), atol)), [qr[0]], [])\n        return circuit\n\n\ndef _mod_2pi(angle: float, atol: float = 0):\n    \"\"\"Wrap angle into interval [-π,π). If within atol of the endpoint, clamp to -π\"\"\"\n    wrapped = (angle + np.pi) % (2 * np.pi) - np.pi\n    if abs(wrapped - np.pi) < atol:\n        wrapped = -np.pi\n    return wrapped\n\n\ndef _h_conjugate(su2):\n    \"\"\"Return su2 conjugated by Hadamard gate. No warning if input matrix is not in su2.\"\"\"\n    return np.array(\n        [\n            [su2[0, 0].real + 1j * su2[1, 0].imag, 1j * su2[0, 0].imag + su2[1, 0].real],\n            [1j * su2[0, 0].imag - su2[1, 0].real, su2[0, 0].real - 1j * su2[1, 0].imag],\n        ],\n        dtype=complex,\n    )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17e71"
  },
  "id": "2f05397b-8942-4bd2-a966-ffa8d3b7e36f",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.basicaer.test_qasm_simulator.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test QASM simulator.\"\"\"\n\nimport os\nimport unittest\nimport io\nfrom logging import StreamHandler, getLogger\nimport sys\n\nimport numpy as np\n\nfrom qiskit import execute\nfrom qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister\nfrom qiskit.compiler import transpile, assemble\nfrom qiskit.providers.basicaer import QasmSimulatorPy\nfrom qiskit.test import providers\n\n\nclass StreamHandlerRaiseException(StreamHandler):\n    \"\"\"Handler class that will raise an exception on formatting errors.\"\"\"\n\n    def handleError(self, record):\n        raise sys.exc_info()\n\n\nclass TestBasicAerQasmSimulator(providers.BackendTestCase):\n    \"\"\"Test the Basic qasm_simulator.\"\"\"\n\n    backend_cls = QasmSimulatorPy\n\n    def setUp(self):\n        super().setUp()\n\n        self.seed = 88\n        qasm_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), \"qasm\")\n        qasm_filename = os.path.join(qasm_dir, \"example.qasm\")\n        transpiled_circuit = QuantumCircuit.from_qasm_file(qasm_filename)\n        transpiled_circuit.name = \"test\"\n        transpiled_circuit = transpile(transpiled_circuit, backend=self.backend)\n        self.qobj = assemble(transpiled_circuit, shots=1000, seed_simulator=self.seed)\n        logger = getLogger()\n        self.addCleanup(logger.setLevel, logger.level)\n        logger.setLevel(\"DEBUG\")\n        self.log_output = io.StringIO()\n        logger.addHandler(StreamHandlerRaiseException(self.log_output))\n\n    def assertExecuteLog(self, log_msg):\n        \"\"\"Runs execute and check for logs containing specified message\"\"\"\n        shots = 100\n        qr = QuantumRegister(2, \"qr\")\n        cr = ClassicalRegister(4, \"cr\")\n        circuit = QuantumCircuit(qr, cr)\n        execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n        self.log_output.seek(0)\n        # Filter unrelated log lines\n        output_lines = self.log_output.readlines()\n        execute_log_lines = [x for x in output_lines if log_msg in x]\n        self.assertTrue(len(execute_log_lines) > 0)\n\n    def test_submission_log_time(self):\n        \"\"\"Check Total Job Submission Time is logged\"\"\"\n        self.assertExecuteLog(\"Total Job Submission Time\")\n\n    def test_qasm_simulator_single_shot(self):\n        \"\"\"Test single shot run.\"\"\"\n        shots = 1\n        self.qobj.config.shots = shots\n        result = self.backend.run(self.qobj).result()\n        self.assertEqual(result.success, True)\n\n    def test_measure_sampler_repeated_qubits(self):\n        \"\"\"Test measure sampler if qubits measured more than once.\"\"\"\n        shots = 100\n        qr = QuantumRegister(2, \"qr\")\n        cr = ClassicalRegister(4, \"cr\")\n        circuit = QuantumCircuit(qr, cr)\n        circuit.x(qr[1])\n        circuit.measure(qr[0], cr[0])\n        circuit.measure(qr[1], cr[1])\n        circuit.measure(qr[1], cr[2])\n        circuit.measure(qr[0], cr[3])\n        target = {\"0110\": shots}\n        job = execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n        result = job.result()\n        counts = result.get_counts(0)\n        self.assertEqual(counts, target)\n\n    def test_measure_sampler_single_qubit(self):\n        \"\"\"Test measure sampler if single-qubit is measured.\"\"\"\n        shots = 100\n        num_qubits = 5\n        qr = QuantumRegister(num_qubits, \"qr\")\n        cr = ClassicalRegister(1, \"cr\")\n\n        for qubit in range(num_qubits):\n            circuit = QuantumCircuit(qr, cr)\n            circuit.x(qr[qubit])\n            circuit.measure(qr[qubit], cr[0])\n            target = {\"1\": shots}\n            job = execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n            result = job.result()\n            counts = result.get_counts(0)\n            self.assertEqual(counts, target)\n\n    def test_measure_sampler_partial_qubit(self):\n        \"\"\"Test measure sampler if single-qubit is measured.\"\"\"\n        shots = 100\n        num_qubits = 5\n        qr = QuantumRegister(num_qubits, \"qr\")\n        cr = ClassicalRegister(4, \"cr\")\n\n        #             ░     ░     ░ ┌─┐ ░\n        # qr_0: ──────░─────░─────░─┤M├─░────\n        #       ┌───┐ ░     ░ ┌─┐ ░ └╥┘ ░\n        # qr_1: ┤ X ├─░─────░─┤M├─░──╫──░────\n        #       └───┘ ░     ░ └╥┘ ░  ║  ░\n        # qr_2: ──────░─────░──╫──░──╫──░────\n        #       ┌───┐ ░ ┌─┐ ░  ║  ░  ║  ░ ┌─┐\n        # qr_3: ┤ X ├─░─┤M├─░──╫──░──╫──░─┤M├\n        #       └───┘ ░ └╥┘ ░  ║  ░  ║  ░ └╥┘\n        # qr_4: ──────░──╫──░──╫──░──╫──░──╫─\n        #             ░  ║  ░  ║  ░  ║  ░  ║\n        # cr: 4/═════════╩═════╩═════╩═════╩═\n        #                1     0     2     3\n        circuit = QuantumCircuit(qr, cr)\n        circuit.x(qr[3])\n        circuit.x(qr[1])\n        circuit.barrier(qr)\n        circuit.measure(qr[3], cr[1])\n        circuit.barrier(qr)\n        circuit.measure(qr[1], cr[0])\n        circuit.barrier(qr)\n        circuit.measure(qr[0], cr[2])\n        circuit.barrier(qr)\n        circuit.measure(qr[3], cr[3])\n        target = {\"1011\": shots}\n        job = execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n        result = job.result()\n        counts = result.get_counts(0)\n        self.assertEqual(counts, target)\n\n    def test_qasm_simulator(self):\n        \"\"\"Test data counts output for single circuit run against reference.\"\"\"\n        result = self.backend.run(self.qobj).result()\n        shots = 1024\n        threshold = 0.04 * shots\n        counts = result.get_counts(\"test\")\n        target = {\n            \"100 100\": shots / 8,\n            \"011 011\": shots / 8,\n            \"101 101\": shots / 8,\n            \"111 111\": shots / 8,\n            \"000 000\": shots / 8,\n            \"010 010\": shots / 8,\n            \"110 110\": shots / 8,\n            \"001 001\": shots / 8,\n        }\n        self.assertDictAlmostEqual(counts, target, threshold)\n\n    def test_if_statement(self):\n        \"\"\"Test if statements.\"\"\"\n        shots = 100\n        qr = QuantumRegister(3, \"qr\")\n        cr = ClassicalRegister(3, \"cr\")\n\n        #       ┌───┐┌─┐          ┌─┐\n        # qr_0: ┤ X ├┤M├──────────┤M├──────\n        #       ├───┤└╥┘┌─┐       └╥┘┌─┐\n        # qr_1: ┤ X ├─╫─┤M├────────╫─┤M├───\n        #       └───┘ ║ └╥┘ ┌───┐  ║ └╥┘┌─┐\n        # qr_2: ──────╫──╫──┤ X ├──╫──╫─┤M├\n        #             ║  ║  └─╥─┘  ║  ║ └╥┘\n        #             ║  ║ ┌──╨──┐ ║  ║  ║\n        # cr: 3/══════╩══╩═╡ 0x3 ╞═╩══╩══╩═\n        #             0  1 └─────┘ 0  1  2\n        circuit_if_true = QuantumCircuit(qr, cr)\n        circuit_if_true.x(qr[0])\n        circuit_if_true.x(qr[1])\n        circuit_if_true.measure(qr[0], cr[0])\n        circuit_if_true.measure(qr[1], cr[1])\n        circuit_if_true.x(qr[2]).c_if(cr, 0x3)\n        circuit_if_true.measure(qr[0], cr[0])\n        circuit_if_true.measure(qr[1], cr[1])\n        circuit_if_true.measure(qr[2], cr[2])\n\n        #       ┌───┐┌─┐       ┌─┐\n        # qr_0: ┤ X ├┤M├───────┤M├──────\n        #       └┬─┬┘└╥┘       └╥┘┌─┐\n        # qr_1: ─┤M├──╫─────────╫─┤M├───\n        #        └╥┘  ║  ┌───┐  ║ └╥┘┌─┐\n        # qr_2: ──╫───╫──┤ X ├──╫──╫─┤M├\n        #         ║   ║  └─╥─┘  ║  ║ └╥┘\n        #         ║   ║ ┌──╨──┐ ║  ║  ║\n        # cr: 3/══╩═══╩═╡ 0x3 ╞═╩══╩══╩═\n        #         1   0 └─────┘ 0  1  2\n        circuit_if_false = QuantumCircuit(qr, cr)\n        circuit_if_false.x(qr[0])\n        circuit_if_false.measure(qr[0], cr[0])\n        circuit_if_false.measure(qr[1], cr[1])\n        circuit_if_false.x(qr[2]).c_if(cr, 0x3)\n        circuit_if_false.measure(qr[0], cr[0])\n        circuit_if_false.measure(qr[1], cr[1])\n        circuit_if_false.measure(qr[2], cr[2])\n        job = execute(\n            [circuit_if_true, circuit_if_false],\n            backend=self.backend,\n            shots=shots,\n            seed_simulator=self.seed,\n        )\n\n        result = job.result()\n        counts_if_true = result.get_counts(circuit_if_true)\n        counts_if_false = result.get_counts(circuit_if_false)\n        self.assertEqual(counts_if_true, {\"111\": 100})\n        self.assertEqual(counts_if_false, {\"001\": 100})\n\n    def test_bit_cif_crossaffect(self):\n        \"\"\"Test if bits in a classical register other than\n        the single conditional bit affect the conditioned operation.\"\"\"\n        #               ┌───┐          ┌─┐\n        # q0_0: ────────┤ H ├──────────┤M├\n        #       ┌───┐   └─╥─┘    ┌─┐   └╥┘\n        # q0_1: ┤ X ├─────╫──────┤M├────╫─\n        #       ├───┤     ║      └╥┘┌─┐ ║\n        # q0_2: ┤ X ├─────╫───────╫─┤M├─╫─\n        #       └───┘┌────╨─────┐ ║ └╥┘ ║\n        # c0: 3/═════╡ c0_0=0x1 ╞═╩══╩══╬═\n        #            └──────────┘ 1  2  ║\n        # c1: 1/════════════════════════╩═\n        #                               0\n        shots = 100\n        qr = QuantumRegister(3)\n        cr = ClassicalRegister(3)\n        cr1 = ClassicalRegister(1)\n        circuit = QuantumCircuit(qr, cr, cr1)\n        circuit.x([qr[1], qr[2]])\n        circuit.measure(qr[1], cr[1])\n        circuit.measure(qr[2], cr[2])\n        circuit.h(qr[0]).c_if(cr[0], True)\n        circuit.measure(qr[0], cr1[0])\n        job = execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n        result = job.result().get_counts()\n        target = {\"0 110\": 100}\n        self.assertEqual(result, target)\n\n    def test_teleport(self):\n        \"\"\"Test teleportation as in tutorials\"\"\"\n        #       ┌─────────┐          ┌───┐ ░ ┌─┐\n        # qr_0: ┤ Ry(π/4) ├───────■──┤ H ├─░─┤M├────────────────────\n        #       └──┬───┬──┘     ┌─┴─┐└───┘ ░ └╥┘┌─┐\n        # qr_1: ───┤ H ├─────■──┤ X ├──────░──╫─┤M├─────────────────\n        #          └───┘   ┌─┴─┐└───┘      ░  ║ └╥┘ ┌───┐  ┌───┐ ┌─┐\n        # qr_2: ───────────┤ X ├───────────░──╫──╫──┤ Z ├──┤ X ├─┤M├\n        #                  └───┘           ░  ║  ║  └─╥─┘  └─╥─┘ └╥┘\n        #                                     ║  ║ ┌──╨──┐   ║    ║\n        # cr0: 1/═════════════════════════════╩══╬═╡ 0x1 ╞═══╬════╬═\n        #                                     0  ║ └─────┘┌──╨──┐ ║\n        # cr1: 1/════════════════════════════════╩════════╡ 0x1 ╞═╬═\n        #                                        0        └─────┘ ║\n        # cr2: 1/═════════════════════════════════════════════════╩═\n        #                                                         0\n        self.log.info(\"test_teleport\")\n        pi = np.pi\n        shots = 2000\n        qr = QuantumRegister(3, \"qr\")\n        cr0 = ClassicalRegister(1, \"cr0\")\n        cr1 = ClassicalRegister(1, \"cr1\")\n        cr2 = ClassicalRegister(1, \"cr2\")\n        circuit = QuantumCircuit(qr, cr0, cr1, cr2, name=\"teleport\")\n        circuit.h(qr[1])\n        circuit.cx(qr[1], qr[2])\n        circuit.ry(pi / 4, qr[0])\n        circuit.cx(qr[0], qr[1])\n        circuit.h(qr[0])\n        circuit.barrier(qr)\n        circuit.measure(qr[0], cr0[0])\n        circuit.measure(qr[1], cr1[0])\n        circuit.z(qr[2]).c_if(cr0, 1)\n        circuit.x(qr[2]).c_if(cr1, 1)\n        circuit.measure(qr[2], cr2[0])\n        job = execute(circuit, backend=self.backend, shots=shots, seed_simulator=self.seed)\n        results = job.result()\n        data = results.get_counts(\"teleport\")\n        alice = {\n            \"00\": data[\"0 0 0\"] + data[\"1 0 0\"],\n            \"01\": data[\"0 1 0\"] + data[\"1 1 0\"],\n            \"10\": data[\"0 0 1\"] + data[\"1 0 1\"],\n            \"11\": data[\"0 1 1\"] + data[\"1 1 1\"],\n        }\n        bob = {\n            \"0\": data[\"0 0 0\"] + data[\"0 1 0\"] + data[\"0 0 1\"] + data[\"0 1 1\"],\n            \"1\": data[\"1 0 0\"] + data[\"1 1 0\"] + data[\"1 0 1\"] + data[\"1 1 1\"],\n        }\n        self.log.info(\"test_teleport: circuit:\")\n        self.log.info(circuit.qasm())\n        self.log.info(\"test_teleport: data %s\", data)\n        self.log.info(\"test_teleport: alice %s\", alice)\n        self.log.info(\"test_teleport: bob %s\", bob)\n        alice_ratio = 1 / np.tan(pi / 8) ** 2\n        bob_ratio = bob[\"0\"] / float(bob[\"1\"])\n        error = abs(alice_ratio - bob_ratio) / alice_ratio\n        self.log.info(\"test_teleport: relative error = %s\", error)\n        self.assertLess(error, 0.05)\n\n    def test_memory(self):\n        \"\"\"Test memory.\"\"\"\n        #       ┌───┐        ┌─┐\n        # qr_0: ┤ H ├──■─────┤M├───\n        #       └───┘┌─┴─┐   └╥┘┌─┐\n        # qr_1: ─────┤ X ├────╫─┤M├\n        #            └┬─┬┘    ║ └╥┘\n        # qr_2: ──────┤M├─────╫──╫─\n        #       ┌───┐ └╥┘ ┌─┐ ║  ║\n        # qr_3: ┤ X ├──╫──┤M├─╫──╫─\n        #       └───┘  ║  └╥┘ ║  ║\n        # cr0: 2/══════╬═══╬══╩══╩═\n        #              ║   ║  0  1\n        #              ║   ║\n        # cr1: 2/══════╩═══╩═══════\n        #              0   1\n        qr = QuantumRegister(4, \"qr\")\n        cr0 = ClassicalRegister(2, \"cr0\")\n        cr1 = ClassicalRegister(2, \"cr1\")\n        circ = QuantumCircuit(qr, cr0, cr1)\n        circ.h(qr[0])\n        circ.cx(qr[0], qr[1])\n        circ.x(qr[3])\n        circ.measure(qr[0], cr0[0])\n        circ.measure(qr[1], cr0[1])\n        circ.measure(qr[2], cr1[0])\n        circ.measure(qr[3], cr1[1])\n\n        shots = 50\n        job = execute(circ, backend=self.backend, shots=shots, memory=True)\n        result = job.result()\n        memory = result.get_memory()\n        self.assertEqual(len(memory), shots)\n        for mem in memory:\n            self.assertIn(mem, [\"10 00\", \"10 11\"])\n\n    def test_unitary(self):\n        \"\"\"Test unitary gate instruction\"\"\"\n        max_qubits = 4\n        x_mat = np.array([[0, 1], [1, 0]])\n        # Test 1 to max_qubits for random n-qubit unitary gate\n        for i in range(max_qubits):\n            num_qubits = i + 1\n            # Apply X gate to all qubits\n            multi_x = x_mat\n            for _ in range(i):\n                multi_x = np.kron(multi_x, x_mat)\n            # Target counts\n            shots = 1024\n            target_counts = {num_qubits * \"1\": shots}\n            # Test circuit\n            qr = QuantumRegister(num_qubits, \"qr\")\n            cr = ClassicalRegister(num_qubits, \"cr\")\n            circuit = QuantumCircuit(qr, cr)\n            circuit.unitary(multi_x, qr)\n            circuit.measure(qr, cr)\n            job = execute(circuit, self.backend, shots=shots)\n            result = job.result()\n            counts = result.get_counts(0)\n            self.assertEqual(counts, target_counts)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17e76"
  },
  "id": "36227a03-ac7d-4bc3-90a6-65d2a120274d",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.extensions.unitary.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nArbitrary unitary circuit instruction.\n\"\"\"\n\nimport numpy\n\nfrom qiskit.circuit import Gate, ControlledGate\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister, Qubit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit._utils import _compute_control_matrix\nfrom qiskit.circuit.quantumcircuit import _qasm_escape_gate_name\nfrom qiskit.circuit.library.standard_gates import U3Gate\nfrom qiskit.extensions.quantum_initializer import isometry\nfrom qiskit.quantum_info.operators.predicates import matrix_equal\nfrom qiskit.quantum_info.operators.predicates import is_unitary_matrix\nfrom qiskit.quantum_info.synthesis.one_qubit_decompose import OneQubitEulerDecomposer\nfrom qiskit.quantum_info.synthesis.two_qubit_decompose import two_qubit_cnot_decompose\nfrom qiskit.extensions.exceptions import ExtensionError\n\n_DECOMPOSER1Q = OneQubitEulerDecomposer(\"U3\")\n\n\nclass UnitaryGate(Gate):\n    \"\"\"Class quantum gates specified by a unitary matrix.\n\n    Example:\n\n        We can create a unitary gate from a unitary matrix then add it\n        to a quantum circuit. The matrix can also be directly applied\n        to the quantum circuit, see :meth:`~qiskit.QuantumCircuit.unitary`.\n\n        .. code-block:: python\n\n            from qiskit import QuantumCircuit\n            from qiskit.extensions import UnitaryGate\n\n            matrix = [[0, 0, 0, 1],\n                      [0, 0, 1, 0],\n                      [1, 0, 0, 0],\n                      [0, 1, 0, 0]]\n            gate = UnitaryGate(matrix)\n\n            circuit = QuantumCircuit(2)\n            circuit.append(gate, [0, 1])\n    \"\"\"\n\n    def __init__(self, data, label=None):\n        \"\"\"Create a gate from a numeric unitary matrix.\n\n        Args:\n            data (matrix or Operator): unitary operator.\n            label (str): unitary name for backend [Default: None].\n\n        Raises:\n            ExtensionError: if input data is not an N-qubit unitary operator.\n        \"\"\"\n        if hasattr(data, \"to_matrix\"):\n            # If input is Gate subclass or some other class object that has\n            # a to_matrix method this will call that method.\n            data = data.to_matrix()\n        elif hasattr(data, \"to_operator\"):\n            # If input is a BaseOperator subclass this attempts to convert\n            # the object to an Operator so that we can extract the underlying\n            # numpy matrix from `Operator.data`.\n            data = data.to_operator().data\n        # Convert to numpy array in case not already an array\n        data = numpy.array(data, dtype=complex)\n        # Check input is unitary\n        if not is_unitary_matrix(data):\n            raise ExtensionError(\"Input matrix is not unitary.\")\n        # Check input is N-qubit matrix\n        input_dim, output_dim = data.shape\n        num_qubits = int(numpy.log2(input_dim))\n        if input_dim != output_dim or 2**num_qubits != input_dim:\n            raise ExtensionError(\"Input matrix is not an N-qubit operator.\")\n\n        self._qasm_name = None\n        self._qasm_definition = None\n        # Store instruction params\n        super().__init__(\"unitary\", num_qubits, [data], label=label)\n\n    def __eq__(self, other):\n        if not isinstance(other, UnitaryGate):\n            return False\n        if self.label != other.label:\n            return False\n        # Should we match unitaries as equal if they are equal\n        # up to global phase?\n        return matrix_equal(self.params[0], other.params[0], ignore_phase=True)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return matrix for the unitary.\"\"\"\n        # pylint: disable=unused-argument\n        return self.params[0]\n\n    def inverse(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return self.adjoint()\n\n    def conjugate(self):\n        \"\"\"Return the conjugate of the unitary.\"\"\"\n        return UnitaryGate(numpy.conj(self.to_matrix()))\n\n    def adjoint(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return self.transpose().conjugate()\n\n    def transpose(self):\n        \"\"\"Return the transpose of the unitary.\"\"\"\n        return UnitaryGate(numpy.transpose(self.to_matrix()))\n\n    def _define(self):\n        \"\"\"Calculate a subcircuit that implements this unitary.\"\"\"\n        if self.num_qubits == 1:\n            q = QuantumRegister(1, \"q\")\n            qc = QuantumCircuit(q, name=self.name)\n            theta, phi, lam, global_phase = _DECOMPOSER1Q.angles_and_phase(self.to_matrix())\n            qc._append(U3Gate(theta, phi, lam), [q[0]], [])\n            qc.global_phase = global_phase\n            self.definition = qc\n        elif self.num_qubits == 2:\n            self.definition = two_qubit_cnot_decompose(self.to_matrix())\n        else:\n            from qiskit.quantum_info.synthesis.qsd import (  # pylint: disable=cyclic-import\n                qs_decomposition,\n            )\n\n            self.definition = qs_decomposition(self.to_matrix())\n\n    def control(self, num_ctrl_qubits=1, label=None, ctrl_state=None):\n        \"\"\"Return controlled version of gate\n\n        Args:\n            num_ctrl_qubits (int): number of controls to add to gate (default=1)\n            label (str): optional gate label\n            ctrl_state (int or str or None): The control state in decimal or as a\n                bit string (e.g. '1011'). If None, use 2**num_ctrl_qubits-1.\n\n        Returns:\n            UnitaryGate: controlled version of gate.\n\n        Raises:\n            QiskitError: Invalid ctrl_state.\n            ExtensionError: Non-unitary controlled unitary.\n        \"\"\"\n        mat = self.to_matrix()\n        cmat = _compute_control_matrix(mat, num_ctrl_qubits, ctrl_state=None)\n        iso = isometry.Isometry(cmat, 0, 0)\n        return ControlledGate(\n            \"c-unitary\",\n            num_qubits=self.num_qubits + num_ctrl_qubits,\n            params=[mat],\n            label=label,\n            num_ctrl_qubits=num_ctrl_qubits,\n            definition=iso.definition,\n            ctrl_state=ctrl_state,\n            base_gate=self.copy(),\n        )\n\n    def qasm(self):\n        \"\"\"The qasm for a custom unitary gate\n        This is achieved by adding a custom gate that corresponds to the definition\n        of this gate. It gives the gate a random name if one hasn't been given to it.\n        \"\"\"\n\n        # give this unitary a name\n        self._qasm_name = (\n            _qasm_escape_gate_name(self.label) if self.label else \"unitary\" + str(id(self))\n        )\n\n        qubit_to_qasm = {bit: f\"p{i}\" for i, bit in enumerate(self.definition.qubits)}\n        gates_def = \"\"\n        for instruction in self.definition.data:\n\n            curr_gate = \"\\t{} {};\\n\".format(\n                instruction.operation.qasm(),\n                \",\".join(qubit_to_qasm[qubit] for qubit in instruction.qubits),\n            )\n            gates_def += curr_gate\n\n        # name of gate + params + {definition}\n        overall = (\n            \"gate \"\n            + self._qasm_name\n            + \" \"\n            + \",\".join(qubit_to_qasm[qubit] for qubit in self.definition.qubits)\n            + \" {\\n\"\n            + gates_def\n            + \"}\"\n        )\n\n        self._qasm_definition = overall\n\n        return self._qasmif(self._qasm_name)\n\n    def validate_parameter(self, parameter):\n        \"\"\"Unitary gate parameter has to be an ndarray.\"\"\"\n        if isinstance(parameter, numpy.ndarray):\n            return parameter\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} in gate {self.name}\")\n\n\ndef unitary(self, obj, qubits, label=None):\n    \"\"\"Apply unitary gate specified by ``obj`` to ``qubits``.\n\n    Example:\n\n        Apply a gate specified by a unitary matrix to a quantum circuit\n\n        .. code-block:: python\n\n            from qiskit import QuantumCircuit\n            matrix = [[0, 0, 0, 1],\n                      [0, 0, 1, 0],\n                      [1, 0, 0, 0],\n                      [0, 1, 0, 0]]\n            circuit = QuantumCircuit(2)\n            circuit.unitary(matrix, [0, 1])\n    \"\"\"\n    gate = UnitaryGate(obj, label=label)\n    if isinstance(qubits, QuantumRegister):\n        qubits = qubits[:]\n    # for single qubit unitary gate, allow an 'int' or a 'list of ints' as qubits.\n    if gate.num_qubits == 1:\n        if isinstance(qubits, (int, Qubit)) or len(qubits) > 1:\n            qubits = [qubits]\n    return self.append(gate, qubits, [])\n\n\nQuantumCircuit.unitary = unitary\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17e88"
  },
  "id": "b526a13b-c9fb-459d-88c1-180073080f54",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.s.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The S, Sdg, CS and CSdg gates.\"\"\"\n\nfrom typing import Optional, Union\nimport numpy\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\n\nclass SGate(Gate):\n    r\"\"\"Single qubit S gate (Z**0.5).\n\n    It induces a :math:`\\pi/2` phase, and is sometimes called the P gate (phase).\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.s` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        S = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ S ├\n             └───┘\n\n    Equivalent to a :math:`\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new S gate.\"\"\"\n        super().__init__(\"s\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate s a { u1(pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of S (SdgGate).\"\"\"\n        return SdgGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the S gate.\"\"\"\n        return numpy.array([[1, 0], [0, 1j]], dtype=dtype)\n\n\nclass SdgGate(Gate):\n    r\"\"\"Single qubit S-adjoint gate (~Z**0.5).\n\n    It induces a :math:`-\\pi/2` phase.\n\n    This is a Clifford gate and a square-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.sdg` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Sdg = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -i\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────┐\n        q_0: ┤ Sdg ├\n             └─────┘\n\n    Equivalent to a :math:`-\\pi/2` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Sdg gate.\"\"\"\n        super().__init__(\"sdg\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate sdg a { u1(-pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(-pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse of Sdg (SGate).\"\"\"\n        return SGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the Sdg gate.\"\"\"\n        return numpy.array([[1, 0], [0, -1j]], dtype=dtype)\n\n\nclass CSGate(ControlledGate):\n    r\"\"\"Controlled-S gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cs` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ──■──\n             ┌─┴─┐\n        q_1: ┤ S ├\n             └───┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & i\n            \\end{pmatrix}\n    \"\"\"\n    # Define class constants. This saves future allocation time.\n    _matrix1 = numpy.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1j],\n        ]\n    )\n    _matrix0 = numpy.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1j, 0],\n            [0, 0, 0, 1],\n        ]\n    )\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CS gate.\"\"\"\n        super().__init__(\n            \"cs\", 2, [], label=label, num_ctrl_qubits=1, ctrl_state=ctrl_state, base_gate=SGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cs a,b { h b; cp(pi/2) a,b; h b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from .p import CPhaseGate\n\n        self.definition = CPhaseGate(theta=pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSGate (CSdgGate).\"\"\"\n        return CSdgGate(ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CS gate.\"\"\"\n        mat = self._matrix1 if self.ctrl_state == 1 else self._matrix0\n        if dtype is not None:\n            return numpy.asarray(mat, dtype=dtype)\n        return mat\n\n\nclass CSdgGate(ControlledGate):\n    r\"\"\"Controlled-S^\\dagger gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.csdg` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ───■───\n             ┌──┴──┐\n        q_1: ┤ Sdg ├\n             └─────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        CS^\\dagger \\ q_0, q_1 =\n        I \\otimes |0 \\rangle\\langle 0| + S^\\dagger \\otimes |1 \\rangle\\langle 1|  =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -i\n            \\end{pmatrix}\n    \"\"\"\n    # Define class constants. This saves future allocation time.\n    _matrix1 = numpy.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, -1j],\n        ]\n    )\n    _matrix0 = numpy.array(\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1j, 0],\n            [0, 0, 0, 1],\n        ]\n    )\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CSdg gate.\"\"\"\n        super().__init__(\n            \"csdg\",\n            2,\n            [],\n            label=label,\n            num_ctrl_qubits=1,\n            ctrl_state=ctrl_state,\n            base_gate=SdgGate(),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate csdg a,b { h b; cp(-pi/2) a,b; h b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from .p import CPhaseGate\n\n        self.definition = CPhaseGate(theta=-pi / 2).definition\n\n    def inverse(self):\n        \"\"\"Return inverse of CSdgGate (CSGate).\"\"\"\n        return CSGate(ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CSdg gate.\"\"\"\n        mat = self._matrix1 if self.ctrl_state == 1 else self._matrix0\n        if dtype is not None:\n            return numpy.asarray(mat, dtype=dtype)\n        return mat\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5ca9c1f7ee332e17eb4"
  },
  "id": "a9c98f85-47a1-4187-8aed-93347fa4d05b",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.basicaer.test_basicaer_qobj_headers.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Tests for all BasicAer  simulators.\"\"\"\n\nimport io\nfrom logging import StreamHandler, getLogger\nimport sys\n\nfrom qiskit import BasicAer\nfrom qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister\nfrom qiskit.compiler import transpile\nfrom qiskit.compiler import assemble\nfrom qiskit.qobj import QobjHeader\nfrom qiskit.test import QiskitTestCase\n\n\nclass StreamHandlerRaiseException(StreamHandler):\n    \"\"\"Handler class that will raise an exception on formatting errors.\"\"\"\n\n    def handleError(self, record):\n        raise sys.exc_info()\n\n\nclass TestBasicAerQobj(QiskitTestCase):\n    \"\"\"Tests for all the Terra simulators.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        logger = getLogger()\n        self.addCleanup(logger.setLevel, logger.level)\n        logger.setLevel(\"DEBUG\")\n\n        self.output = io.StringIO()\n        logger.addHandler(StreamHandlerRaiseException(self.output))\n\n        qr = QuantumRegister(1)\n        cr = ClassicalRegister(1)\n        self.qc1 = QuantumCircuit(qr, cr, name=\"circuit0\")\n        self.qc1.h(qr[0])\n\n    def test_qobj_headers_in_result(self):\n        \"\"\"Test that the qobj headers are passed onto the results.\"\"\"\n        custom_qobj_header = {\"x\": 1, \"y\": [1, 2, 3], \"z\": {\"a\": 4}}\n\n        for backend in BasicAer.backends():\n            with self.subTest(backend=backend):\n                new_circ = transpile(self.qc1, backend=backend)\n                qobj = assemble(new_circ, shots=1024)\n\n                # Update the Qobj header.\n                qobj.header = QobjHeader.from_dict(custom_qobj_header)\n                # Update the Qobj.experiment header.\n                qobj.experiments[0].header.some_field = \"extra info\"\n\n                result = backend.run(qobj).result()\n                self.assertEqual(result.header.to_dict(), custom_qobj_header)\n                self.assertEqual(result.results[0].header.some_field, \"extra info\")\n",
  "circuit": "[[\"H\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 778,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\"]]"
        },
        "timestamp": "2023-11-26T23:00:40.288+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[\"H\"]]"
        }
      }
    ],
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17ec0"
  },
  "id": "ade16216-b0cf-4248-ab0f-31a7e5ebec97",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.transpiler.test_layout_transformation.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the LayoutTransformation pass\"\"\"\n\nimport unittest\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.transpiler import CouplingMap, Layout\nfrom qiskit.transpiler.passes import LayoutTransformation\n\n\nclass TestLayoutTransformation(QiskitTestCase):\n    \"\"\"\n    Tests the LayoutTransformation pass.\n    \"\"\"\n\n    def test_three_qubit(self):\n        \"\"\"Test if the permutation {0->2,1->0,2->1} is implemented correctly.\"\"\"\n        v = QuantumRegister(3, \"v\")  # virtual qubits\n        coupling = CouplingMap([[0, 1], [1, 2]])\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2})\n        to_layout = Layout({v[0]: 2, v[1]: 0, v[2]: 1})\n        ltpass = LayoutTransformation(\n            coupling_map=coupling, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(3)\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(3)\n        expected.swap(1, 0)\n        expected.swap(1, 2)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n    def test_four_qubit(self):\n        \"\"\"Test if the permutation {0->3,1->0,2->1,3->2} is implemented correctly.\"\"\"\n        v = QuantumRegister(4, \"v\")  # virtual qubits\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2, v[3]: 3})\n        to_layout = Layout({v[0]: 3, v[1]: 0, v[2]: 1, v[3]: 2})\n        ltpass = LayoutTransformation(\n            coupling_map=coupling, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(4)  # input (empty) physical circuit\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(4)\n        expected.swap(1, 0)\n        expected.swap(1, 2)\n        expected.swap(2, 3)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n    def test_full_connected_coupling_map(self):\n        \"\"\"Test if the permutation {0->3,1->0,2->1,3->2} in a fully connected map.\"\"\"\n        v = QuantumRegister(4, \"v\")  # virtual qubits\n        from_layout = Layout({v[0]: 0, v[1]: 1, v[2]: 2, v[3]: 3})\n        to_layout = Layout({v[0]: 3, v[1]: 0, v[2]: 1, v[3]: 2})\n        ltpass = LayoutTransformation(\n            coupling_map=None, from_layout=from_layout, to_layout=to_layout, seed=42\n        )\n        qc = QuantumCircuit(4)  # input (empty) physical circuit\n        dag = circuit_to_dag(qc)\n        output_dag = ltpass.run(dag)\n\n        expected = QuantumCircuit(4)\n        expected.swap(1, 0)\n        expected.swap(2, 1)\n        expected.swap(3, 2)\n\n        self.assertEqual(circuit_to_dag(expected), output_dag)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[], [], [], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], [], [], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17ec1"
  },
  "id": "c13346ee-6226-44a1-ae1d-638bb7ac291f",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.transpiler.test_pass_call.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test calling passes (passmanager-less)\"\"\"\n\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.circuit.library import ZGate\nfrom qiskit.transpiler.passes import Unroller\nfrom qiskit.test import QiskitTestCase\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.transpiler import PropertySet\nfrom ._dummy_passes import PassD_TP_NR_NP, PassE_AP_NR_NP, PassN_AP_NR_NP\n\n\nclass TestPassCall(QiskitTestCase):\n    \"\"\"Test calling passes (passmanager-less).\"\"\"\n\n    def assertMessageLog(self, context, messages):\n        \"\"\"Checks the log messages\"\"\"\n        self.assertEqual([record.message for record in context.records], messages)\n\n    def test_transformation_pass(self):\n        \"\"\"Call a transformation pass without a scheduler\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n\n        pass_d = PassD_TP_NR_NP(argument1=[1, 2])\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_d(circuit)\n\n        self.assertMessageLog(cm, [\"run transformation pass PassD_TP_NR_NP\", \"argument [1, 2]\"])\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_dict(self):\n        \"\"\"Call an analysis pass without a scheduler (property_set dict)\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = {\"another_property\": \"another_value\"}\n\n        pass_e = PassE_AP_NR_NP(\"value\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(cm, [\"run analysis pass PassE_AP_NR_NP\", \"set property as value\"])\n        self.assertEqual(property_set, {\"another_property\": \"another_value\", \"property\": \"value\"})\n        self.assertIsInstance(property_set, dict)\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_property_set(self):\n        \"\"\"Call an analysis pass without a scheduler (PropertySet dict)\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = PropertySet({\"another_property\": \"another_value\"})\n\n        pass_e = PassE_AP_NR_NP(\"value\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(cm, [\"run analysis pass PassE_AP_NR_NP\", \"set property as value\"])\n        self.assertEqual(\n            property_set, PropertySet({\"another_property\": \"another_value\", \"property\": \"value\"})\n        )\n        self.assertIsInstance(property_set, PropertySet)\n        self.assertEqual(circuit, result)\n\n    def test_analysis_pass_remove_property(self):\n        \"\"\"Call an analysis pass that removes a property without a scheduler\"\"\"\n        qr = QuantumRegister(1, \"qr\")\n        circuit = QuantumCircuit(qr, name=\"MyCircuit\")\n        property_set = {\"to remove\": \"value to remove\", \"to none\": \"value to none\"}\n\n        pass_e = PassN_AP_NR_NP(\"to remove\", \"to none\")\n        with self.assertLogs(\"LocalLogger\", level=\"INFO\") as cm:\n            result = pass_e(circuit, property_set)\n\n        self.assertMessageLog(\n            cm,\n            [\n                \"run analysis pass PassN_AP_NR_NP\",\n                \"property to remove deleted\",\n                \"property to none noned\",\n            ],\n        )\n        self.assertEqual(property_set, PropertySet({\"to none\": None}))\n        self.assertIsInstance(property_set, dict)\n        self.assertEqual(circuit, result)\n\n    def test_error_unknown_defn_unroller_pass(self):\n        \"\"\"Check for proper error message when unroller cannot find the definition\n        of a gate.\"\"\"\n        circuit = ZGate().control(2).definition\n        basis = [\"u1\", \"u2\", \"u3\", \"cx\"]\n        unroller = Unroller(basis)\n        with self.assertRaises(QiskitError) as cm:\n            unroller(circuit)\n        exp_msg = (\n            \"Error decomposing node of instruction 'p': 'NoneType' object has no\"\n            \" attribute 'global_phase'. Unable to define instruction 'u' in the basis.\"\n        )\n        self.assertEqual(exp_msg, cm.exception.message)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f16"
  },
  "id": "c978cfff-aa90-4356-b3be-c3da1ff25742",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.circuit.test_hamiltonian_gate.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\" HamiltonianGate tests \"\"\"\n\nimport numpy as np\nfrom numpy.testing import assert_allclose\n\n\nimport qiskit\nfrom qiskit.extensions.hamiltonian_gate import HamiltonianGate, UnitaryGate\nfrom qiskit.extensions.exceptions import ExtensionError\nfrom qiskit.test import QiskitTestCase\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import Operator\nfrom qiskit.converters import circuit_to_dag, dag_to_circuit\n\n\nclass TestHamiltonianGate(QiskitTestCase):\n    \"\"\"Tests for the HamiltonianGate class.\"\"\"\n\n    def test_set_matrix(self):\n        \"\"\"Test instantiation\"\"\"\n        hamiltonian = HamiltonianGate([[0, 1], [1, 0]], 1)\n        self.assertEqual(hamiltonian.num_qubits, 1)\n\n    def test_set_matrix_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        with self.assertRaises(ExtensionError):\n            HamiltonianGate([[1, 0], [1, 1]], 1)\n\n    def test_complex_time_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        with self.assertRaises(ExtensionError):\n            HamiltonianGate([[1, 0], [1, 1]], 1j)\n\n    def test_conjugate(self):\n        \"\"\"test conjugate\"\"\"\n        ham = HamiltonianGate([[0, 1j], [-1j, 2]], np.pi / 4)\n        np.testing.assert_array_almost_equal(ham.conjugate().to_matrix(), np.conj(ham.to_matrix()))\n\n    def test_transpose(self):\n        \"\"\"test transpose\"\"\"\n        ham = HamiltonianGate([[15, 1j], [-1j, -2]], np.pi / 7)\n        np.testing.assert_array_almost_equal(\n            ham.transpose().to_matrix(), np.transpose(ham.to_matrix())\n        )\n\n    def test_adjoint(self):\n        \"\"\"test adjoint operation\"\"\"\n        ham = HamiltonianGate([[3, 4j], [-4j, -0.2]], np.pi * 0.143)\n        np.testing.assert_array_almost_equal(\n            ham.adjoint().to_matrix(), np.transpose(np.conj(ham.to_matrix()))\n        )\n\n\nclass TestHamiltonianCircuit(QiskitTestCase):\n    \"\"\"Hamiltonian gate circuit tests.\"\"\"\n\n    def test_1q_hamiltonian(self):\n        \"\"\"test 1 qubit hamiltonian\"\"\"\n        qr = QuantumRegister(1, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = np.zeros((2, 2))\n        qc.x(qr[0])\n        theta = Parameter(\"theta\")\n        qc.append(HamiltonianGate(matrix, theta), [qr[0]])\n        qc = qc.bind_parameters({theta: 1})\n\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        dag_nodes = dag.named_nodes(\"hamiltonian\")\n        self.assertTrue(len(dag_nodes) == 1)\n        dnode = dag_nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, tuple(qc.qubits))\n        assert_allclose(dnode.op.to_matrix(), np.eye(2))\n\n    def test_error_on_qasm(self):\n        \"\"\"test that an error is thrown if qc.qasm() is called.\"\"\"\n        qr = QuantumRegister(1, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = np.zeros((2, 2))\n        qc.hamiltonian(operator=matrix, time=1, qubits=qr[0])\n\n        with self.assertRaises(ExtensionError):\n            qc.qasm()\n\n    def test_2q_hamiltonian(self):\n        \"\"\"test 2 qubit hamiltonian\"\"\"\n        qr = QuantumRegister(2)\n        cr = ClassicalRegister(2)\n        qc = QuantumCircuit(qr, cr)\n        matrix = Operator.from_label(\"XY\")\n        qc.x(qr[0])\n        theta = Parameter(\"theta\")\n        uni2q = HamiltonianGate(matrix, theta)\n        qc.append(uni2q, [qr[0], qr[1]])\n        qc2 = qc.bind_parameters({theta: -np.pi / 2})\n        dag = circuit_to_dag(qc2)\n        nodes = dag.two_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1]))\n        # Equality based on Pauli exponential identity\n        np.testing.assert_array_almost_equal(dnode.op.to_matrix(), 1j * matrix.data)\n        qc3 = dag_to_circuit(dag)\n        self.assertEqual(qc2, qc3)\n\n    def test_3q_hamiltonian(self):\n        \"\"\"test 3 qubit hamiltonian on non-consecutive bits\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        qc.x(qr[0])\n        matrix = Operator.from_label(\"XZY\")\n        theta = Parameter(\"theta\")\n        uni3q = HamiltonianGate(matrix, theta)\n        qc.append(uni3q, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        # test of text drawer\n        self.log.info(qc)\n        qc = qc.bind_parameters({theta: -np.pi / 2})\n        dag = circuit_to_dag(qc)\n        nodes = dag.multi_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, HamiltonianGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1], qr[3]))\n        np.testing.assert_almost_equal(dnode.op.to_matrix(), 1j * matrix.data)\n\n    def test_qobj_with_hamiltonian(self):\n        \"\"\"test qobj output with hamiltonian\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        qc.rx(np.pi / 4, qr[0])\n        matrix = Operator.from_label(\"XIZ\")\n        theta = Parameter(\"theta\")\n        uni = HamiltonianGate(matrix, theta, label=\"XIZ\")\n        qc.append(uni, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        qc = qc.bind_parameters({theta: np.pi / 2})\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[1]\n        self.assertEqual(instr.name, \"hamiltonian\")\n        # Also test label\n        self.assertEqual(instr.label, \"XIZ\")\n        np.testing.assert_array_almost_equal(\n            np.array(instr.params[0]).astype(np.complex64), matrix.data\n        )\n\n    def test_decomposes_into_correct_unitary(self):\n        \"\"\"test 2 qubit hamiltonian\"\"\"\n        qc = QuantumCircuit(2)\n        matrix = Operator.from_label(\"XY\")\n        theta = Parameter(\"theta\")\n        uni2q = HamiltonianGate(matrix, theta)\n        qc.append(uni2q, [0, 1])\n        qc = qc.bind_parameters({theta: -np.pi / 2}).decompose()\n        decomposed_ham = qc.data[0].operation\n        self.assertEqual(decomposed_ham, UnitaryGate(Operator.from_label(\"XY\")))\n",
  "circuit": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0.25
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 782,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"RX\"], [], [\"X\"], [{\"CONTROL\": 2}]]"
        },
        "timestamp": "2023-11-26T23:07:38.505+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f23"
  },
  "id": "f069ee2e-c7e3-413e-9c41-5a3de0ef6d3d",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.qobj.test_qobj_identifiers.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n# pylint: disable=missing-function-docstring\n\n\"\"\"Non-string identifiers for circuit and record identifiers test\"\"\"\n\nimport unittest\n\nfrom qiskit.circuit import ClassicalRegister, QuantumCircuit, QuantumRegister\nfrom qiskit.compiler import assemble\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestQobjIdentifiers(QiskitTestCase):\n    \"\"\"Check the Qobj compiled for different backends create names properly\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        qr = QuantumRegister(2, name=\"qr2\")\n        cr = ClassicalRegister(2, name=None)\n        qc = QuantumCircuit(qr, cr, name=\"qc10\")\n        qc.h(qr[0])\n        qc.measure(qr[0], cr[0])\n        self.qr_name = qr.name\n        self.cr_name = cr.name\n        self.circuits = [qc]\n\n    def test_builtin_qasm_simulator_py(self):\n        qobj = assemble(self.circuits)\n        exp = qobj.experiments[0]\n        self.assertIn(self.qr_name, map(lambda x: x[0], exp.header.qubit_labels))\n        self.assertIn(self.cr_name, map(lambda x: x[0], exp.header.clbit_labels))\n\n    def test_builtin_qasm_simulator(self):\n        qobj = assemble(self.circuits)\n        exp = qobj.experiments[0]\n        self.assertIn(self.qr_name, map(lambda x: x[0], exp.header.qubit_labels))\n        self.assertIn(self.cr_name, map(lambda x: x[0], exp.header.clbit_labels))\n\n    def test_builtin_unitary_simulator_py(self):\n        qobj = assemble(self.circuits)\n        exp = qobj.experiments[0]\n        self.assertIn(self.qr_name, map(lambda x: x[0], exp.header.qubit_labels))\n        self.assertIn(self.cr_name, map(lambda x: x[0], exp.header.clbit_labels))\n\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)\n",
  "circuit": "[[\"H\", \"MEASURE\"], []]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 783,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"H\", \"MEASURE\"], []]"
        },
        "timestamp": "2023-11-26T23:09:14.525+00:00"
      },
      "value": 0.5
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f32"
  },
  "id": "3699fb7b-d21a-42cd-9337-6dabd38becac",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.circuit.test_unitary.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\" UnitaryGate tests \"\"\"\n\nimport json\nimport numpy\nfrom numpy.testing import assert_allclose\n\nimport qiskit\nfrom qiskit.extensions.unitary import UnitaryGate\nfrom qiskit.test import QiskitTestCase\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.transpiler import PassManager\nfrom qiskit.converters import circuit_to_dag, dag_to_circuit\nfrom qiskit.quantum_info.random import random_unitary\nfrom qiskit.quantum_info.operators import Operator\nfrom qiskit.transpiler.passes import CXCancellation\n\n\nclass TestUnitaryGate(QiskitTestCase):\n    \"\"\"Tests for the Unitary class.\"\"\"\n\n    def test_set_matrix(self):\n        \"\"\"Test instantiation\"\"\"\n        try:\n            UnitaryGate([[0, 1], [1, 0]])\n        # pylint: disable=broad-except\n        except Exception as err:\n            self.fail(f\"unexpected exception in init of Unitary: {err}\")\n\n    def test_set_matrix_raises(self):\n        \"\"\"test non-unitary\"\"\"\n        try:\n            UnitaryGate([[1, 1], [1, 0]])\n        # pylint: disable=broad-except\n        except Exception:\n            pass\n        else:\n            self.fail(\"setting Unitary with non-unitary did not raise\")\n\n    def test_set_init_with_unitary(self):\n        \"\"\"test instantiation of new unitary with another one (copy)\"\"\"\n        uni1 = UnitaryGate([[0, 1], [1, 0]])\n        uni2 = UnitaryGate(uni1)\n        self.assertEqual(uni1, uni2)\n        self.assertFalse(uni1 is uni2)\n\n    def test_conjugate(self):\n        \"\"\"test conjugate\"\"\"\n        ymat = numpy.array([[0, -1j], [1j, 0]])\n        uni = UnitaryGate([[0, 1j], [-1j, 0]])\n        self.assertTrue(numpy.array_equal(uni.conjugate().to_matrix(), ymat))\n\n    def test_adjoint(self):\n        \"\"\"test adjoint operation\"\"\"\n        uni = UnitaryGate([[0, 1j], [-1j, 0]])\n        self.assertTrue(numpy.array_equal(uni.adjoint().to_matrix(), uni.to_matrix()))\n\n\nclass TestUnitaryCircuit(QiskitTestCase):\n    \"\"\"Matrix gate circuit tests.\"\"\"\n\n    def test_1q_unitary(self):\n        \"\"\"test 1 qubit unitary matrix\"\"\"\n        qr = QuantumRegister(1)\n        cr = ClassicalRegister(1)\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        qc.x(qr[0])\n        qc.append(UnitaryGate(matrix), [qr[0]])\n        # test of qasm output\n        self.log.info(qc.qasm())\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        dag_nodes = dag.named_nodes(\"unitary\")\n        self.assertTrue(len(dag_nodes) == 1)\n        dnode = dag_nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0],))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n\n    def test_2q_unitary(self):\n        \"\"\"test 2 qubit unitary matrix\"\"\"\n        qr = QuantumRegister(2)\n        cr = ClassicalRegister(2)\n        qc = QuantumCircuit(qr, cr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmax, sigmay)\n        qc.x(qr[0])\n        uni2q = UnitaryGate(matrix)\n        qc.append(uni2q, [qr[0], qr[1]])\n        passman = PassManager()\n        passman.append(CXCancellation())\n        qc2 = passman.run(qc)\n        # test of qasm output\n        self.log.info(qc2.qasm())\n        # test of text drawer\n        self.log.info(qc2)\n        dag = circuit_to_dag(qc)\n        nodes = dag.two_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1]))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n        qc3 = dag_to_circuit(dag)\n        self.assertEqual(qc2, qc3)\n\n    def test_3q_unitary(self):\n        \"\"\"test 3 qubit unitary matrix on non-consecutive bits\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmay, numpy.kron(sigmax, sigmay))\n        qc.x(qr[0])\n        uni3q = UnitaryGate(matrix)\n        qc.append(uni3q, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        # test of text drawer\n        self.log.info(qc)\n        dag = circuit_to_dag(qc)\n        nodes = dag.multi_qubit_ops()\n        self.assertEqual(len(nodes), 1)\n        dnode = nodes[0]\n        self.assertIsInstance(dnode.op, UnitaryGate)\n        self.assertEqual(dnode.qargs, (qr[0], qr[1], qr[3]))\n        assert_allclose(dnode.op.to_matrix(), matrix)\n\n    def test_1q_unitary_int_qargs(self):\n        \"\"\"test single qubit unitary matrix with 'int' and 'list of ints' qubits argument\"\"\"\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmaz = numpy.array([[1, 0], [0, -1]])\n        # new syntax\n        qr = QuantumRegister(2)\n        qc = QuantumCircuit(qr)\n        qc.unitary(sigmax, 0)\n        qc.unitary(sigmax, qr[1])\n        qc.unitary(sigmaz, [0, 1])\n        # expected circuit\n        qc_target = QuantumCircuit(qr)\n        qc_target.append(UnitaryGate(sigmax), [0])\n        qc_target.append(UnitaryGate(sigmax), [qr[1]])\n        qc_target.append(UnitaryGate(sigmaz), [[0, 1]])\n        self.assertEqual(qc, qc_target)\n\n    def test_qobj_with_unitary_matrix(self):\n        \"\"\"test qobj output with unitary matrix\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmay, numpy.kron(sigmax, sigmay))\n        qc.rx(numpy.pi / 4, qr[0])\n        uni = UnitaryGate(matrix)\n        qc.append(uni, [qr[0], qr[1], qr[3]])\n        qc.cx(qr[3], qr[2])\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[1]\n        self.assertEqual(instr.name, \"unitary\")\n        assert_allclose(numpy.array(instr.params[0]).astype(numpy.complex64), matrix)\n        # check conversion to dict\n        qobj_dict = qobj.to_dict()\n\n        class NumpyEncoder(json.JSONEncoder):\n            \"\"\"Class for encoding json str with complex and numpy arrays.\"\"\"\n\n            def default(self, obj):  # pylint: disable=arguments-differ\n                if isinstance(obj, numpy.ndarray):\n                    return obj.tolist()\n                if isinstance(obj, complex):\n                    return (obj.real, obj.imag)\n                return json.JSONEncoder.default(self, obj)\n\n        # check json serialization\n        self.assertTrue(isinstance(json.dumps(qobj_dict, cls=NumpyEncoder), str))\n\n    def test_labeled_unitary(self):\n        \"\"\"test qobj output with unitary matrix\"\"\"\n        qr = QuantumRegister(4)\n        qc = QuantumCircuit(qr)\n        sigmax = numpy.array([[0, 1], [1, 0]])\n        sigmay = numpy.array([[0, -1j], [1j, 0]])\n        matrix = numpy.kron(sigmax, sigmay)\n        uni = UnitaryGate(matrix, label=\"xy\")\n        qc.append(uni, [qr[0], qr[1]])\n        qobj = qiskit.compiler.assemble(qc)\n        instr = qobj.experiments[0].instructions[0]\n        self.assertEqual(instr.name, \"unitary\")\n        self.assertEqual(instr.label, \"xy\")\n\n    def test_qasm_unitary_only_one_def(self):\n        \"\"\"test that a custom unitary can be converted to qasm and the\n        definition is only written once\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        unitary_gate = UnitaryGate(matrix, label=\"custom_gate\")\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0]])\n        qc.append(unitary_gate, [qr[1]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate custom_gate p0 {\\n\"\n            \"\\tu3(0,0,0) p0;\\n\"\n            \"}\\n\"\n            \"qreg q0[2];\\ncreg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"custom_gate q0[0];\\n\"\n            \"custom_gate q0[1];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_unitary_twice(self):\n        \"\"\"test that a custom unitary can be converted to qasm and that if\n        the qasm is called twice it is the same every time\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.array([[1, 0], [0, 1]])\n        unitary_gate = UnitaryGate(matrix, label=\"custom_gate\")\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0]])\n        qc.append(unitary_gate, [qr[1]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate custom_gate p0 {\\n\"\n            \"\\tu3(0,0,0) p0;\\n\"\n            \"}\\n\"\n            \"qreg q0[2];\\ncreg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"custom_gate q0[0];\\n\"\n            \"custom_gate q0[1];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_2q_unitary(self):\n        \"\"\"test that a 2 qubit custom unitary can be converted to qasm\"\"\"\n        qr = QuantumRegister(2, \"q0\")\n        cr = ClassicalRegister(1, \"c0\")\n        qc = QuantumCircuit(qr, cr)\n        matrix = numpy.asarray([[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0]])\n        unitary_gate = UnitaryGate(matrix, label=\"custom_gate\")\n\n        qc.x(qr[0])\n        qc.append(unitary_gate, [qr[0], qr[1]])\n        qc.append(unitary_gate, [qr[1], qr[0]])\n\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate custom_gate p0,p1 {\\n\"\n            \"\\tu3(pi,-pi/2,pi/2) p0;\\n\"\n            \"\\tu3(pi,pi/2,-pi/2) p1;\\n\"\n            \"}\\n\"\n            \"qreg q0[2];\\n\"\n            \"creg c0[1];\\n\"\n            \"x q0[0];\\n\"\n            \"custom_gate q0[0],q0[1];\\n\"\n            \"custom_gate q0[1],q0[0];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_qasm_unitary_noop(self):\n        \"\"\"Test that an identifier unitary can be converted to OpenQASM 2\"\"\"\n        qc = QuantumCircuit(QuantumRegister(3, \"q0\"))\n        qc.unitary(numpy.eye(8), qc.qubits, label=\"unitary_identity\")\n        expected_qasm = (\n            \"OPENQASM 2.0;\\n\"\n            'include \"qelib1.inc\";\\n'\n            \"gate unitary_identity p0,p1,p2 {\\n\"\n            \"}\\n\"\n            \"qreg q0[3];\\n\"\n            \"unitary_identity q0[0],q0[1],q0[2];\\n\"\n        )\n        self.assertEqual(expected_qasm, qc.qasm())\n\n    def test_unitary_decomposition(self):\n        \"\"\"Test decomposition for unitary gates over 2 qubits.\"\"\"\n        qc = QuantumCircuit(3)\n        qc.unitary(random_unitary(8, seed=42), [0, 1, 2])\n        self.assertTrue(Operator(qc).equiv(Operator(qc.decompose())))\n\n    def test_unitary_decomposition_via_definition(self):\n        \"\"\"Test decomposition for 1Q unitary via definition.\"\"\"\n        mat = numpy.array([[0, 1], [1, 0]])\n        self.assertTrue(numpy.allclose(Operator(UnitaryGate(mat).definition).data, mat))\n\n    def test_unitary_decomposition_via_definition_2q(self):\n        \"\"\"Test decomposition for 2Q unitary via definition.\"\"\"\n        mat = numpy.array([[0, 0, 1, 0], [0, 0, 0, -1], [1, 0, 0, 0], [0, -1, 0, 0]])\n        self.assertTrue(numpy.allclose(Operator(UnitaryGate(mat).definition).data, mat))\n\n    def test_unitary_control(self):\n        \"\"\"Test parameters of controlled - unitary.\"\"\"\n        mat = numpy.array([[0, 1], [1, 0]])\n        gate = UnitaryGate(mat).control()\n        self.assertTrue(numpy.allclose(gate.params, mat))\n        self.assertTrue(numpy.allclose(gate.base_gate.params, mat))\n",
  "circuit": "[[], [], []]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {},
    "uncompute": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[], [], []]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f38"
  },
  "id": "be884acd-1bf9-4e65-848e-5a90778dcaf5",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.randomized.test_synthesis.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Randomized tests of quantum synthesis.\"\"\"\nimport unittest\nfrom test.python.quantum_info.test_synthesis import CheckDecompositions\nfrom hypothesis import given, strategies, settings\nimport numpy as np\n\nfrom qiskit import execute\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister\nfrom qiskit.extensions import UnitaryGate\nfrom qiskit.providers.basicaer import UnitarySimulatorPy\nfrom qiskit.quantum_info.random import random_unitary\nfrom qiskit.quantum_info.synthesis.two_qubit_decompose import (\n    two_qubit_cnot_decompose,\n    TwoQubitBasisDecomposer,\n    Ud,\n)\n\n\nclass TestSynthesis(CheckDecompositions):\n    \"\"\"Test synthesis\"\"\"\n\n    seed = strategies.integers(min_value=0, max_value=2**32 - 1)\n    rotation = strategies.floats(min_value=-np.pi * 10, max_value=np.pi * 10)\n\n    @given(seed)\n    def test_1q_random(self, seed):\n        \"\"\"Checks one qubit decompositions\"\"\"\n        unitary = random_unitary(2, seed=seed)\n        self.check_one_qubit_euler_angles(unitary)\n        self.check_one_qubit_euler_angles(unitary, \"U3\")\n        self.check_one_qubit_euler_angles(unitary, \"U1X\")\n        self.check_one_qubit_euler_angles(unitary, \"PSX\")\n        self.check_one_qubit_euler_angles(unitary, \"ZSX\")\n        self.check_one_qubit_euler_angles(unitary, \"ZYZ\")\n        self.check_one_qubit_euler_angles(unitary, \"ZXZ\")\n        self.check_one_qubit_euler_angles(unitary, \"XYX\")\n        self.check_one_qubit_euler_angles(unitary, \"RR\")\n\n    @settings(deadline=None)\n    @given(seed)\n    def test_2q_random(self, seed):\n        \"\"\"Checks two qubit decompositions\"\"\"\n        unitary = random_unitary(4, seed=seed)\n        self.check_exact_decomposition(unitary.data, two_qubit_cnot_decompose)\n\n    @given(strategies.tuples(*[seed] * 5))\n    def test_exact_supercontrolled_decompose_random(self, seeds):\n        \"\"\"Exact decomposition for random supercontrolled basis and random target\"\"\"\n        k1 = np.kron(random_unitary(2, seed=seeds[0]).data, random_unitary(2, seed=seeds[1]).data)\n        k2 = np.kron(random_unitary(2, seed=seeds[2]).data, random_unitary(2, seed=seeds[3]).data)\n        basis_unitary = k1 @ Ud(np.pi / 4, 0, 0) @ k2\n        decomposer = TwoQubitBasisDecomposer(UnitaryGate(basis_unitary))\n        self.check_exact_decomposition(random_unitary(4, seed=seeds[4]).data, decomposer)\n\n    @given(strategies.tuples(*[rotation] * 6), seed)\n    def test_cx_equivalence_0cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with  0 cx gates locally equivalent to identity.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 0)\n\n    @given(strategies.tuples(*[rotation] * 12), seed)\n    def test_cx_equivalence_1cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 1 cx gates locally equivalent to a cx.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 1)\n\n    @given(strategies.tuples(*[rotation] * 18), seed)\n    def test_cx_equivalence_2cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 2 cx gates locally equivalent to some circuit with 2 cx.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        qc.cx(qr[0], qr[1])\n\n        qc.u(rnd[12], rnd[13], rnd[14], qr[0])\n        qc.u(rnd[15], rnd[16], rnd[17], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 2)\n\n    @given(strategies.tuples(*[rotation] * 24), seed)\n    def test_cx_equivalence_3cx_random(self, rnd, seed):\n        \"\"\"Check random circuits with 3 cx gates are outside the 0, 1, and 2 qubit regions.\"\"\"\n        qr = QuantumRegister(2, name=\"q\")\n        qc = QuantumCircuit(qr)\n\n        qc.u(rnd[0], rnd[1], rnd[2], qr[0])\n        qc.u(rnd[3], rnd[4], rnd[5], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[6], rnd[7], rnd[8], qr[0])\n        qc.u(rnd[9], rnd[10], rnd[11], qr[1])\n\n        qc.cx(qr[0], qr[1])\n\n        qc.u(rnd[12], rnd[13], rnd[14], qr[0])\n        qc.u(rnd[15], rnd[16], rnd[17], qr[1])\n\n        qc.cx(qr[1], qr[0])\n\n        qc.u(rnd[18], rnd[19], rnd[20], qr[0])\n        qc.u(rnd[21], rnd[22], rnd[23], qr[1])\n\n        sim = UnitarySimulatorPy()\n        unitary = execute(qc, sim, seed_simulator=seed).result().get_unitary()\n        self.assertEqual(two_qubit_cnot_decompose.num_basis_gates(unitary), 3)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 7
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1.5714285714285714
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1.5
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 11
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 8
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 785,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        },
        "timestamp": "2023-11-26T23:12:23.095+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": [
      {
        "id": 0,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[{\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 1,
        "position": {
          "qubit": 1,
          "column": 0,
          "fragment": "[[], [{\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 2,
        "position": {
          "qubit": 0,
          "column": 2,
          "fragment": "[[\"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 3,
        "position": {
          "qubit": 1,
          "column": 2,
          "fragment": "[[], [\"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 4,
        "position": {
          "qubit": 0,
          "column": 4,
          "fragment": "[[\"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 5,
        "position": {
          "qubit": 1,
          "column": 4,
          "fragment": "[[], [\"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 6,
        "position": {
          "qubit": 0,
          "column": 6,
          "fragment": "[[\"_\", \"_\", \"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      },
      {
        "id": 7,
        "position": {
          "qubit": 1,
          "column": 6,
          "fragment": "[[], [\"_\", \"_\", \"_\", \"_\", \"_\", \"_\", {\"ORACLE\": 1}]]"
        }
      }
    ],
    "uncompute": [
      {
        "id": 8,
        "position": {
          "qubit": 0,
          "column": 0,
          "fragment": "[[{\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 1}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}], [{\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}, \"X\", {\"ORACLE\": 1}, {\"CONTROL\": 0}, {\"ORACLE\": 1}]]"
        }
      }
    ]
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f3f"
  },
  "id": "7efa43a3-d697-4a51-8c84-ab7440b26bd8",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_test.python.transpiler.test_basic_swap.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Test the BasicSwap pass\"\"\"\n\nimport unittest\nfrom qiskit.transpiler.passes import BasicSwap\nfrom qiskit.transpiler import CouplingMap\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit import QuantumRegister, QuantumCircuit\nfrom qiskit.test import QiskitTestCase\n\n\nclass TestBasicSwap(QiskitTestCase):\n    \"\"\"Tests the BasicSwap pass.\"\"\"\n\n    def test_trivial_case(self):\n        \"\"\"No need to have any swap, the CX are distance 1 to each other\n        q0:--(+)-[U]-(+)-\n              |       |\n        q1:---.-------|--\n                      |\n        q2:-----------.--\n\n        CouplingMap map: [1]--[0]--[2]\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[1])\n        circuit.h(qr[0])\n        circuit.cx(qr[0], qr[2])\n\n        dag = circuit_to_dag(circuit)\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(dag, after)\n\n    def test_trivial_in_same_layer(self):\n        \"\"\"No need to have any swap, two CXs distance 1 to each other, in the same layer\n        q0:--(+)--\n              |\n        q1:---.---\n\n        q2:--(+)--\n              |\n        q3:---.---\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[2], qr[3])\n        circuit.cx(qr[0], qr[1])\n\n        dag = circuit_to_dag(circuit)\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(dag, after)\n\n    def test_a_single_swap(self):\n        \"\"\"Adding a swap\n        q0:-------\n\n        q1:--(+)--\n              |\n        q2:---.---\n\n        CouplingMap map: [1]--[0]--[2]\n\n        q0:--X---.---\n             |   |\n        q1:--X---|---\n                 |\n        q2:-----(+)--\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[1], qr[2])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[1], qr[0])\n        expected.cx(qr[0], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_a_single_swap_bigger_cm(self):\n        \"\"\"Swapper in a bigger coupling map\n        q0:-------\n\n        q1:---.---\n              |\n        q2:--(+)--\n\n        CouplingMap map: [1]--[0]--[2]--[3]\n\n        q0:--X---.---\n             |   |\n        q1:--X---|---\n                 |\n        q2:-----(+)--\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [0, 2], [2, 3]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[1], qr[2])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[1], qr[0])\n        expected.cx(qr[0], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_keep_layout(self):\n        \"\"\"After a swap, the following gates also change the wires.\n        qr0:---.---[H]--\n               |\n        qr1:---|--------\n               |\n        qr2:--(+)-------\n\n        CouplingMap map: [0]--[1]--[2]\n\n        qr0:--X-----------\n              |\n        qr1:--X---.--[H]--\n                  |\n        qr2:-----(+)------\n        \"\"\"\n        coupling = CouplingMap([[1, 0], [1, 2]])\n\n        qr = QuantumRegister(3, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[2])\n        circuit.h(qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[0], qr[1])\n        expected.cx(qr[1], qr[2])\n        expected.h(qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap(self):\n        \"\"\"A far swap that affects coming CXs.\n        qr0:--(+)---.--\n               |    |\n        qr1:---|----|--\n               |    |\n        qr2:---|----|--\n               |    |\n        qr3:---.---(+)-\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        qr0:--X--------------\n              |\n        qr1:--X--X-----------\n                 |\n        qr2:-----X--(+)---.--\n                     |    |\n        qr3:---------.---(+)-\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[0], qr[3])\n        circuit.cx(qr[3], qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[0], qr[1])\n        expected.swap(qr[1], qr[2])\n        expected.cx(qr[2], qr[3])\n        expected.cx(qr[3], qr[2])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_front(self):\n        \"\"\"A far swap with a gate in the front.\n        q0:------(+)--\n                  |\n        q1:-------|---\n                  |\n        q2:-------|---\n                  |\n        q3:--[H]--.---\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-----------(+)--\n                       |\n        q1:---------X--.---\n                    |\n        q2:------X--X------\n                 |\n        q3:-[H]--X---------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.h(qr[3])\n        circuit.cx(qr[3], qr[0])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.h(qr[3])\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_back(self):\n        \"\"\"A far swap with a gate in the back.\n        q0:--(+)------\n              |\n        q1:---|-------\n              |\n        q2:---|-------\n              |\n        q3:---.--[H]--\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-------(+)------\n                   |\n        q1:-----X--.--[H]--\n                |\n        q2:--X--X----------\n             |\n        q3:--X-------------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[3], qr[0])\n        circuit.h(qr[3])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n        expected.h(qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n    def test_far_swap_with_gate_the_middle(self):\n        \"\"\"A far swap with a gate in the middle.\n        q0:--(+)-------.--\n              |        |\n        q1:---|--------|--\n              |\n        q2:---|--------|--\n              |        |\n        q3:---.--[H]--(+)-\n\n        CouplingMap map: [0]--[1]--[2]--[3]\n\n        q0:-------(+)-------.---\n                   |        |\n        q1:-----X--.--[H]--(+)--\n                |\n        q2:--X--X---------------\n             |\n        q3:--X------------------\n\n        \"\"\"\n        coupling = CouplingMap([[0, 1], [1, 2], [2, 3]])\n\n        qr = QuantumRegister(4, \"q\")\n        circuit = QuantumCircuit(qr)\n        circuit.cx(qr[3], qr[0])\n        circuit.h(qr[3])\n        circuit.cx(qr[0], qr[3])\n        dag = circuit_to_dag(circuit)\n\n        expected = QuantumCircuit(qr)\n        expected.swap(qr[3], qr[2])\n        expected.swap(qr[2], qr[1])\n        expected.cx(qr[1], qr[0])\n        expected.h(qr[1])\n        expected.cx(qr[0], qr[1])\n\n        pass_ = BasicSwap(coupling)\n        after = pass_.run(dag)\n\n        self.assertEqual(circuit_to_dag(expected), after)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "circuit": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0.75
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 6
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0.3333333333333333
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 786,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[\"X\", \"_\", {\"CONTROL\": 3}, \"X\", \"_\", {\"CONTROL\": 1}], [\"_\", \"_\", \"_\", {\"CONTROL\": 0}, \"H\", \"X\"], [], [{\"CONTROL\": 0}, \"H\", \"X\"]]"
        },
        "timestamp": "2023-11-26T23:13:52.286+00:00"
      },
      "value": 0
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17f4d"
  },
  "id": "39faf531-eb1b-40da-8e93-171f171d644b",
  "language": "Python",
  "extension": "qiskit",
  "author": "sethuquantum",
  "name": "LearnQuantum",
  "path": "Python_qiskit_sethuquantum_LearnQuantum_qiskit.circuit.library.standard_gates.t.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"T and Tdg gate.\"\"\"\nimport math\nfrom typing import Optional\nimport numpy\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\n\n\nclass TGate(Gate):\n    r\"\"\"Single qubit T gate (Z**0.25).\n\n    It induces a :math:`\\pi/4` phase, and is sometimes called the pi/8 gate\n    (because of how the RZ(\\pi/4) matrix looks like).\n\n    This is a non-Clifford gate and a fourth-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.t` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        T = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & e^{i\\pi/4}\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ T ├\n             └───┘\n\n    Equivalent to a :math:`\\pi/4` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new T gate.\"\"\"\n        super().__init__(\"t\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate t a { u1(pi/4) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi / 4), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse T gate (i.e. Tdg).\"\"\"\n        return TdgGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the T gate.\"\"\"\n        return numpy.array([[1, 0], [0, (1 + 1j) / numpy.sqrt(2)]], dtype=dtype)\n\n\nclass TdgGate(Gate):\n    r\"\"\"Single qubit T-adjoint gate (~Z**0.25).\n\n    It induces a :math:`-\\pi/4` phase.\n\n    This is a non-Clifford gate and a fourth-root of Pauli-Z.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.tdg` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Tdg = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & e^{-i\\pi/4}\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌─────┐\n        q_0: ┤ Tdg ├\n             └─────┘\n\n    Equivalent to a :math:`-\\pi/4` radian rotation about the Z axis.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Tdg gate.\"\"\"\n        super().__init__(\"tdg\", 1, [], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate tdg a { u1(pi/4) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(-pi / 4), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse Tdg gate (i.e. T).\"\"\"\n        return TGate()\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the inverse T gate.\"\"\"\n        return numpy.array([[1, 0], [0, (1 - 1j) / math.sqrt(2)]], dtype=dtype)\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17fa7"
  },
  "id": "48df79ee-955b-4b98-94e8-87f6ededa932",
  "language": "Python",
  "extension": "qiskit",
  "author": "benkoehlL",
  "name": "Qiskit_Playground",
  "path": "Python_qiskit_benkoehlL_Qiskit_Playground_logic_gates_creator.py",
  "hybrid": true,
  "content": "'''\nThis program creates a .tex file of several classical logic gates\n'''\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nimport os\nimport shutil\n\nlogic_folder = os.getcwd()\nLaTex_folder_logic_gates = str(os.getcwd())+'/Latex_quantum_gates/logic_gates/'\nif not os.path.exists(LaTex_folder_logic_gates):\n    os.makedirs(LaTex_folder_logic_gates)\nelse:\n    shutil.rmtree(LaTex_folder_logic_gates)\n    os.makedirs(LaTex_folder_logic_gates)\nprint(LaTex_folder_logic_gates)\n## NOT gate\nq = QuantumRegister(1, name='q')\nc = ClassicalRegister(1, name='c')\nqc = QuantumCircuit(q,c)\nqc.x(q[0])\nqc.measure(q[0],c[0])\nLaTex_code = qc.draw(output='latex_source', justify=None) # draw the circuit\nf_name = 'NOT_gate.tex'\nwith open(LaTex_folder_logic_gates+f_name, 'w') as f:\n            f.write(LaTex_code)\n## AND gate\nq = QuantumRegister(3, name='q')\nqubit_state = '0'\nc = ClassicalRegister(1, name='c')\nqc = QuantumCircuit(q,c)\nqc.reset(q[2])\nqc.ccx(q[0], q[1], q[2])\nqc.measure(q[2], c[0])\nLaTex_code = qc.draw(output='latex_source', justify=None) # draw the circuit\nf_name = 'AND_gate.tex'\nwith open(LaTex_folder_logic_gates+f_name, 'w') as f:\n            f.write(LaTex_code)\n\n## OR gate\nq = QuantumRegister(3, name='q')\nc = ClassicalRegister(1, name='c')\nqc = QuantumCircuit(q,c)\nqc.reset(q[2])\nqc.ccx(q[0], q[1], q[2])\nqc.cx(q[0],q[2])\nqc.cx(q[1],q[2])\nqc.measure(q[2],c[0])\nLaTex_code = qc.draw(output='latex_source', justify=None) # draw the circuit\nf_name = 'OR_gate.tex'\nwith open(LaTex_folder_logic_gates+f_name, 'w') as f:\n            f.write(LaTex_code)\n\n## XOR gate\nq = QuantumRegister(3, name='q')\nc = ClassicalRegister(1, name='c')\nqc = QuantumCircuit(q,c)\nqc.reset(q[2])\nqc.cx(q[0],q[2])\nqc.cx(q[1],q[2])\nqc.measure(q[2],c[0])\nLaTex_code = qc.draw(output='latex_source', justify=None) # draw the circuit\nf_name = 'XOR_gate.tex'\nwith open(LaTex_folder_logic_gates+f_name, 'w') as f:\n            f.write(LaTex_code)\n\n## NOR gate\nq = QuantumRegister(3, name='q')\nc = ClassicalRegister(1, name='c')\nqc = QuantumCircuit(q,c)\nqc.reset(q[2])\nqc.ccx(q[0], q[1], q[2])\nqc.cx(q[0],q[2])\nqc.cx(q[1],q[2])\nqc.x(q[2])\nqc.measure(q[2],c[0])\nLaTex_code = qc.draw(output='latex_source', justify=None) # draw the circuit\nf_name = 'NOR_gate.tex'\nwith open(LaTex_folder_logic_gates+f_name, 'w') as f:\n            f.write(LaTex_code)",
  "circuit": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0.6666666666666666
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 2
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0.5
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 788,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[{\"CONTROL\": 2}], [\"_\", {\"CONTROL\": 2}], [\"X\", \"X\", \"X\", \"MEASURE\"]]"
        },
        "timestamp": "2023-11-26T23:15:38.442+00:00"
      },
      "value": 0.3333333333333333
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cb9c1f7ee332e17faa"
  },
  "id": "62de8b6d-c265-435c-87dc-0d099aaffa62",
  "language": "Python",
  "extension": "qiskit",
  "author": "benkoehlL",
  "name": "Qiskit_Playground",
  "path": "Python_qiskit_benkoehlL_Qiskit_Playground_quantum_k_means.py",
  "hybrid": true,
  "content": "'''\nThis program realises the quantum k-means algorithm\n'''\n\nimport numpy as np\nfrom qiskit import *\nfrom qiskit.tools.visualization import plot_histogram\nfrom matplotlib.pyplot import plot, draw, show\n\ncircuit_name = 'k_means'\n\nbackend = Aer.get_backend('qasm_simulator')\ntheta_list = [0.01, 0.02, 0.03, 0.04, 0.05,\n             1.31, 1.32, 1.33, 1.34, 1.35]\n\nqr = QuantumRegister(5,'q')\ncr = ClassicalRegister(5, 'c')\nqc = QuantumCircuit(qr, cr, name=circuit_name)\n\n# define a loop to compute the distance between each pair of points\nfor i in range(len(theta_list)-1):\n    for j in range(1,len(theta_list)-i):\n        # set the parameters theta about different points\n        theta_1 = theta_list[i]\n        theta_2 = theta_list[i+j]\n\n        qc.h(qr[2])\n        qc.h(qr[1])\n        qc.h(qr[4])\n        qc.u3(theta_1, np.pi, np.pi, qr[1])\n        qc.u3(theta_2, np.pi, np.pi, qr[4])\n        qc.cswap(qr[2], qr[1], qr[4])\n        qc.h(qr[2])\n\n        qc.measure(qr[2], cr[2])\n        qc.reset(qr)\n\n        job = execute(qc, backend=backend, shots=1024)\n        result = job.result()\n        print(result.get_counts())\n        print('theta_1: ', theta_1, '\\t', 'theta_2: ', theta_2)\nplot_histogram(result.get_counts())\n",
  "circuit": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]",
  "metrics": [
    {
      "metric": {
        "id": 1,
        "name": "Width",
        "description": "Number of qubits in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 2,
        "name": "Depth",
        "description": "Maximum number of operations applied to a qubit in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 3,
        "name": "MaxDens",
        "description": "Maximum number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 3
    },
    {
      "metric": {
        "id": 4,
        "name": "AvgDens",
        "description": "Average of the number of operations applied to the circuit qubits in parallel",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 1.6666666666666667
    },
    {
      "metric": {
        "id": 5,
        "name": "NoP-X",
        "description": "Number of Pauli-X (NOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 6,
        "name": "NoP-Y",
        "description": "Number of Pauli-Y gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 7,
        "name": "NoP-Z",
        "description": "Number of Pauli-Z gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 8,
        "name": "TNo-P",
        "description": "Total number of Pauli gates in the circuit (calculated as the addition of the previous three)",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 9,
        "name": "NoH",
        "description": "Number of Hadamard gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 4
    },
    {
      "metric": {
        "id": 10,
        "name": "%SpposQ",
        "description": "Ratio of qubits with a Hadamard gate as initial gate (qubits in superposition state)",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0.6
    },
    {
      "metric": {
        "id": 11,
        "name": "NoOtherSG",
        "description": "Number of other single-qubit gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 12,
        "name": "TNoSQG",
        "description": "Total number of single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 13,
        "name": "TNoCSQG",
        "description": "Total number of controlled single-qubit gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 14,
        "name": "NoSWAP",
        "description": "Number of swap gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 15,
        "name": "NoCNOT",
        "description": "Number of Controlled NOT (CNOT) gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 16,
        "name": "%QInCNOT",
        "description": "Ratio of qubits affected by CNOT gates (both the controlled and the target qubit in a CNOT will be considered as affected for the calculation of this metric)",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 17,
        "name": "AvgCNOT",
        "description": "Average number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 18,
        "name": "MaxCNOT",
        "description": "Maximum number of CNOT gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 19,
        "name": "NoToff",
        "description": "Number of Toffoli gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 20,
        "name": "%QInToff",
        "description": "Ratio of qubits affected by Toffoli gates (the controlled qubit and the target qubits will be taken into account as affected for the calculation)",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 21,
        "name": "AvgToff",
        "description": "Average number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 22,
        "name": "MaxToff",
        "description": "Maximum number of Toffoli gates targeting any qubit of a circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 23,
        "name": "NoGates",
        "description": "Total number of gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 5
    },
    {
      "metric": {
        "id": 24,
        "name": "NoCGates",
        "description": "Total number of controlled gates in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 25,
        "name": "%SGates",
        "description": "Ratio single vs total gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 26,
        "name": "NoOr",
        "description": "Number of oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 27,
        "name": "NoCOr",
        "description": "Number of controlled oracles in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 28,
        "name": "%QInOr",
        "description": "Ratio of qubits affected by oracles. Only the non-controlled qubits of the oracle will be considered as affected for this metric.",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 29,
        "name": "%QInCOr",
        "description": "Ratio of qubits affected by controlled oracles",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 30,
        "name": "AvgOrD",
        "description": "Average depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 31,
        "name": "MaxOrD",
        "description": "Maximum depth of an oracle in the circuit",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0
    },
    {
      "metric": {
        "id": 32,
        "name": "NoM",
        "description": "Number of measurement gates",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 1
    },
    {
      "metric": {
        "id": 33,
        "name": "%QM",
        "description": "Ratio of qubits measured",
        "metricType": null
      },
      "measurement": {
        "id": 789,
        "circuit": {
          "id": 55,
          "name": "MiriamTFGCircuit",
          "circuitCode": "[[], [\"H\"], [\"H\", \"H\", \"MEASURE\"], [], [\"H\"]]"
        },
        "timestamp": "2023-11-26T23:15:53.519+00:00"
      },
      "value": 0.2
    }
  ],
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cc9c1f7ee332e18023"
  },
  "id": "3d846d81-2325-477d-a984-73228bf63353",
  "language": "Python",
  "extension": "qiskit",
  "author": "Priyanshusinhaa",
  "name": "Super-Circuit",
  "path": "Python_qiskit_Priyanshusinhaa_Super-Circuit_Environment.Lib.site-packages.qiskit.circuit.library.standard_gates.ry.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Rotation around the Y axis.\"\"\"\n\nimport math\nfrom typing import Optional, Union\nimport numpy\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\n\n\nclass RYGate(Gate):\n    r\"\"\"Single-qubit rotation about the Y axis.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ry` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───────┐\n        q_0: ┤ Ry(ϴ) ├\n             └───────┘\n\n    **Matrix Representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        RY(\\theta) = \\exp\\left(-i \\th Y\\right) =\n            \\begin{pmatrix}\n                \\cos{\\th} & -\\sin{\\th} \\\\\n                \\sin{\\th} & \\cos{\\th}\n            \\end{pmatrix}\n    \"\"\"\n\n    def __init__(self, theta: ParameterValueType, label: Optional[str] = None):\n        \"\"\"Create new RY gate.\"\"\"\n        super().__init__(\"ry\", 1, [theta], label=label)\n\n    def _define(self):\n        \"\"\"\n        gate ry(theta) a { r(theta, pi/2) a; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .r import RGate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(RGate(self.params[0], pi / 2), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-RY gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CRYGate(self.params[0], label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        r\"\"\"Return inverted RY gate.\n\n        :math:`RY(\\lambda){\\dagger} = RY(-\\lambda)`\n        \"\"\"\n        return RYGate(-self.params[0])\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the RY gate.\"\"\"\n        cos = math.cos(self.params[0] / 2)\n        sin = math.sin(self.params[0] / 2)\n        return numpy.array([[cos, -sin], [sin, cos]], dtype=dtype)\n\n\nclass CRYGate(ControlledGate):\n    r\"\"\"Controlled-RY gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cry` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ────■────\n             ┌───┴───┐\n        q_1: ┤ Ry(ϴ) ├\n             └───────┘\n\n    **Matrix representation:**\n\n    .. math::\n\n        \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n        CRY(\\theta)\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + RY(\\theta) \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0         & 0 & 0 \\\\\n                0 & \\cos{\\th} & 0 & -\\sin{\\th} \\\\\n                0 & 0         & 1 & 0 \\\\\n                0 & \\sin{\\th} & 0 & \\cos{\\th}\n            \\end{pmatrix}\n\n    .. note::\n\n        In Qiskit's convention, higher qubit indices are more significant\n        (little endian convention). In many textbooks, controlled gates are\n        presented with the assumption of more significant qubits as control,\n        which in our case would be q_1. Thus a textbook matrix for this\n        gate will be:\n\n        .. parsed-literal::\n                 ┌───────┐\n            q_0: ┤ Ry(ϴ) ├\n                 └───┬───┘\n            q_1: ────■────\n\n        .. math::\n\n            \\newcommand{\\th}{\\frac{\\theta}{2}}\n\n            CRY(\\theta)\\ q_1, q_0 =\n            |0\\rangle\\langle 0| \\otimes I + |1\\rangle\\langle 1| \\otimes RY(\\theta) =\n                \\begin{pmatrix}\n                    1 & 0 & 0 & 0 \\\\\n                    0 & 1 & 0 & 0 \\\\\n                    0 & 0 & \\cos{\\th} & -\\sin{\\th} \\\\\n                    0 & 0 & \\sin{\\th} & \\cos{\\th}\n                \\end{pmatrix}\n    \"\"\"\n\n    def __init__(\n        self,\n        theta: ParameterValueType,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Create new CRY gate.\"\"\"\n        super().__init__(\n            \"cry\",\n            2,\n            [theta],\n            num_ctrl_qubits=1,\n            label=label,\n            ctrl_state=ctrl_state,\n            base_gate=RYGate(theta),\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cry(lambda) a,b\n        { u3(lambda/2,0,0) b; cx a,b;\n          u3(-lambda/2,0,0) b; cx a,b;\n        }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .x import CXGate\n\n        # q_0: ─────────────■───────────────■──\n        #      ┌─────────┐┌─┴─┐┌─────────┐┌─┴─┐\n        # q_1: ┤ Ry(λ/2) ├┤ X ├┤ Ry(λ/2) ├┤ X ├\n        #      └─────────┘└───┘└─────────┘└───┘\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [\n            (RYGate(self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n            (RYGate(-self.params[0] / 2), [q[1]], []),\n            (CXGate(), [q[0], q[1]], []),\n        ]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverse CRY gate (i.e. with the negative rotation angle).\"\"\"\n        return CRYGate(-self.params[0], ctrl_state=self.ctrl_state)\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CRY gate.\"\"\"\n        half_theta = float(self.params[0]) / 2\n        cos = math.cos(half_theta)\n        sin = math.sin(half_theta)\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, cos, 0, -sin], [0, 0, 1, 0], [0, sin, 0, cos]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[cos, 0, -sin, 0], [0, 1, 0, 0], [sin, 0, cos, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
},
{
  "_id": {
    "$oid": "6563b5cc9c1f7ee332e180b2"
  },
  "id": "a91a404c-e727-485a-a032-67eca856be65",
  "language": "Python",
  "extension": "qiskit",
  "author": "Priyanshusinhaa",
  "name": "Super-Circuit",
  "path": "Python_qiskit_Priyanshusinhaa_Super-Circuit_Environment.Lib.site-packages.qiskit.circuit.library.standard_gates.z.py",
  "hybrid": true,
  "content": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Z, CZ and CCZ gates.\"\"\"\n\nfrom typing import Optional, Union\nimport numpy\nfrom qiskit.qasm import pi\nfrom qiskit.circuit.controlledgate import ControlledGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumregister import QuantumRegister\nfrom qiskit.circuit._utils import _compute_control_matrix\n\n\nclass ZGate(Gate):\n    r\"\"\"The single-qubit Pauli-Z gate (:math:`\\sigma_z`).\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.z` method.\n\n    **Matrix Representation:**\n\n    .. math::\n\n        Z = \\begin{pmatrix}\n                1 & 0 \\\\\n                0 & -1\n            \\end{pmatrix}\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n             ┌───┐\n        q_0: ┤ Z ├\n             └───┘\n\n    Equivalent to a :math:`\\pi` radian rotation about the Z axis.\n\n    .. note::\n\n        A global phase difference exists between the definitions of\n        :math:`RZ(\\pi)` and :math:`Z`.\n\n        .. math::\n\n            RZ(\\pi) = \\begin{pmatrix}\n                        -1 & 0 \\\\\n                        0 & 1\n                      \\end{pmatrix}\n                    = -Z\n\n    The gate is equivalent to a phase flip.\n\n    .. math::\n\n        |0\\rangle \\rightarrow |0\\rangle \\\\\n        |1\\rangle \\rightarrow -|1\\rangle\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None):\n        \"\"\"Create new Z gate.\"\"\"\n        super().__init__(\"z\", 1, [], label=label)\n\n    def _define(self):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .u1 import U1Gate\n\n        q = QuantumRegister(1, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(U1Gate(pi), [q[0]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: Optional[str] = None,\n        ctrl_state: Optional[Union[str, int]] = None,\n    ):\n        \"\"\"Return a (multi-)controlled-Z gate.\n\n        One control returns a CZ gate.\n\n        Args:\n            num_ctrl_qubits (int): number of control qubits.\n            label (str or None): An optional label for the gate [Default: None]\n            ctrl_state (int or str or None): control state expressed as integer,\n                string (e.g. '110'), or None. If None, use all 1s.\n\n        Returns:\n            ControlledGate: controlled version of this gate.\n        \"\"\"\n        if num_ctrl_qubits == 1:\n            gate = CZGate(label=label, ctrl_state=ctrl_state)\n            gate.base_gate.label = self.label\n            return gate\n        return super().control(num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n\n    def inverse(self):\n        \"\"\"Return inverted Z gate (itself).\"\"\"\n        return ZGate()  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the Z gate.\"\"\"\n        return numpy.array([[1, 0], [0, -1]], dtype=dtype)\n\n\nclass CZGate(ControlledGate):\n    r\"\"\"Controlled-Z gate.\n\n    This is a Clifford and symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.cz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CZ\\ q_0, q_1 =\n            I \\otimes |0\\rangle\\langle 0| + Z \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubit is in the :math:`|1\\rangle` state.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CZ gate.\"\"\"\n        super().__init__(\n            \"cz\", 2, [], label=label, num_ctrl_qubits=1, ctrl_state=ctrl_state, base_gate=ZGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate cz a,b { h b; cx a,b; h b; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .h import HGate\n        from .x import CXGate\n\n        q = QuantumRegister(2, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[1]], []), (CXGate(), [q[0], q[1]], []), (HGate(), [q[1]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CZ gate (itself).\"\"\"\n        return CZGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CZ gate.\"\"\"\n        if self.ctrl_state:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]], dtype=dtype\n            )\n        else:\n            return numpy.array(\n                [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]], dtype=dtype\n            )\n\n\nclass CCZGate(ControlledGate):\n    r\"\"\"CCZ gate.\n\n    This is a symmetric gate.\n\n    Can be applied to a :class:`~qiskit.circuit.QuantumCircuit`\n    with the :meth:`~qiskit.circuit.QuantumCircuit.ccz` method.\n\n    **Circuit symbol:**\n\n    .. parsed-literal::\n\n        q_0: ─■─\n              │\n        q_1: ─■─\n              │\n        q_2: ─■─\n\n    **Matrix representation:**\n\n    .. math::\n\n        CCZ\\ q_0, q_1, q_2 =\n            I \\otimes I \\otimes |0\\rangle\\langle 0| + CZ \\otimes |1\\rangle\\langle 1| =\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 & 0 & 0 & -1\n            \\end{pmatrix}\n\n    In the computational basis, this gate flips the phase of\n    the target qubit if the control qubits are in the :math:`|11\\rangle` state.\n    \"\"\"\n\n    def __init__(self, label: Optional[str] = None, ctrl_state: Optional[Union[str, int]] = None):\n        \"\"\"Create new CCZ gate.\"\"\"\n        super().__init__(\n            \"ccz\", 3, [], label=label, num_ctrl_qubits=2, ctrl_state=ctrl_state, base_gate=ZGate()\n        )\n\n    def _define(self):\n        \"\"\"\n        gate ccz a,b,c { h c; ccx a,b,c; h c; }\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit.quantumcircuit import QuantumCircuit\n        from .h import HGate\n        from .x import CCXGate\n\n        q = QuantumRegister(3, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        rules = [(HGate(), [q[2]], []), (CCXGate(), [q[0], q[1], q[2]], []), (HGate(), [q[2]], [])]\n        for instr, qargs, cargs in rules:\n            qc._append(instr, qargs, cargs)\n\n        self.definition = qc\n\n    def inverse(self):\n        \"\"\"Return inverted CCZ gate (itself).\"\"\"\n        return CCZGate(ctrl_state=self.ctrl_state)  # self-inverse\n\n    def __array__(self, dtype=None):\n        \"\"\"Return a numpy.array for the CCZ gate.\"\"\"\n        mat = _compute_control_matrix(\n            self.base_gate.to_matrix(), self.num_ctrl_qubits, ctrl_state=self.ctrl_state\n        )\n        if dtype is not None:\n            return numpy.asarray(mat, dtype=dtype)\n        return mat\n",
  "circuit": "[[]]",
  "metrics": {
    "error": "QMetrics couldn't calculate the metrics"
  },
  "patterns": {
    "initialization": {},
    "superposition": {},
    "entanglement": {},
    "oracle": {}
  }
}]